h3. Wyświetlanie błędów walidacji w podglądzie

Railsy oferują wbudowane helpery do wyświetlania powiadomień o błędach twojego modelu w widoku szablonów. 

h4. +error_messages+ i +error_messages_for+ 

Podczas tworzenia formularza z aplikacją pomocniczą +form_for+ możesz użyć metody +error_messages+ podczas generowania formularza, aby wyświetlić wszystkie komunikaty błędów dla obecnej postaci modelu. 

<ruby>
class Product < ActiveRecord::Base
  validates_presence_of :description, :value
  validates_numericality_of :value, :allow_nil => true
end
</ruby>

<erb>
<% form_for(@product) do |f| %>
  <%= f.error_messages %>
  <p>
    <%= f.label :description %><br />
    <%= f.text_field :description %>
  </p>
  <p>
    <%= f.label :value %><br />
    <%= f.text_field :value %>
  </p>
  <p>
    <%= f.submit "Create" %>
  </p>
<% end %>
</erb>

Aby zrozumieć sposób działania: jeśli wyślesz formularz z pustymi polami, zazwyczaj wrócisz do niego i niezależnie od tego jakie są style, brakujące pola zostaną oznaczone domyślnie:

!images/error_messages.png(Error messages)!

Do wyświetlania komunikatów błędów modelu możesz użyć również metody +error_messages_for+. Jest bardzo podobna do poprzedniego przykładu i daje dokładnie taki sam rezultat.

<erb>
<%= error_messages_for :product %>
</erb>

Wyświetlany dla każdego komunikatu błędu tekst będzie się zawsze składał z wypisanej wielkimi literami nazwy atrybutu, w którym występuje błąd, oraz właściwej treści komunikatu.

Obydwa helpery, zarówno +form.error_messages+ jak i +error_messages_for+, zawierają opcję umożliwiającą przystosowywanie bloku +div+, w którym wyświetlane są komunikaty o błędach, zmianę jego nagłówka, wiadomości wyświetlającej się pod nagłówkiem oraz tagu używanego do elementu zawierającego nagłówek.

<erb>
<%= f.error_messages :header_message => "Invalid product!",
  :message => "You'll need to fix the following fields:",
  :header_tag => :h3 %>
</erb> 

Skutkuje to pojawieniem się następujących treści:

!images/customized_error_messages.png(Customized error messages)!

Jeżeli przypiszesz +nil+ do którejś z tych pozycji, pozbawi to element +div+ indywidualnego charakteru danej pozycji.

h4. Personalizowanie komunikatów błędów za pomocą CSS 

Selektorami personalizowania komunikatów błędów są: 

* +.fieldWithErrors+ - styl dla pól i linii z błędami 
* +#errorExplanation+ - styl dla elementów +div+ zawierających komunikaty błędów 
* +#errorExplanation h2+ - styl dla nagłówka elementu +div+ 
* +#errorExplanation p+ - styl akapitu zawierającego komunikat błędu, znajdującego się zaraz pod nagłówkiem elementu +div+ 
* +#errorExplanation ul li+ - styl listy pozycji z wyszczególnionymi komunikatami błędów 

Rusztowanie generuje na przykład +public/stylesheets/scaffold.css+, który określa ten "czerwony" styl, który widziałeś powyżej. 

Nazwa klasy oraz id może być zmieniona za pomocą opcji +:class+ oraz +:id+, co jest obsługiwane przez obydwie metody.

h4. Personalizowanie komunikatów błędów za pomocą HTML 

Domyślnie pola formularza z błedami są wyświetlane wewnątrz bloku +div+ o klasie CSS +fieldWithErrors+. Tak czy inaczej, można to obejść.

Sposób, w jaki traktowane są pola formularza z błędami, jest określony przez +ActionView::Base.field_error_proc+. Jest to +Proc+, który otrzymuje dwa parametry:
 
* łańcuch znaków z tagiem HTML 
* instancję +ActionView::Helpers::InstanceTag+ 

Oto prosty przykład gdzie zmieniamy zachowanie Railsów tak, aby zawsze wyświetlać komunikaty błędów przed każdym polem formularza z błędem. Komunikaty błędów będą zawarte w bloku +span+ o klasie CSS +validation-error+. Nie będzie bloku +div+ zawierającego element +input+, więc pozbywamy sie czerwonego obramowania dookoła pola tekstowego. Możesz użyc klasy CSS +validation-error+, aby wystylizować je jak chcesz.

<ruby>
ActionView::Base.field_error_proc = Proc.new do |html_tag, instance|
  if instance.error_message.kind_of?(Array)
    %(#{html_tag}<span class="validation-error">&nbsp;
      #{instance.error_message.join(',')}</span>)
  else
    %(#{html_tag}<span class="validation-error">&nbsp;
      #{instance.error_message}</span>)
  end
end
</ruby>

Skutkuje to pojawieniem się czegoś podobnego do następującej treści:

!images/validation_error_messages.png(Validation error messages)!

h3. Przegląd callbacków 

Callbacki są metodami przywoływanymi w pewnych momentach cyklu życia obiektu. Dzięki callbackom możliwe jest napisanie kodu, który zadziała, kiedykolwiek obiekt modułu Active Record zostanie utworzony, zachowany, zaktualizowany, usunięty, zwalidowany lub załadowany z bazy danych. 

h4. Rejestracja callbacków 

Aby używać dostępnych callbacków, musisz je najpierw zarejestrować. Możesz to zrobić implementując je jako zwykłe metody, a potem użyć metody makrostylowych klas, aby zarejestrować je jako callbacki.

<ruby>
class User < ActiveRecord::Base
  validates_presence_of :login, :email

  before_validation :ensure_login_has_a_value

  protected
  def ensure_login_has_a_value
    if login.nil?
      self.login = email unless email.blank?
    end
  end
end
</ruby>

Metody makrostylowych klas mogą również otrzymywać bloki. Rozważ używanie tych stylów, jeśli kod wewnątrz twojego bloku jest tak krótki, że mieści się w jednej linii.

<ruby>
class User < ActiveRecord::Base
  validates_presence_of :login, :email

  before_create {|user| user.name = user.login.capitalize 
	if user.name.blank?}
end
</ruby>

Deklarowanie callbacków w strefie chronionej lub prywatnej uważa się za dobrą praktykę. Jeśli zostanie to zrobione w strefie publicznej, mogą one zostać wywołane spoza modelu i naruszają zasadę jego enkapsulacji.

h3. Dostępne callbacki

Oto lista dostępnych callbacków modułu Active Records, wypisanych w tej samej kolejności, w której są wywoływane podczas poszczególnych operacji: 

h4. Tworzenie obiektu 

* +before_validation+
* +before_validation_on_create+
* +after_validation+
* +after_validation_on_create+
* +before_save+
* +before_create+
* INSERT OPERATION
* +after_create+
* +after_save+

h4. Aktualizowanie obiektu 

* +before_validation+
* +before_validation_on_update+
* +after_validation+
* +after_validation_on_update+
* +before_save+
* +before_update+
* UPDATE OPERATION
* +after_update+
* +after_save+

h4. Usuwanie obiektu 

* +before_destroy+
* DELETE OPERATION
* +after_destroy+


WARNING. +after_save+ działa i podczas tworzenia i aktualizowania, ale zawsze po bardziej specyficznych callbackach +after_create+ i +after_update+, nie ważne w jakiej kolejności wykonywane były makrowywołania. 

h4. +after_initialize+ i +after_find+
 
Callback +after_initialize+ jest wywoływany kiedykolwiek zostaje utworzony egzemplarz obiektu modułu Active Records. Jest to użyteczne do uniknięcia pominięcia metody +initialize+ modułu Active Record.

Callback +after_find+ jest uruchamiany kiedykolwiek rekord zostaje załadowany z bazy danych. +after_find+ jest wywoływana przed +after_initialize+, jeżeli zdefiniowane są obydwie z tych metod.

Callbacki +after_initialize+ i +after_find+ są trochę inne niż pozostałe. Nie mają odpowiedników +before_*+, a jedynym sposobem na ich rejestrację jest zdefiniowanie ich jako zwykłych metod. Jeżeli spróbujesz zarejestrować je jako metody klasy makrostylowej, zostaną one po prostu pominięte. Takie zachowanie spowodowane jest kwestiami związanymi z wydajnością, odkąd +after_initialize+ i +after_find+ są wywoływane przy każdym odnalezieniu rekordu w bazie, spowalniając znacząco zapytania.

<ruby>
class User < ActiveRecord::Base
  def after_initialize
    puts "You have initialized an object!"
  end

  def after_find
    puts "You have found an object!"
  end
end

>> User.new
You have initialized an object!
=> #<User id: nil>

>> User.first
You have found an object!
You have initialized an object!
=> #<User id: 1>
</ruby>

h3. Uruchamianie callbacków

Następujące metody uruchamiają callbacki: 

* +create+
* +create!+
* +decrement!+
* +destroy+
* +destroy_all+
* +increment!+
* +save+
* +save!+
* +save(false)+
* +toggle!+
* +update+
* +update_attribute+
* +update_attributes+
* +update_attributes!+
* +valid?+

Callback +after_find+ jest dodatkowo uruchamiany przez następujące metody wyszukiwania: 

* +all+
* +first+
* +find+
* +find_all_by_<em>attribute</em>+
* +find_by_<em>attribute</em>+
* +find_by_<em>attribute</em>!+
* +last+

Calback +after_initialize+ jest uruchmiany zawsze, kiedy zostaje zainicjowana nowa klasa lub obiekt.

h3. Pomijanie callbacków 

Podobnie jak walidację można pominąć callbacki. Tak czy inaczej takie metody powinny być używane ostrożnie, ponieważ logika aplikacji może być przez nie utrzymywana. Omijanie ich bez zrozumienia może potencjalnie skutkować nieprawidłościami w danych. 

* +decrement+
* +decrement_counter+
* +delete+
* +delete_all+
* +find_by_sql+
* +increment+
* +increment_counter+
* +toggle+
* +update_all+
* +update_counters+

h3. Zatrzymywanie wykonania 

Kiedy zaczynasz rejestrację nowych callbacków dla swojego modelu są one ustawiane w kolejce wykonania. Ta kolejka zawiera wszystkie walidacje modelu, zarejestrowane callbacki oraz operacje na bazie danych.

Łańcuch callbacków zachowuje się jak transakcja. Jeśli któryś z callbacków zwróci +false+ lub wyjątek, łańcuch transakcji zostaje zatrzymany i emitowany jest ROLLBACK. Transakcja może byż zakończona dopiero po zgłoszeniu wyjątku.

WARNING. Zgłoszenie przypadkowego wyjątku może załamać kod oczekujący metody +save+ i jej podobnych a nie przerwania w ten sposób. Wyjątek +ActiveRecord::Rollback+ jest przemyślany precyzyjnie w ten sposób, by zakomunikować modułowi Active Record, że wykonany zostaje rollback. Jest on wewnętrznie wyłapywany, ale nie zgłaszany ponownie.

h3. Relacyjne callbacki 

Callbacki działaja za pomocą relacji modelu i mogą być przez nie definiowane. Spójrzmy na następujący przykład: użytkownik ma wiele postów. W naszym przykładzie posty danego użytkownika powinny być usuwane, jeżeli usunięty zostanie użytkownik. Tak więc dodajemy callback +after_destroy+ do modelu Users na drodze jego relacji z modelem +Post+.

<ruby>
class User < ActiveRecord::Base
  has_many :posts, :dependent => :destroy    
end

class Post < ActiveRecord::Base
  after_destroy :log_destroy_action

  def log_destroy_action
    puts 'Post destroyed'
  end
end

>> user = User.first
=> #<User id: 1>
>> user.posts.create!
=> #<Post id: 1, user_id: 1>
>> user.destroy
Post destroyed
=> #<User id: 1>
</ruby>

h3. Callbacki warunkowe 

Tak jak przy walidacjach, możemy skonstruować callbacki warunkowe, tak by były wykonywane tylko kiedy zostanie spełniony dany warunek. Możesz to zrobić używając opcji +:if+ oraz +:unless+, które mogą pobierać symbol, łańcuch znaków lub Proc. Możesz użyć opcji +:if+, kiedy chcesz zaznaczyć, kiedy dany callback *powinien* zostać wykonany. Aby zaznaczyć, że callback *nie powinien* zostać wykonany w danej sytuacji, możesz użyć opcji +:unless+. 

h4. Używanie +:if+ oraz +:unless+ z symbolami 

Możesz używać opcji +:if+ i +:unless+ z symbolem właściwym dla nazwy metody wywoływanej zaraz przed callbackiem. Jeżeli metoda ta zwróci +false+, callback nie zostanie wykonany. Sposób ten jest najbardziej rozpowszechniony. Używanie tej formy rejestracji callbacków umożliwia również zarejestrownie kilku innych metod, które powinny zostać poddane sprawdzeniu, czy callback może zostać wykonany.

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number, :if => :paid_with_card?
end
</ruby>

h4. Używanie +if+ oraz +unless+ z łańcuchami znaków 

Możesz użyć rownież łańcucha znaków, który będzie przeliczany za pomocą +eval+ i będzie zawierał poprawny kod Ruby. Powinieneś używać tej opcji tylko wtedy, gdy łańcuch znaków reprezentuje naprawdę krótki warunek.

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number, :if => "paid_with_card?"
end
</ruby>

h4. Używanie +:if+ oraz +:unless+ z Proc

Możliwe jest także skojarzenie +:if+ oraz +:unless+ z obiektem +Proc+. Ta opcja najlepiej się dopasowuje przy pisaniu kraótkich metod walidacji, zazwyczaj jedno liniowych.

<ruby>
class Order < ActiveRecord::Base
  before_save :normalize_card_number,
    :if => Proc.new { |order| order.paid_with_card? }
end
</ruby>

h4. Warunki wielokrotne dla callbacków 

Podczas pisania warunkowych callbacków jest możliwe łączenie obu opcji - +:if+ oraz +:unless+ w tej samej deklaracji callbacka.

<ruby>
class Comment < ActiveRecord::Base
  after_create :send_email_to_author, :if => :author_wants_emails?,
    :unless => Proc.new { |comment| comment.post.ignore_comments? }
end
</ruby>

h3. Klasy callbacków

Czasami metody callbackowe, które napisałeś, są na tyle użyteczne, że mogą zostać wykorzystane w innych modelach. Moduł Active Records umożliwia tworzenie klas, które enkapsulują metody callbackowe, więc ponowne ich użycie jest bardzo proste.

Oto przykład, w którym tworzymy klasę zawierającą callback +after_destroy+ dla modelu +PictureFile+:

<ruby>
class PictureFileCallbacks
  def after_destroy(picture_file)
    File.delete(picture_file.filepath) 
      if File.exists?(picture_file.filepath)
  end
end
</ruby>

Jeśli jest to zdeklarowane wewnątrz klasy, metoda callbackowa będzie otrzymywała obiekt modelu jako parametr. Możemy jej teraz użyć w następujący sposób:

<ruby>
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks.new
end
</ruby>

Zauważ, że musimy stworzyć egzemplarz obiektu +PictureFileCallbacks+ odkąd zadeklarowaliśmy nasze callbacki jako metody instancyjne. Czasami wydaje się być bardziej sensownym zadeklarować je jako metody klasowe.

<ruby>
class PictureFileCallbacks
  def self.after_destroy(picture_file)
    File.delete(picture_file.filepath) 
      if File.exists?(picture_file.filepath)
  end
end
</ruby>

Jeżeli klasy callbackowe zostaną zadeklarowane w ten sposób, nie będzie koniczne tworzenie egzemplarza obiektu +PictureFileCallbacks+.

<ruby>
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks
end
</ruby>

Możesz stworzyć tyle callbacków ile chcesz w ramach swoich klas callbackowych.

h3. Obserwatorzy

Obserwatorzy są podobni do callbacków, ale są pewne ważne różnice. Gdziekolwiek callbacki mogą zaśmiecać kodem, który nie jest bezpośrednio związany z celem modelu, obserwatorzy umożliwiają dodanie takiej funkcjonalności poza modelem. Na przykład, uzasadnionym wydaje się, aby model +User+ nie zawierał kodu wysyłającego e-maile potwierdzające rejestrację. Kiedykolwiek używasz callbacków o kodzie nie związanym bezpośrednio z modelem, możesz rozważyć stworzenie zamiast tego obserwatora. 

h4. Tworzenie obserwatorów 

Wyobraź sobie model +User+, za pomocą którego chcemy, aby wysyłane były e-maile potwierdzające rejestrację nowego użytkownika. Ponieważ wysyłanie maili nie jest bezpośrednio powiązane z celem obiektu, możemy stworzyć obserwatora zawierającego tą funkcjonalność.

<ruby>
class UserObserver < ActiveRecord::Observer
  def after_create(model)
    # code to send confirmation email...
  end
end
</ruby>

Tak jak w klasach callbackowych, metody obserwatorów otrzymują obserwowaną metodę jako parametr. 

h4. Rejestrowanie obserwatorów 

Obserwatorzy są zazwyczaj umiejscowieni w lokalizacji +app/models+ a zarejestrowani w pliku +config/environment.rb+. Na przykład +UserObserver+, którym zajmowaliśmy się powyżej, zostanie zachowany jako +app/models/user_observer.rb+ a zarejestrowany w +config/environment.rb+ w następujący sposób:

<ruby>
# Activate observers that should always be running
config.active_record.observers = :user_observer
</ruby>

Jak zwykle, ustawienia w +config/environments+ mają pierwszeństwo nad tymi w +config/environment.rb+. Więc jeśli wolisz, aby obserwator nie działał na wszytskich środowiskach, możesz go zdefiniować w specjalnie dla niego poświęconym środowisku. 

h4. Udostępnianie obserwatorów 

Domyślnie Railsy pozbawiają członu "Observer" nazwę obserwatora aby odszukać model, który ma on obserwować. Tak czy inaczej, obserwatorzy mogą być wykorzystywani do obserowawania więcej niż jednego modelu i możliwe jest ręczne uściślenie, których modeli mają dotyczyć.

<ruby>
class MailerObserver < ActiveRecord::Observer
  observe :registration, :user
  
  def after_create(model)
    # code to send confirmation email...
  end
end
</ruby>

W tym przykładzie metoda +after_create+ będzie wywoływana zawsze, kiedy stworzony zostanie +Registration+ lub +User+. Zauważ, że +MailerObserver+ musi być zarejestrowany w +config/environment.rb+, aby mógł działać.

<ruby>
# Activate observers that should always be running
config.active_record.observers = :mailer_observer
</ruby>

h3. Changelog

"Lighthouse ticket":http://rails.lighthouseapp.com/projects/16213/tickets/26-active-record-validations-and-callbacks

* March 7, 2009: Callbacks revision by Trevor Turk
* February 10, 2009: Observers revision by Trevor Turk
* February 5, 2009: Initial revision by Trevor Turk
* January 9, 2009: Initial version by "Cássio Marques":credits.html#cmarques

