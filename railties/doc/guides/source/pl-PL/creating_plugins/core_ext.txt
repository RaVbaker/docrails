== Rozszerzanie klas wbudowanych ==

Z tego rozdziału dowiemy się jak do klasy String dodać metodę, która będzie dostępna w całej naszej aplikacji.

W tym przykładzie dodamy do klasy String metodę `to_squawk`, dzięki której nasz dzięcioł będzie potrafił skrzeczeć. Na początek utwórzmy nowy plik z testem:

*vendor/plugins/yaffle/test/core_ext_test.rb*

[source, ruby]
--------------------------------------------------------
require File.dirname(__FILE__) + '/test_helper.rb'

class CoreExtTest < Test::Unit::TestCase
  def test_to_squawk_prepends_the_word_squawk
    assert_equal "squawk! Hello World", "Hello World".to_squawk
  end
end
--------------------------------------------------------

Przechodzimy do katalogu z naszym pluginem i uruchamiamy `rake test`:

--------------------------------------------------------
cd vendor/plugins/yaffle
rake test
--------------------------------------------------------

Powyższy test powinien zakończyć się niepowodzeniem:

--------------------------------------------------------
 1) Error:
test_to_squawk_prepends_the_word_squawk(CoreExtTest):
NoMethodError: undefined method `to_squawk' for "Hello World":String
    ./test/core_ext_test.rb:5:in `test_to_squawk_prepends_the_word_squawk'
--------------------------------------------------------

Bez paniki - o to nam chodziło. Zaczynamy właściwą pracę.

W 'lib/yaffle.rb' musimy dołączyć 'lib/core_ext.rb':

*vendor/plugins/yaffle/lib/yaffle.rb*

[source, ruby]
--------------------------------------------------------
require "yaffle/core_ext"
--------------------------------------------------------

Na koniec tworzymy plik 'core_ext.rb' i dodajemy metodę 'to_squawk':

*vendor/plugins/yaffle/lib/yaffle/core_ext.rb*

[source, ruby]
--------------------------------------------------------
String.class_eval do
  def to_squawk
    "squawk! #{self}".strip
  end
end
--------------------------------------------------------

Czas sprawdzić czy nasza metoda robi to, co chcemy aby robiła. Uruchamiamy przez `rake` testy jednostkowe z katalogu naszego pluginu. Aby zobaczyć nasz plugin w akcji, odpalamy konsolę i możemy zacząć skrzeczeć:

--------------------------------------------------------
$ ./script/console
>> "Hello World".to_squawk
=> "squawk! Hello World"
--------------------------------------------------------

=== Praca z init.rb ===

Kiedy railsy ładują pluginy, szukają pliku o nazwie 'init.rb' lub 'rails/init.rb'. Inaczej jest w przypadku inicjalizacji pluginu - wtedy 'init.rb' jest wywoływany przez metodę `eval` (a nie `require`), co skutkuje troszkę innym zachowaniem.

W pewnych sytuacjach, jeśli ponownie otworzymy klasy lub moduły w 'init.rb', możemy omyłkowo utworzyć nową klasę zamiast ponownie otworzyć istniejącą. Lepszym sposobem jest ponowne otworzenie klasy w innym pliku i załączenie go w `init.rb`, tak jak w powyższym przykładzie.

Jeśli już koniecznie musimy ponownie otworzyć klasę w `init.rb` możemy użyć metody `module_eval` lub `class_eval`, co pozwoli uniknąć problemów:

*vendor/plugins/yaffle/rails/init.rb*

[source, ruby]
---------------------------------------------------
Hash.class_eval do
  def is_a_special_hash?
    true
  end
end
---------------------------------------------------

Innym sposobem jest dokładne zdefiniowanie przestrzeniu modułu najwyższego poziomu (top-level module space) dla wszystkich modułów i klas, np. `::Hash`:

*vendor/plugins/yaffle/rails/init.rb*

[source, ruby]
---------------------------------------------------
class ::Hash
  def is_a_special_hash?
    true
  end
end
---------------------------------------------------