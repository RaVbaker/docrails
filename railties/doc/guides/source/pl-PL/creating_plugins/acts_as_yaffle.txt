== Dodawanie metody 'acts_as' do modułu Active Record ==

Przy tworzeniu pluginów często będziemy dodawać do modeli metodę 'acts_as_something'. W naszym przykładzie napiszemy metodę 'acts_as_yaffle', która sprawi, że nasze modele będą zachowywać się tak jak nasz ulubiony dzięcioł - czyli będą potrafiły skrzeczeć dzięki metodzie 'squawk'.

Na początek troszkę konfiguracji:

*vendor/plugins/yaffle/test/acts_as_yaffle_test.rb*

[source, ruby]
------------------------------------------------------
require File.dirname(__FILE__) + '/test_helper.rb'

class ActsAsYaffleTest < Test::Unit::TestCase
end
------------------------------------------------------

*vendor/plugins/yaffle/lib/yaffle.rb*

[source, ruby]
------------------------------------------------------
require 'yaffle/acts_as_yaffle'
------------------------------------------------------

*vendor/plugins/yaffle/lib/yaffle/acts_as_yaffle.rb*

[source, ruby]
------------------------------------------------------
module Yaffle
  # tutaj będzie nasz kod
end
------------------------------------------------------

Zauważmy, że po dołączeniu 'acts_as_yaffle' musimy go włączyć również do ActiveRecord::Base, aby metody naszego pluginu były dostępne w modelach Railsów.

Najpopularniejszym schematem pluginów typu 'acts_as_yaffle' jest użycie następującej struktury pliku:

*vendor/plugins/yaffle/lib/yaffle/acts_as_yaffle.rb*

[source, ruby]
------------------------------------------------------
module Yaffle
  def self.included(base)
    base.send :extend, ClassMethods
  end

  module ClassMethods
    # każda zdefiniowana tutaj metoda będzie się odnosiła do klas, np. Hickwall
    def acts_as_something
      send :include, InstanceMethods
    end
  end

  module InstanceMethods
    # każda zdefiniowana tutaj metoda będzie się odnosiła do instancji, np. @hickwall
  end
end
------------------------------------------------------

Przy takiej strukturze możemy łatwo oddzielić metody klasowe (np. `Hickwall.jakas_metoda`) od instancyjnych (np. `@hickwall.jakas_metoda`).

=== Dodawanie metody klasowej ===

Nasz plugin oczekuje, że stworzyliśmy w naszym modelu metodę 'last_squawk'. Może się jednak zdarzyć, że przyszły użytkownik pluginu też jest wielbicielem ptactwa leśnego i zdefiniował sobie własną metodę 'last_squawk', która robi coś innego. Dlatego nasz plugin będzie pozwalał na zmianę jej nazwy przy użyciu metody klasowej, którą nazwiemy 'yaffle_text_field'.

Na początek napiszemy test, który będzie symulował taką (niepożądaną) sytuację:

*vendor/plugins/yaffle/test/acts_as_yaffle_test.rb*

[source, ruby]
------------------------------------------------------
require File.dirname(__FILE__) + '/test_helper.rb'

class Hickwall < ActiveRecord::Base
  acts_as_yaffle
end

class Wickwall < ActiveRecord::Base
  acts_as_yaffle :yaffle_text_field => :last_tweet
end

class ActsAsYaffleTest < Test::Unit::TestCase
  load_schema

  def test_a_hickwalls_yaffle_text_field_should_be_last_squawk
    assert_equal "last_squawk", Hickwall.yaffle_text_field
  end

  def test_a_wickwalls_yaffle_text_field_should_be_last_tweet
    assert_equal "last_tweet", Wickwall.yaffle_text_field
  end
end
------------------------------------------------------

Aby test wypadł poprawnie musimy zmodyfikować nasz plik `acts_as_yaffle.rb` w taki sposób:

*vendor/plugins/yaffle/lib/yaffle/acts_as_yaffle.rb*

[source, ruby]
------------------------------------------------------
module Yaffle
  def self.included(base)
    base.send :extend, ClassMethods
  end

  module ClassMethods
    def acts_as_yaffle(options = {})
      cattr_accessor :yaffle_text_field
      self.yaffle_text_field = (options[:yaffle_text_field] || :last_squawk).to_s
    end
  end
end

ActiveRecord::Base.send :include, Yaffle
------------------------------------------------------

=== Dodawanie metody instancyjnej ===

Nasz plugin będzie dodawał metodę 'squawk' do wszystkich obiektów modułu Active Record, które będą wywoływać 'acts_as_yaffle'. Metoda 'squawk' będzie po prostu ustawiać wartość jakiegoś pola w bazie danych.

Na początek znowu stworzymy test, które będzie symulował błędy:

*vendor/plugins/yaffle/test/acts_as_yaffle_test.rb*

[source, ruby]
------------------------------------------------------
require File.dirname(__FILE__) + '/test_helper.rb'

class Hickwall < ActiveRecord::Base
  acts_as_yaffle
end

class Wickwall < ActiveRecord::Base
  acts_as_yaffle :yaffle_text_field => :last_tweet
end

class ActsAsYaffleTest < Test::Unit::TestCase
  load_schema

  def test_a_hickwalls_yaffle_text_field_should_be_last_squawk
    assert_equal "last_squawk", Hickwall.yaffle_text_field
  end

  def test_a_wickwalls_yaffle_text_field_should_be_last_tweet
    assert_equal "last_tweet", Wickwall.yaffle_text_field
  end
  
  def test_hickwalls_squawk_should_populate_last_squawk
    hickwall = Hickwall.new
    hickwall.squawk("Hello World")
    assert_equal "squawk! Hello World", hickwall.last_squawk
  end  
  
  def test_wickwalls_squawk_should_populate_last_tweeted_at
    wickwall = Wickwall.new
    wickwall.squawk("Hello World")
    assert_equal "squawk! Hello World", wickwall.last_tweet
  end  
end
------------------------------------------------------

Po uruchomieniu dwa ostatnie testy powinny skończyć się błędnie. Aby to naprawić, zmodyfikujmy `acts_as_yaffle.rb`:

*vendor/plugins/yaffle/lib/yaffle/acts_as_yaffle.rb*

[source, ruby]
------------------------------------------------------
module Yaffle
  def self.included(base)
    base.send :extend, ClassMethods
  end

  module ClassMethods
    def acts_as_yaffle(options = {})
      cattr_accessor :yaffle_text_field
      self.yaffle_text_field = (options[:yaffle_text_field] || :last_squawk).to_s
      send :include, InstanceMethods
    end
  end

  module InstanceMethods
    def squawk(string)
      write_attribute(self.class.yaffle_text_field, string.to_squawk)
    end
  end
end

ActiveRecord::Base.send :include, Yaffle
------------------------------------------------------

.Od autora:
NOTE: Użycie metody `write_attribute` w celu zapisania wartości do pola w modelu jest tylko jednym ze sposobów, w jakie plugin może współpracować z modelem i nie zawsze będzie właściwym rozwiązaniem. Równie dobrze można użyć np. `send("#{self.class.yaffle_text_field}=", string.to_squawk)`.