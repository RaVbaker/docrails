== Migracje ==

Jeśli nasz plugin wymaga zmian w bazie danych aplikacji to prawdopodobnie będziemy chcieli użyć migracji. Railsy nie mają wbudowanego wsparcia dla wywoływania migracji z pluginów, ale możemy ułatwić sobie i innym użytkownikom plugina ten proces.

Jeśli nasze wymagania są bardzo proste, np. tworzenie tabeli, która zawsze będzie miała taką samą nazwę i kolumny, możemy użyć jeszcze prostszego rozwiązania - stworzyć własne zadanie modułu `rake` lub metodę. Jeśli potrzebujemy czegoś więcej (np. użytkownik ma podać nazwę tabeli lub inne opcje) to lepszym rozwiązaniem będzie użycie migracji.

Powiedzmy, że w naszym pluginie mamy taką migrację:

*vendor/plugins/yaffle/lib/db/migrate/20081116181115_create_birdhouses.rb:*

[source, ruby]
----------------------------------------------
class CreateBirdhouses < ActiveRecord::Migration
  def self.up
    create_table :birdhouses, :force => true do |t|
      t.string :name
      t.timestamps
    end
  end

  def self.down
    drop_table :birdhouses
  end
end
----------------------------------------------

Oto kilka sposobów na to, jak umożliwić deweloperom korzystanie z migracji naszego pluginu:

=== Tworzenie własnego zadania modułu rake ===

*vendor/plugins/yaffle/tasks/yaffle_tasks.rake:*

[source, ruby]
----------------------------------------------
namespace :db do
  namespace :migrate do
    desc "Migrate the database through scripts in vendor/plugins/yaffle/lib/db/migrate and update db/schema.rb by invoking db:schema:dump. Target specific version with VERSION=x. Turn off output with VERBOSE=false."
    task :yaffle => :environment do
      ActiveRecord::Migration.verbose = ENV["VERBOSE"] ? ENV["VERBOSE"] == "true" : true
      ActiveRecord::Migrator.migrate("vendor/plugins/yaffle/lib/db/migrate/", ENV["VERSION"] ? ENV["VERSION"].to_i : nil)
      Rake::Task["db:schema:dump"].invoke if ActiveRecord::Base.schema_format == :ruby
    end
  end
end
----------------------------------------------

=== Bezpośrednie wywołanie migracji ===

*vendor/plugins/yaffle/lib/yaffle.rb:*

[source, ruby]
----------------------------------------------
Dir.glob(File.join(File.dirname(__FILE__), "db", "migrate", "*")).each do |file|
  require file
end
----------------------------------------------

*db/migrate/20081116181115_create_birdhouses.rb:*

[source, ruby]
----------------------------------------------
class CreateBirdhouses < ActiveRecord::Migration
  def self.up
    Yaffle::CreateBirdhouses.up
  end

  def self.down
    Yaffle::CreateBirdhouses.down
  end
end
----------------------------------------------

.Od autora:
NOTE: Niektóre frameworki, takie jak Desert czy Engines, umożliwiają użycie bardziej zaawansowanych funkcjonalności pluginów.

=== Generowanie migracji ===

Generowanie migracji ma pewną przewagę nad innymi metodami, a mianowicie pozwala innym programistom na łatwiejszą customizację migracji. Proces wygląda następująco:

 * Wywołanie skryptu script/generate i podanie potrzebnych opcji
 * Analiza wygenerowanych migracji, dodawanie/usuwanie kolumn i inne potrzebne opcje

Ten przykład pokaże nam jak użyć jednej z wbudowanych metod generatora, 'migration_template', w celu stworzenia pliku migracji. Rozszerzenie railsowego generatora migracji wymaga pewnej wiedzy na temat jego wewnętrznej organizacji, więc najlepiej będzie na początku stworzyć test:

*vendor/plugins/yaffle/test/yaffle_migration_generator_test.rb*

[source, ruby]
------------------------------------------------------------------
require File.dirname(__FILE__) + '/test_helper.rb'
require 'rails_generator'
require 'rails_generator/scripts/generate'

class MigrationGeneratorTest < Test::Unit::TestCase

  def setup
    FileUtils.mkdir_p(fake_rails_root)
    @original_files = file_list
  end

  def teardown
    ActiveRecord::Base.pluralize_table_names = true
    FileUtils.rm_r(fake_rails_root)
  end
  
  def test_generates_correct_file_name
    Rails::Generator::Scripts::Generate.new.run(["yaffle_migration", "some_name_nobody_is_likely_to_ever_use_in_a_real_migration"], :destination => fake_rails_root)
    new_file = (file_list - @original_files).first
    assert_match /add_yaffle_fields_to_some_name_nobody_is_likely_to_ever_use_in_a_real_migrations/, new_file
    assert_match /add_column :some_name_nobody_is_likely_to_ever_use_in_a_real_migrations do |t|/, File.read(new_file)
  end

  def test_pluralizes_properly
    ActiveRecord::Base.pluralize_table_names = false
    Rails::Generator::Scripts::Generate.new.run(["yaffle_migration", "some_name_nobody_is_likely_to_ever_use_in_a_real_migration"], :destination => fake_rails_root)
    new_file = (file_list - @original_files).first
    assert_match /add_yaffle_fields_to_some_name_nobody_is_likely_to_ever_use_in_a_real_migration/, new_file
    assert_match /add_column :some_name_nobody_is_likely_to_ever_use_in_a_real_migration do |t|/, File.read(new_file)
  end

  private
    def fake_rails_root
      File.join(File.dirname(__FILE__), 'rails_root')
    end
  
    def file_list
      Dir.glob(File.join(fake_rails_root, "db", "migrate", "*"))
    end
      
end
------------------------------------------------------------------

.Od autora:
NOTE: Generator migracji najpierw sprawdza, czy migracja już istnieje w katalogu 'db/migrate'. W związku z tym, jeśli nasz test będzie generował migrację, która już istnieje, zostanie zwrócony błąd. Najprostszym rozwiązaniem jest nadanie generowanej migracji jakiejś nieprawdopodobnej nazwy, która na pewno nie pojawi się w aplikacji.

Jak zwykle, po próbie uruchomienia 'rake' zaprotestuje błędem. Aby błędu nie było, poprawiamy nasz generator:

*vendor/plugins/yaffle/generators/yaffle_migration/yaffle_migration_generator.rb*

[source, ruby]
------------------------------------------------------------------
class YaffleMigrationGenerator < Rails::Generator::NamedBase
  def manifest
    record do |m|
      m.migration_template 'migration:migration.rb', "db/migrate", {:assigns => yaffle_local_assigns,
        :migration_file_name => "add_yaffle_fields_to_#{custom_file_name}"
      }
    end
  end

  private
    def custom_file_name
      custom_name = class_name.underscore.downcase
      custom_name = custom_name.pluralize if ActiveRecord::Base.pluralize_table_names
      custom_name
    end

    def yaffle_local_assigns
      returning(assigns = {}) do
        assigns[:migration_action] = "add"
        assigns[:class_name] = "add_yaffle_fields_to_#{custom_file_name}"
        assigns[:table_name] = custom_file_name
        assigns[:attributes] = [Rails::Generator::GeneratedAttribute.new("last_squawk", "string")]
      end
    end
end
------------------------------------------------------------------

Generator tworzy nowy plik w 'db/migrate' razem ze stemplem czasowym i deklaracją 'add_column'. Używa wbudowanej w Railsy metody `migration_template` oraz wbudowanego schematu migracji.

Bardzo miłym zwyczajem przy tworzeniu generatora jest sprawdzanie czy nazwy tabeli są pluralizowane (są w liczbie mnogiej). Dzięki temu użytkownicy naszego generatora nie będą musieli ręcznie zmieniać wygenerowanych plików jeśli nie używają pluralizacji.

Aby uruchomić generator, wywołaj następujące polecenie:

------------------------------------------------------------------
./script/generate yaffle_migration bird
------------------------------------------------------------------

W efekcie zostanie utworzony nowy plik:

*db/migrate/20080529225649_add_yaffle_fields_to_birds.rb*

[source, ruby]
------------------------------------------------------------------
class AddYaffleFieldsToBirds < ActiveRecord::Migration
  def self.up
    add_column :birds, :last_squawk, :string
  end

  def self.down
    remove_column :birds, :last_squawk
  end
end
------------------------------------------------------------------