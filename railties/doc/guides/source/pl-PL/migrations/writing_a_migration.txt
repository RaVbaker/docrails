== Pisanie migracji ==


Jeśli już utworzyłeś migrację przy pomocy jednego z generatorów, najwyższy czas zabrać się do pracy!

=== Tworzenie tabeli ===

`create_table` jest jedną z najbardziej podstawowych komend. Jej typowe użycie ilustruje przykład:

[source, ruby]
---------------------
create_table :products do |t|
  t.string :name
end
---------------------

Przykład ten generuje tabelę `products` z kolumną o nazwie `name` (i, jak to omówimy w dalszej części, domyślną kolumną `id`).

Obiekt dołączony do bloku pozwala na tworzenie kolumn tabeli. Są na to dwa sposoby. Pierwszy z nich wygląda tak:

[source, ruby]
---------------------
create_table :products do |t|
  t.column :name, :string, :null => false
end
---------------------

Drugi sposób, tzw. "sexy" migracje, nie korzysta z nadmiarowej metody `column`. Zamiast niej wykorzystać można metody `string`, `integer` itp., tworzą kolumny odpowiednich typów. Pozostałe parametry są identyczne do parametrów metody `column`.

[source, ruby]
---------------------
create_table :products do |t|
  t.string :name, :null => false
end
---------------------

Domyślnie `create_table` stworzy klucz główny nazwany `id`. Możesz zmienić jego nazwę korzystając z opcji `:primiary_key` (nie zapomnij poprawić powiązanego z tabelą modelu) lub, jeśli nie chcesz w ogóle klucza głównego (np. dla tabeli HABTM, realizującej relację typu wiele-do-wielu) możesz dodać `id => false`. Jeśli chcesz dodać opcję specyficzną dla konkretnego typu bazy danych, możesz umieścić fragment kody SQL wewnątrz parametru `:options`. Na przykład:

[source, ruby]
---------------------
create_table :products, :options => "ENGINE=BLACKHOLE" do |t|
  t.string :name, :null => false
end
---------------------
Opcja ta doda `ENGINE=BLACKHOLE` do kodu SQL użytego do tworzenia tabeli (dla MySQL domyślny parametr to "ENGINE=InnoDB").

Typy obsługiwane przez moduł Active Record to `:primary_key`, `:string`, `:text`, `:integer`, `:float`, `:decimal`, `:datetime`, `:timestamp`, `:time`, `:date`, `:binary`, `:boolean`.

Zostaną one zrealizowane poprzez odpowiednie dla bazy danych typy danych, np. w MySQL `:string` zostanie przetłumaczony na `VARCHAR(255)`. Możesz tworzyć kolumny innych niż wymienione typów pod warunkiem, że nie używasz "sexy" składni, przykładowo:

[source, ruby]
---------------------
create_table :products do |t|
  t.column :name, 'polygon', :null => false
end
---------------------

Może to jednak uniemożliwić poprawne przeniesienie migracji na inny typ bazy danych.

=== Zmienianie tabel ===

Bliskim kuzynem `create_table` jest `change_table`. Komenda ta służy do zmiany istniejących już tabel i używana jest w analogiczny sposób jak `create_table`, posiada jednak o wiele większe możliwości. Przykładowo:

[source, ruby]
---------------------
change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end
---------------------

Ta komenda usuwa kolumnę `description`, dodaje kolumnę `part_number` i tworzy na niej indeks. Ostatnia metoda powoduje zmianę nazwy kolumny `upccode` na `upc_code`. Ten sam efekt można osiągnąć również następującym sposobem:

[source, ruby]
---------------------
remove_column :products, :description
remove_column :products, :name
add_column :products, :part_number, :string
add_index :products, :part_number
rename_column :products, :upccode, :upc_code
---------------------

Stosując pierwszą składnię nie musisz powtarzać przy każdej komendzie nazwy tabeli - grupujesz wszystkie wykonane na niej operacje w jedną komendę. Dodatkowo nazwy transformacji są krótsze: `remove_column` zastępuje samo `remove` a `add_index` - po prostu `index`.

=== Special helpers ===

Active Record provides some shortcuts for common functionality. It is for example very common to add both the `created_at` and `updated_at` columns and so there is a method that does exactly that:

[source, ruby]
---------------------
create_table :products do |t|
  t.timestamps
end
---------------------
will create a new products table with those two columns whereas

[source, ruby]
---------------------
change_table :products do |t|
  t.timestamps
end
---------------------
adds those columns to an existing table.

The other helper is called `references` (also available as `belongs_to`). In its simplest form it just adds some readability

[source, ruby]
---------------------
create_table :products do |t|
  t.references :category
end
---------------------

will create a `category_id` column of the appropriate type. Note that you pass the model name, not the column name. Active Record adds the `_id` for you. If you have polymorphic belongs_to associations then `references` will add both of the columns required:

[source, ruby]
---------------------
create_table :products do |t|
  t.references :attachment, :polymorphic => {:default => 'Photo'}
end
---------------------
will add an `attachment_id` column and a string `attachment_type` column with a default value of 'Photo'.

NOTE: The `references` helper does not actually create foreign key constraints for you. You will need to use `execute` for that or a plugin that adds <<foreign_key,foreign key support>>.

If the helpers provided by Active Record aren't enough you can use the `execute` function to execute arbitrary SQL.

For more details and examples of individual methods check the API documentation, in particular the documentation for http://api.rubyonrails.com/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html[ActiveRecord::ConnectionAdapters::SchemaStatements] (which provides the methods available in the `up` and `down` methods),  http://api.rubyonrails.com/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html[ActiveRecord::ConnectionAdapters::TableDefinition] (which provides the methods available on the object yielded by `create_table`) and http://api.rubyonrails.com/classes/ActiveRecord/ConnectionAdapters/Table.html[ActiveRecord::ConnectionAdapters::Table] (which provides the methods available on the object yielded by `change_table`).

=== Writing your down method ===

The `down` method of your migration should revert the transformations done by the `up` method. In other words the database should be unchanged if you do an `up` followed by a `down`. For example if you create a table in the up you should drop it in the `down` method. It is wise to do things in precisely the reverse order to in the `up` method. For example

[source, ruby]
---------------------
class ExampleMigration < ActiveRecord::Migration

  def self.up
    create_table :products do |t|
      t.references :category
    end
    #add a foreign key
    execute "ALTER TABLE products ADD CONSTRAINT fk_products_categories FOREIGN KEY (category_id) REFERENCES categories(id)"
    
    add_column :users, :home_page_url, :string
    
    rename_column :users, :email, :email_address
  end
  
  def self.down
    rename_column :users, :email_address, :email
    remove_column :users, :home_page_url
    execute "ALTER TABLE products DROP FOREIGN KEY fk_products_categories"
    drop_table :products
  end
end
---------------------
Sometimes your migration will do something which is just plain irreversible, for example it might destroy some data. In cases like those when you can't reverse the migration you can raise IrreversibleMigration from your `down` method. If someone tries to revert your migration an error message will be
displayed saying that it can't be done.

