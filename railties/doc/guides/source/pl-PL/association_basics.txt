Przewodnik po asocjacjach modułu Active Record
==============================================

Niniejszy przewodnik obejmuje opis asocjacji (_associations_) – elementów modułu Active Record. Za pomocą tego przewodnika będziesz w stanie:

* Zadeklarować asocjacje w modelach wykorzystujących moduł Active Record
* Zrozumieć różne typy asocjacji dostępnych w ramach modułu Active Record
* Stosować metody dodane do twoich modeli dzięki stworzeniu asocjacji

== Dlaczego Asocjacje?

Dlaczego potrzebne są asocjacje(_powiązania_, _połączenia_ - przyp. tłum.) między modelami? Ponieważ sprawiają one, że wspólne operacje (czyli operacje na kilku modelach – przyp.tłum.) stają się mniej skomplikowane i łatwe do implementacji w kodzie.
Na przykład, pomyśl o prostej aplikacji zawierającej dwa modele – klienta (_customer_) oraz zamówień (_order(s)_). Każdy klient może składać wiele zamówień.
Bez zdefiniowania powiązania deklaracja modelu mogłaby wyglądać tak:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
end

class Order < ActiveRecord::Base
end
-------------------------------------------------------

Teraz załóżmy, że chcielibyśmy dodać nowe zamówienie złożone przez istniejącego klienta. Należałoby zrobić coś takiego:

[source, ruby]
-------------------------------------------------------
@order = Order.create(:order_date => Time.now, :customer_id => @customer.id)
-------------------------------------------------------

Przypuśćmy, że chcemy teraz usunąć klienta. W takim przypadku powinniśmy zadbać, by wszystkie zamówienia złożone przez niego zostały również usunięte:

[source, ruby]
-------------------------------------------------------
@orders = Order.find_by_customer_id(@customer.id)
@orders.each do |order|
  order.destroy
end
@customer.destroy
-------------------------------------------------------

Z asocjacjami modułu Active Record można znacznie usprawnić tego typu operacje (i wiele innych). Poprzez deklarację możemy _powiedzieć_ Railsom, że istnieje relacja między dwoma modelami. Oto poprawione zgodnie z tymi założeniami modele - klienta i zamówienia:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end

class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

Dzięki tej zmianie stworzenie nowego zamówienia dla konkretnego klienta jest łatwiejsze:

[source, ruby]
-------------------------------------------------------
@order = @customer.orders.create(:order_date => Time.now)
-------------------------------------------------------

Także usuwanie klienta i jego wszystkich zamówień jest _o_ _wiele_ prostsze.

[source, ruby]
-------------------------------------------------------
@customer.destroy
-------------------------------------------------------

Aby dowiedzieć się więcej o różnych rodzajach asocjacji, przeczytaj następny rozdział tego przewodnika. Zapoznasz się tam z kilkoma wskazówkami i trikami przydatnymi w pracy z asocjacjami, a także z kompletnym spisem metod i opcji dla asocjacji w Railsach.

== Typy asocjacji

W Railsach _asocjacja_ to powiązanie ze sobą modeli wykorzystujących moduł Active Record. Asocjacje są realizowane poprzez makro-połączenia, a więc dzięki dodaniu stosownej funkcji do modelu poprzez jej zadeklarowanie. Na przykład, deklarując, że jeden model _należy do_ (+belongs_to+) innego, instruujesz Railsy by utrzymywały powiązanie klucza podstawowego z obcym kluczem między instancjami tych dwóch modeli, a dzięki temu otrzymujesz także szereg narzędzi (metod), które możesz wykorzystać w swoim modelu. Rails obsługuje sześć typów asocjacji:

* +belongs_to+
* +has_one+
* +has_many+
* +has_many :through+
* +has_one :through+
* +has_and_belongs_to_many+

W dalszej części przewodnika dowiesz się jak deklarować asocjacje i jak używać różnych z nich. Ale najpierw – krótkie wprowadzenie do przypadków właściwych użyć poszczególnych asocjacji. 

=== Asocjacja +belongs_to+

Asocjacja +belongs_to+ ustanawia relację  typu jeden-do-jeden z innym modelem w taki sposób, że każda instancja  zadeklarowanego modelu "należy do" (_belongs_ _to_) jednej instancji innego modelu.
Na przykład: jeśli twoja aplikacja zawiera modele klientów i ich zamówienia, a każde zamówienie przypisane jest dokładnie do jednego klienta, można zadeklarować model zamówienia w ten sposób:
 
[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------
 
image:images/belongs_to.png[diagram asocjacji belongs_to]

=== Asocjacja +has_one+

Asocjacja +has_one+ również ustanawia relację typu jeden-do-jeden pomiędzy dwoma modelami, jednak posiada inną semantykę (i jej konsekwencje). Ta asocjacja wskazuje, iż każda instancja jednego modelu posiada jedną instancję drugiego. 
Na przykład: Każdy dostawca (_supplier_) w twojej aplikacji ma tylko jedno konto – możesz zadeklarować model dostawcy w taki sposób:
 
[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end
-------------------------------------------------------
 
image:images/has_one.png[diagram asocjacji has_one]

=== Asocjacja +has_many+
 
Asocjacja +has_many+ wskazuje relację typu jeden-do-wiele. Będziesz mógł często znaleźć tę asocjację "po drugiej stronie" asocjacji +belongs_to+. Ta relacja wskazuje, że każda instancja modelu posiada zero i więcej instancji innego modelu. 
Na przykład, w aplikacji zawierającej klientów i zamówienia, model klienta mógłby zostać zadeklarowany następująco:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------
 
NOTE: Kiedy deklarujemy asocjację +has_many+, nazwa wiązanego modelu jest zamieniana na jej liczbę mnogą (oczywiście mowa tu o gramatyce języka angielskiego - przyp. tłum.).
 
image:images/has_many.png[diagram asocjacji has_many]

=== Asocjacja has_many :through
 
Asocjacja +has_many :through+ (_posiada_wiele :poprzez_) często używana jest do stworzenia relacji wiele-do-wiele z innym modelem. Asocjacja wskazuje, że zadeklarowany model może być powiązany z zerem i większą ilością instancji innego modelu poprzez trzeci model (dzięki użyciu _through_).
Na przykład, wyobraź sobie praktykę lekarską, gdzie pacjenci (_patient(s)_) rezerwują wizyty (_appointment(s)_) u lekarzy (_physician(s)_). Odpowiednio zadeklarowana asocjacja mogłaby wyglądać tak:

[source, ruby]
-------------------------------------------------------
class Physician < ActiveRecord::Base
  has_many :appointments
  has_many :patients, :through => :appointments
end

class Appointment < ActiveRecord::Base
  belongs_to :physician
  belongs_to :patient
end

class Patient < ActiveRecord::Base
  has_many :appointments
  has_many :physicians, :through => :appointments
end
-------------------------------------------------------

image:images/has_many_through.png[diagram asocjacji has_many :through]
 
Asocjacja +has_many :through+ przydaje się także do tworzenia "skrótów" poprzez zagnieżdżone asocjacje +has_many+. Na przykład, jeśli dokument ma wiele rozdziałów (_sections_), a rozdział wiele paragrafów (_paragraph_), możesz czasem chcieć utworzyć prosty zbiór (in. kolekcję - _collection_) wszystkich paragrafów w dokumencie. Da się to zrobić w ten sposób:

[source, ruby]
-------------------------------------------------------
class Document < ActiveRecord::Base
  has_many :sections
  has_many :paragraphs, :through => :sections
end

class Section < ActiveRecord::Base
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ActiveRecord::Base
  belongs_to :section
end
-------------------------------------------------------

=== Asocjacja +has_one :through+

Asocjacja +has_one :through+ (_posiada jeden :poprzez_) ustanawia relację typu jeden-do-jeden z innym modelem. Asocjacja ta wskazuje, że deklaracja jednego modelu może być dopasowana do instancji innego modelu poprzez model trzeci. 
Na przykład, jeśli każdy dostawca posiada jedno konto (_account_), a każde konto jest powiązane (_associate_) z jedną historią konta (_account history_), wtedy model klienta  mógłby wyglądać następująco:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
  has_one :account_history, :through => :account
end

class Account < ActiveRecord::Base
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ActiveRecord::Base
  belongs_to :account
end
-------------------------------------------------------

image:images/has_one_through.png[diagram asocjacji has_one :through]

=== Asocjacja +has_and_belongs_to_many+

Asocjacja has_and_belongs_to_many tworzy bezpośrednią relację typu wiele-do-wiele z innym modelem bez ingerencji modelu pośredniego (nie ma potrzeby deklarowania go, jednak zauważyć należy, iż jest tworzona automatycznie stosowna tabela wiążąca -przyp.tłum.).
Na przykład, jeżeli projekt miałby zawierać zbiory (zestawy - _assembly(ies)_)  i części (_part(s)_) oraz każdy zbiór posiadałby wiele części, a każda część mogłaby pojawić się w wielu zbiorach,  modele można zadeklarować w ten sposób:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

image:images/habtm.png[diagram asocjacji has_and_belongs_to_many]
 
=== Wybór pomiędzy +belongs_to+ i +has_one+
 
Jeśli chcesz ustawić relację typu jeden-do-jeden między dwoma modelami, powinieneś użyć asocjacji +belongs_to+ do jednego i +has_one+ do drugiego. Ale skąd wiedzieć która powinna być w którym modelu?

Rozróżnić to należy sprawdzając, w której tabeli (w którym modelu) ustawiłeś klucz obcy (foreign key) (dla klasy tej tabeli potrzebujesz asocjacji +belongs_to+), ale powinieneś pomyśleć także nad znaczeniem danych. Relacja +has_one+ mówi, że "jednen ze zbioru” należy do ciebie – tzn. że coś wskazuje z powrotem na ciebie. 
Na przykład: Ma większy sens powiedzenie, że dostawca posiada konto, aniżeli konto posiada dostawcę. To sugeruje nam, że poprawne relacje wyglądają tak:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end

class Account < ActiveRecord::Base
  belongs_to :supplier
end
-------------------------------------------------------

Powiązana relacja może wyglądać tak:

[source, ruby]
-------------------------------------------------------
class CreateSuppliers < ActiveRecord::Migration
  def self.up
    create_table :suppliers do |t|
      t.string  :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.integer :supplier_id
      t.string  :account_number
      t.timestamps
    end
  end

  def self.down
    drop_table :accounts
    drop_table :suppliers
  end
end
-------------------------------------------------------

NOTE: Użycie t.integer :supplier_id powoduje, że nazwa klucza obcego jest podana wprost, ale jednocześnie samo użycie
klucza jest niejawne. W obecnej wersji Rails można ukryć ten szczegół implementacyjny używając składni t.references :supplier
 
=== Wybór pomiędzy +has_many :through+ i +has_and_belongs_to_many+

Rails oferuje dwa sposoby deklaracji relacji tyou wiele-do-wiele między modelami. Łatwiejszym wyjściem jest użycie +has_and_belongs_to_many+, które umożliwia bezpośrednie ustanowienie asocjacji:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

Druga opcja implementacji relacji tyou wiele-do-wiele to użycie +has_many :through+. Ustanawia to asocjację pośrednio, poprzed dołączenie dodatkowego modelu (_join model_): 

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_many :manifests
  has_many :parts, :through => :manifests
end

class Manifest < ActiveRecord::Base
  belongs_to :assembly
  belongs_to :part
end

class Part < ActiveRecord::Base
  has_many :manifests
  has_many :assemblies, :through => :manifests
end
-------------------------------------------------------

Najłatwiejsza zasada polega na tym, że ustawiasz relację +has_many :through+ jeśli chcesz pracować z pośrednim (wiążącym pozostałe dwa) modelem jako niezależnym bytem. Jeśli jednak nie potrzebujesz niczego z nim robić, łatwiejsze będzie wykorzystanie asocjacji +has_and_belongs_to_many+ (choć musisz pamiętać, że należy stworzyć tabelę łączącą)

Należy używać :has_many :through: jeśli potrzebujesz opcji walidacji, callback-ów lub dodatkowych atrybutów dla wiążącego modelu.
 
=== Asocjacje polimorficzne

Nieco bardziej zaawansowanym typem asocjacji jest asocjacja polimorficzna. Dzięki polimorficznym asocjacjom model może być powiązany z więcej niż jednym innym modelem, za pomocją pojedynczej asocjacji. 
Na przykład, chcesz mieć model  "zdjęcia" (_picture_), który należy do (+belongs_to+) modelu pracownika (_employee_) lub produktu (_product_). Oto w jaki sposób mogłoby to zostać zadeklarowane:

[source, ruby]
-------------------------------------------------------
class Picture < ActiveRecord::Base
  belongs_to :imageable, :polymorphic => true
end

class Employee < ActiveRecord::Base
  has_many :pictures, :as => :imageable
end

class Product < ActiveRecord::Base
  has_many :pictures, :as => :imageable
end
-------------------------------------------------------

Mógłbyś pomyśleć, że polimofriczna deklaracja +belongs_to+ ustanawia taki interfejs, że żaden inny model nie może go użyć. Z instancji modelu pracownika (+Employee+) można pobrać zbiór zdjęć: +@employee.pictures+. Podobnie, możesz pobrać zdjęcia produktów - +@product.pictures+. Jeśli masz instancję modelu zdjęcia (+Picture+), możesz "dostać się" do jego rodzica dzięki +@picture.imageable+. By to zadziałało, potrzebujesz zadeklarować w modelu, który ma mieć polimorficzny interfejs (tu: +Picture+) dwie rzeczy: klucz obcy (dla id pracownika lub produktu – przyp. tłum.), jak i "typ” wiązanego modelu:

[source, ruby]
-------------------------------------------------------
class CreatePictures < ActiveRecord::Migration
  def self.up
    create_table :pictures do |t|
      t.string  :name
      t.integer :imageable_id
      t.string  :imageable_type
      t.timestamps
    end
  end

  def self.down
    drop_table :pictures
  end
end
-------------------------------------------------------

Migracja dla takiego modelu może być uproszczona dzięki użyciu t.references: 

[source, ruby]
-------------------------------------------------------
class CreatePictures < ActiveRecord::Migration
  def self.up
    create_table :pictures do |t|
      t.string  :name
      t.references :imageable, :polymorphic => true
      t.timestamps
    end
  end

  def self.down
    drop_table :pictures
  end
end
-------------------------------------------------------

image:images/polymorphic.png[diagram asocjacji polimorficznej]
 
=== Samoodniesienie (wiązanie rekurencyjne)

Przy projektowaniu modeli danych, możesz czasem natknąć się na model, który powinien mieć odniesienie do siebie samego. Na przykład, chcesz przechowywać wszystkich pracowników w jednym modelu bazy danych (w jednej tabeli w bazie), ale też chciałbyś móc prześledzić hierarchie między pracownikami (takie jak manager i jego podwładni). Takie powiązanie może być zadeklarowane za pomocą asocjacji samoodniesienia:

[source, ruby]
-------------------------------------------------------
class Employee < ActiveRecord::Base
  has_many :subordinates, :class_name => "Employee", :foreign_key => "manager_id"
  belongs_to :manager, :class_name => "Employee"
end
-------------------------------------------------------

Dzięki takiemu ustawieniu możesz "wyciągnąć" +@employee.subordinates+ (podwładni pracownika) i +@employee.manager+ (manager pracownika).

== Porady, triki i ostrzeżenia

W tym rozdziale znajdziesz kilka rzeczy, które powinieneś wiedzieć, by skutecznie używać modułu Active Record w twoich aplikacjach Rails. 

* Kontrolowanie cachingu
* Unikanie kolizji w nazwach 
* Aktualizacje schematów 
* Kontrolowanie zakresu asocjacji
 
=== Kontrolowanie cachingu

Wszystkie metody asocjacji są cache-owane tak, że wynik ostatniego zapytania dostępny jest dla następnych operacji. Zawartość _cache_ jest nawet widoczna z innych metod. Na przykład:
 
[source, ruby]
-------------------------------------------------------
customer.orders               # pobiera zamówienia z bazy danych
customer.orders.size          # używa kopii zamówień z cache
customer.orders.empty?        # używa kopii zamówień z cache
-------------------------------------------------------

Ale co zrobić, gdy potrzeba uaktualnić _cache_, bo dane być może zostały zmienione przez jakąś inną część aplikacji? Po prostu ustaw +true+ dla wywołania asocjacji:

[source, ruby]
-------------------------------------------------------
customer.orders               # pobiera zamówienia z bazy danych
customer.orders.size          # używa kopii zamówień z cache
customer.orders(true).empty?  # odrzuca kopię zamówień będącą w cache i "wraca" do bazy danych
-------------------------------------------------------

=== Unikanie kolizji nazw
 
Nazwy twoich asocjacji nie mgą być dowolne. Ponieważ tworzenie asocjacji automatycznie dodaje do modelu metodę z taką samą nazwą, złym pomysłem jest nazywanie asocjacji tak samo jak metody instancji ActiveRecord::Base. Metoda asocjacji w takim przypadku przesłoni metodę bazy, a to nie jest pożądane. Przykładem złych nazw asocjacji są +attributes+ albo +connection+. 
 
=== Aktualizacja schematu
 
Asocjacje są bardzo przydatne, ale nie są magiczne. Jesteś odpowiedzialny za utrzymanie schematu  bazy danych w dopasowaniu do swoich asocjacji. W praktyce oznacza to dwie rzeczy, w zależności od tego, którego rodzaju asocjacji użyłeś w swoim modelu. Dla asocjacji +belongs_to+ porzebujesz stworzyć klucze obce, a dla +has_and_belongs_to_many+ - stosowną wiążącą tabelę (w bazie).
 
==== Tworzenie kluczy obcych dla asocjacji +belongs_to+

Kiedy deklarujesz asocjację +belongs_to+, powinieneś stworzyć odpowiednie klucze obce. Na przykład, rozważ taki model:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

Taka deklaracja  powinna być uwzgleniona i "wsparta" odpowiednią deklaracją klucza obcego w tabeli zamówień:

[source, ruby]
-------------------------------------------------------
class CreateOrders < ActiveRecord::Migration
  def self.up
    create_table :orders do |t|
      t.datetime   :order_date
      t.string     :order_number 
      t.integer    :customer_id 
    end
  end

  def self.down
    drop_table :orders
  end
end
-------------------------------------------------------

Jeśli tworzysz asocjację po jakimś czasie od stworzenia modelu bazowego, musisz pamiętać o stworzeniu migracji +add_column+ (dodaj kolumnę) by zapewnić modelowi odpowiedni klucz obcy.

==== Creating Join Tables for +has_and_belongs_to_many+ Associations

Jeśli tworzysz asocjację +has_and_belongs_to_many+ potrzebujesz stworzyć wiążącą tabelę. Dopóki nazwa dołączanej tabeli nie jest wyraźnie określona poprzez użycie opcji +:join_table+, moduł Active Record utworzy nazwę używając leksykalnego (alfabetycznego) )porządku tworzenia nazw. Zatem: połączenie między modelem  klienta (customer) a zamówieniem (order) otrzyma domyślną nazwę tabeli "customers_orders" (zamówienia klientów), bo "c" jest w alfabecie przed "o".

WARNING: Pierwszeństwo między nazwami modeli jest "obliczane" przy użyciu operatora „<” (mniejszości) dla stringów (łańcuchów znaków). To znaczy, ze jeśli słowa są różnej długości, ale początkowy łańcuch jest jednakowy – wtedy wyżej w tym porządku jest słowo dłuższe. Na przykład, możnaby oczekiwać, że dla tabeli paper_boxes i papers wygenerowana nazwa wiążącej tabeli będzie brzmiała "papers_paper_boxes", ze względu na długość łańcucha "paper_boxes". Jednak w rzeczywistości wygenerowana zostanie nazwa "paper_boxes_papers".
 
Niezależnie od nazwy, musisz "ręcznie" wygenerować wiążącą tabelę za pomocą odpowiedniej migracji. Na przykład, rozważ takie asocjacje:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

Powinny one zostać zaktualizowane za pomocą migracji, która wygeneruje tabelę +assemblies_parts+.Taka tabela powinna być stworzona bez klucza podstawowego:

[source, ruby]
-------------------------------------------------------
class CreateAssemblyPartJoinTable < ActiveRecord::Migration
  def self.up
    create_table :assemblies_parts, :id => false do |t|
      t.integer :assembly_id
      t.integer :part_id
    end
  end

  def self.down
    drop_table :assemblies_parts
  end
end
-------------------------------------------------------

=== Kontrolowanie zakresu asocjacji
 
Domyślnie asocjacje "szukają" obiektów tylko w ramach bieżącego zakresu modułów. To może być ważne, gdy deklarujesz modele wykorzystujące ActiveRecord wewnątrz modułu, na przykład:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    end

    class Account < ActiveRecord::Base
       belongs_to :supplier
    end
  end
end
-------------------------------------------------------

Ten kod będzie działał dobrze, bo zarówno klasa dostawcy, jak i klasa konta są zdefiniowane w ramach tego samego zakresu (zakresu modelu). Ale już poniższy przykład nie będzie działać, bo dostawca i konto są zdefiniowane w różnych zakresach:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    end
  end

  module Billing
    class Account < ActiveRecord::Base
       belongs_to :supplier
    end
  end
end
-------------------------------------------------------

By powiązać dwa modele istniejące w ramach różnych zakresów – musisz podać pełną nazwę klasy w deklaracji asocjacji:  

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account, :class_name => "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ActiveRecord::Base
       belongs_to :supplier, :class_name => "MyApplication::Business::Supplier"
    end
  end
end
-------------------------------------------------------

== Szczegółowy spis asocjacji

Niniejszy rozdział ukaże ci szczegóły każdego typu asocjacji, w tym informacje o metodach, które dzięki nim zyskujesz oraz opcji, których możesz uzywać dzięki zadeklarowaniu asocjacji.

=== Asocjacja belongs_to
 
Asocjacja +belongs_to+ tworzy relację typu jeden-do-jeden z innym modelem. Wwarunkach bazy danych, oznacza to że dana klasa zawiera klucz obcy. Jeśli inna klasa zawiera klucz obcy, powinieneś raczej użyć asocjacji +has_one+

==== Metody dodane dzięki +belongs_to+

Kiedy zadeklarujesz asocjację belongs_to, deklarowana klasa automatycznie zyskuje pięć metod odnoszących się do asocjacji:
 
* +_association_(force_reload = false)+
* +_association_=(associate)+
* +_association_.nil?+
* +build___association__(attributes = {})+
* +create___association__(attributes = {})+
 
We wszystkich tych medodach +_association_+ zastępuje się symbolem przekazanym jako pierwszy argument do belongs_to. Na przykład gdy mamy deklarację:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

Każda instancja wybranego modelu będzie posiadała poniższe metody:

[source, ruby]
-------------------------------------------------------
customer
customer=
customer.nil?
build_customer
create_customer
-------------------------------------------------------

===== +_association_(force_reload = false)+

The +_association_+ method returns the associated object, if any. If no associated object is found, it returns +nil+.
Metoda +_association_+ zwraca wiązany obiekt, jeśli tylko taki istnieje. Jeśli wiązany obiekt nie został znaleziony, metoda zwraca +nil+.

[source, ruby]
-------------------------------------------------------
@customer = @order.customer
-------------------------------------------------------

Jeśli wiązany obiekt został już pobrany z bazy danych, zwrócona będzie jego wersja przechowywana w _cache_. Aby to zmienić  (i wymusić czytanie z bazy), ustaw +true+ przy argumencie +force_reload+
 
===== +_association_=(associate)+

metoda +_association_=+ przydziela wiązanemy obiekt do naszego obiektu. Od środka wygląda to tak, że wydobywa ona z wiązanego obiektu klucz postawowy i ustawia naszemu obiektowi klucz obcy na tę samą wartość.

[source, ruby]
-------------------------------------------------------
@order.customer = @customer
-------------------------------------------------------

===== +_association_.nil?+

metoda +_association_.nil?+ zwraca wartość +true+ jeśli nie znaleziono wiązanego obiektu.

[source, ruby]
-------------------------------------------------------
if @order.customer.nil?
  @msg = "No customer found for this order"
end
-------------------------------------------------------

===== +build___association__(attributes = {})+

Metoda +build__\_association__+ zwraca nowy obiekt wiązanego typu. Ten obiekt zostanie natychmiast utworzony z ustawionych atrybutów,  będzie ustawiony odnośnik do obcego klucza tego obiektu, ale wiązany obiekt _nie zostanie_ zapisany. 

[source, ruby]
-------------------------------------------------------
@customer = @order.build_customer({:customer_number => 123, :customer_name => "John Doe"})
-------------------------------------------------------

===== +create___association__(attributes = {})+

Metoda +create__\_association__+ zwraca nowy obiekt wiązanego typu, Ten obiekt zostanie natychmiast utworzony z ustawionych atrybutów i będzie ustawiony odnośnik do obcego klucza tego obiektu. Ponadto wiązany obiekt zostanie zapisany (zakładając, że przejdzie pomyślnie przez walidację).

[source, ruby]
-------------------------------------------------------
@customer = @order.create_customer({:customer_number => 123, :customer_name => "John Doe"})
-------------------------------------------------------

==== Opcje dla +belongs_to+

W wielu sytuacjach możesz użyć asocjacji +belongs_to+ bez potrzeby jej dostosowywania. Ale pomimo Ralisowego nacisku na górowanie konwencji nad dostosowaniem do własnych potrzeb, możesz zmieniać domyślne ustawienia na kilka sposobów. Ten rozdział przedstawi ci opcje, których możesz używać, kiedy zadeklarujesz asocjację +belongs_to+. Na przykład asocjacja z kilkoma opcjami może wyglądać tak:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => true, :conditions => "active = 1"
end
-------------------------------------------------------

Asocjacja +belongs_to+ wspiera następujące opcje

// * +:accessible+
* +:class_name+
* +:conditions+
* +:counter_cache+
* +:dependent+
* +:foreign_key+
* +:include+
* +:polymorphic+
* +:readonly+
* +:select+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:class_name+

Jeśli nazwa innego modelu nie może zostać utworzona z nazwy asocjacji, możesz użyć opcji +:class-name+, by dostarczyć własną nazwę modelu. Na przykład, jeśli zamówienie należy [_belongs to_] do klienta, ale aktualna nazwa zawierająca klientów to +Patron+, możesz to ustawić w ten sposób:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :class_name => "Patron"
end
-------------------------------------------------------

===== +:conditions+

Opcja +:conditions+ pozwala określić warunki, jakie wiązany obiekt musi spełniać (W składni SQL użyłbyś klauzuli WHERE).

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :conditions => "active = 1"
end
-------------------------------------------------------

===== +:counter_cache+

Opcja +:counter_cache+ może sprawić, że znajdowanie liczby powiązanych obiektów będzie bardziej wydajne (szybsze). Rozważ te modele:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Z powyższymi deklaracjami, znalezienie wartości +@customer.orders.size+ (wielkość [ilość] zamówień klientów) wymaga zapytania do bazy wykorzystującego +COUNT(*)+. Aby uniknąć tego połączenia możesz dodać :counter_cache ("licznik cache") do modelu: 

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => true
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------
 
Dzięki tej deklaracji Railsy będą pobierały bieżącą wartość cache i zwrócą ją w odpowiedzi na metodę +.size+.

Pomimo, że opcja +:counter_cache+ jest określona dla modelu zawierającego deklarację +belongs_to+, bieżąca kolumna musi być dodana do wiązanego modelu. W powyższym przypadku musisz dodać kolumnę o nazwie+orders_count+ do modelu klienta [+Customer+]. Możesz zamienić domyślną nazwę kolumny, jeśli tylko chcesz:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => :count_of_orders
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Kolumny _licznika_ są dodawane do listy atrybutów tylko-do-odczytu wiązanego modelu (poprzez +attr_readonly+)

===== +:dependent+

Jeśli ustawisz opcję +:dependent+ na :destroy, wtedy usunięcie tego obiektu wywoła metodę destroy na wiązanym obiekcie, by usunąć ten obiekt. Jeżeli ustawisz opcję +:dependent+ na +:delete+, wtedy usunięcie tego obiektu spowoduje usunięcie obiektu wiązanego _bez_ wywoływania dla niego metody +destroy+.

WARNING: Nie używaj tej opcji w asocjacji +belongs_to+, która jest połączona z asocjacją +has_many+ w innej klasie. W przeciwnym wypadku w twojej bazie pojawią się rekordy osierocone.

===== +:foreign_key+

Zgodnie z konwencją, Railsy "domyślają się", że kolumna używana do przechowywania klucza obcego to nazwa asocjacji z dodanym przyrostkiem +_id+. Opcja +:foreign_key+ umożliwia ustawienie nazwy klucza obcego bezpośrednio:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :class_name => "Patron", :foreign_key => "patron_id"
end
-------------------------------------------------------

TIP: W żadnym z wypadków Railsy nie będą same tworzyły dla ciebie kolumn klucza obcego. Musisz zdefiniować teklucze w swoich migracjach.

===== +:include+

Możesz użyć opcji +:include+ do podania drugorzędnych asocjacji, które zostaną załadowane wtedy, gdy zostanie użyta dana asocjacja. Na przykład, rozważmy takie modele:

[source, ruby]
-------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Jeśli często pobierasz klienta bezpośrednio z pozycji w jego zamówieniu [_line item_] (+@line_item.order.customer+), możesz sprawić, żetwój kod będzie wydajniejszy, włączając klienta w asocjacji z pozycją w zamówieniu do zamówienia:


[source, ruby]
-------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order, :include => :customer
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

NOTE: There's no need to use +:include+ for immediate associations - that is, if you have +Order belongs_to :customer+, then the customer is eager-loaded automatically when it's needed.
NOTE:Nie ma potrzeby stosowanie +:include+ do bezpośrednich asocjacji, to znaczy: jeśli masz zdefiniowaną w modelu relację zamówień należących do  (_belongs to_) klientów, wtedy "klient" jest przygotowany do wczytania zawsze, kiedy tylko jest potrzebny.

===== +:polymorphic+

Ustawienie +true+ dla opcji +:polymorphic+ wskazuje, że asocjacja jest polimorficzna. Asocjacje polimorficzne zostały omówione wcześniej w tym przewodniku.

===== +:readonly+

jeśli ustawisz +true+ dla opcji +:readonly+, asocjowany obiekt będzie tylko do odczytu, gdy wywoływana jest asocjacja.

===== +:select+

Użyj opcji : select by zastąpić klauzulę SQL +SELECT+, która służy do wyszukiwania danych w wiązanym obiekcie. Domyślnie Rails pobiera wszystkie kolumny. 

TIP: Po ustawieniu opcji +:select+ dla asocjacji +belongs_to+, powinieneś też ustawić opcję +:foreign_key+, by mieć pewność, że uzyskasz poprawny wynik zapytania

===== +:validate+

Kiedy ustawisz na +true+ opcję +:validate+,  wiązane obiekty będą walidowane zawsze, kiedy będziesz je zapisywać. Domyślne ustawienie to +false+: wiązane obiekty nie są walidowane kiedy je zapisujesz.

==== When are Objects Saved?

Assigning an object to a +belongs_to+ association does _not_ automatically save the object. It does not save the associated object either.
Przypisywanie obiektu do asocjacji +belongs_to+ nie zapisuje go automatycznie. Nie zapisuje to także wiązanego obiektu.

=== The has_one Association

The +has_one+ association creates a one-to-one match with another model. In database terms, this association says that the other class contains the foreign key. If this class contains the foreign key, then you should use +belongs_to+ instead.

==== Methods Added by +has_one+

When you declare a +has_one+ association, the declaring class automatically gains five methods related to the association:

* +_association_(force_reload = false)+
* +_association_=(associate)+
* +_association_.nil?+
* +build___association__(attributes = {})+
* +create___association__(attributes = {})+

In all of these methods, +_association_+ is replaced with the symbol passed as the first argument to +has_one+. For example, given the declaration:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end
-------------------------------------------------------

Each instance of the +Supplier+ model will have these methods:

[source, ruby]
-------------------------------------------------------
account
account=
account.nil?
build_account
create_account
-------------------------------------------------------

===== +_association_(force_reload = false)+

The +_association_+ method returns the associated object, if any. If no associated object is found, it returns +nil+.

[source, ruby]
-------------------------------------------------------
@account = @supplier.account
-------------------------------------------------------

If the associated object has already been retrieved from the database for this object, the cached version will be returned. To override this behavior (and force a database read), pass +true+ as the +force_reload+ argument.

===== +_association_=(associate)+

The +_association_=+ method assigns an associated object to this object. Behind the scenes, this means extracting the primary key from this object and setting the associate object's foreign key to the same value.

[source, ruby]
-------------------------------------------------------
@suppler.account = @account
-------------------------------------------------------

===== +_association_.nil?+

The +_association_.nil?+ method returns +true+ if there is no associated object.

[source, ruby]
-------------------------------------------------------
if @supplier.account.nil?
  @msg = "No account found for this supplier"
end
-------------------------------------------------------

===== +build___association__(attributes = {})+

The +build__\_association__+ method returns a new object of the associated type. This object will be instantiated from the passed attributes, and the link through its foreign key will be set, but the associated object will _not_ yet be saved.

[source, ruby]
-------------------------------------------------------
@account = @supplier.build_account({:terms => "Net 30"})
-------------------------------------------------------

===== +create___association__(attributes = {})+

The +create__\_association__+ method returns a new object of the associated type. This object will be instantiated from the passed attributes, and the link through its foreign key will be set. In addition, the associated object _will_ be saved (assuming that it passes any validations).

[source, ruby]
-------------------------------------------------------
@account = @supplier.create_account({:terms => "Net 30"})
-------------------------------------------------------

==== Options for +has_one+

In many situations, you can use the default behavior of +has_one+ without any customization. But despite Rails' emphasis of convention over customization, you can alter that behavior in a number of ways. This section covers the options that you can pass when you create a +has_one+ association. For example, an association with several options might look like this:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :class_name => "Billing", :dependent => :nullify
end
-------------------------------------------------------

The +has_one+ association supports these options:

// * +:accessible+
* +:as+
* +:class_name+
* +:conditions+
* +:dependent+
* +:foreign_key+
* +:include+
* +:order+
* +:primary_key+
* +:readonly+
* +:select+
* +:source+
* +:source_type+
* +:through+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:as+

Setting the +:as+ option indicates that this is a polymorphic association. Polymorphic associations are discussed in detail later in this guide.

===== +:class_name+

If the name of the other model cannot be derived from the association name, you can use the +:class_name+ option to supply the model name. For example, if a supplier has an account, but the actual name of the model containing accounts is Billing, you'd set things up this way:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :class_name => "Billing"
end
-------------------------------------------------------

===== +:conditions+

The +:conditions+ option lets you specify the conditions that the associated object must meet (in the syntax used by a SQL +WHERE+ clause).

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :conditions => "confirmed = 1"
end
-------------------------------------------------------

===== +:dependent+

If you set the +:dependent+ option to +:destroy+, then deleting this object will call the destroy method on the associated object to delete that object. If you set the +:dependent+ option to +:delete+, then deleting this object will delete the associated object _without_ calling its +destroy+ method. If you set the +:dependent+ option to +:nullify+, then deleting this object will set the foreign key in the association object to +NULL+.

===== +:foreign_key+

By convention, Rails guesses that the column used to hold the foreign key on the other model is the name of this model with the suffix +_id+ added. The +:foreign_key+ option lets you set the name of the foreign key directly:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :foreign_key => "supp_id"
end
-------------------------------------------------------

TIP: In any case, Rails will not create foreign key columns for you. You need to explicitly define them as part of your migrations.

===== +:include+

You can use the :include option to specify second-order associations that should be eager-loaded when this association is used. For example, consider these models:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end
class Account < ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end
class Representative < ActiveRecord::Base
  has_many :accounts
end
-------------------------------------------------------

If you frequently retrieve representatives directly from suppliers (+@supplier.account.representative+), then you can make your code somewhat more efficient by including representatives in the association from suppliers to accounts:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :include => :representative
end
class Account < ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end
class Representative < ActiveRecord::Base
  has_many :accounts
end
-------------------------------------------------------

===== +:order+

The +:order+ option dictates the order in which associated objects will be received (in the syntax used by a SQL +ORDER BY+ clause). Because a +has_one+ association will only retrieve a single associated object, this option should not be needed.

===== +:primary_key+

By convention, Rails guesses that the column used to hold the primary key of this model is +id+. You can override this and explicitly specify the primary key with the +:primary_key+ option.

===== +:readonly+

If you set the +:readonly+ option to +true+, then the associated object will be read-only when retrieved via the association.

===== +:select+

The +:select+ option lets you override the SQL +SELECT+ clause that is used to retrieve data about the associated object. By default, Rails retrieves all columns.

===== +:source+

The +:source+ option specifies the source association name for a +has_one :through+ association.

===== +:source_type+

The +:source_type+ option specifies the source association type for a +has_one :through+ association that proceeds through a polymorphic association.

===== +:through+

The +:through+ option specifies a join model through which to perform the query. +has_one :through+ associations are discussed in detail later in this guide.

===== +:validate+

If you set the +:validate+ option to +true+, then associated objects will be validated whenever you save this object. By default, this is +false+: associated objects will not be validated when this object is saved.

==== When are Objects Saved?

When you assign an object to a +has_one+ association, that object is automatically saved (in order to update its foreign key). In addition, any object being replaced is also automatically saved, because its foreign key will change too.

If either of these saves fails due to validation errors, then the assignment statement returns +false+ and the assignment itself is cancelled.

If the parent object (the one declaring the +has_one+ association) is unsaved (that is, +new_record?+ returns +true+) then the child objects are not saved.

If you want to assign an object to a +has_one+ association without saving the object, use the +association.build+ method.

=== The has_many Association

The +has_many+ association creates a one-to-many relationship with another model. In database terms, this association says that the other class will have a foreign key that refers to instances of this class.

==== Methods Added

When you declare a +has_many+ association, the declaring class automatically gains 13 methods related to the association:

* +_collection_(force_reload = false)+
* +_collection_<<(object, ...)+
* +_collection_.delete(object, ...)+
* +_collection_=objects+
* +_collection\_singular_\_ids+
* +_collection\_singular_\_ids=ids+
* +_collection_.clear+
* +_collection_.empty?+
* +_collection_.size+
* +_collection_.find(...)+
* +_collection_.exist?(...)+
* +_collection_.build(attributes = {}, ...)+
* +_collection_.create(attributes = {})+

In all of these methods, +_collection_+ is replaced with the symbol passed as the first argument to +has_many+, and +_collection\_singular_+ is replaced with the singularized version of that symbol.. For example, given the declaration:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Each instance of the customer model will have these methods:

[source, ruby]
-------------------------------------------------------
orders(force_reload = false)
orders<<(object, ...)
orders.delete(object, ...)
orders=objects
order_ids
order_ids=ids
orders.clear
orders.empty?
orders.size
orders.find(...)
orders.exist?(...)
orders.build(attributes = {}, ...)
orders.create(attributes = {})
-------------------------------------------------------

===== +_collection_(force_reload = false)+

The +_collection_+ method returns an array of all of the associated objects. If there are no associated objects, it returns an empty array.

[source, ruby]
-------------------------------------------------------
@orders = @customer.orders
-------------------------------------------------------

===== +_collection_<<(object, ...)+

The +_collection_<<+ method adds one or more objects to the collection by setting their foreign keys to the primary key of the calling model.

[source, ruby]
-------------------------------------------------------
@customer.orders << @order1
-------------------------------------------------------

===== +_collection_.delete(object, ...)+

The +_collection_.delete+ method removes one or more objects from the collection by setting their foreign keys to +NULL+.

[source, ruby]
-------------------------------------------------------
@customer.orders.delete(@order1)
-------------------------------------------------------

WARNING: Objects will be in addition destroyed if they're associated with +:dependent => :destroy+, and deleted if they're associated with +:dependent => :delete_all+.


===== +_collection_=objects+

The +_collection_=+ method makes the collection contain only the supplied objects, by adding and deleting as appropriate.

===== +_collection\_singular_\_ids+

The +_collection\_singular_\_ids+ method returns an array of the ids of the objects in the collection.

[source, ruby]
-------------------------------------------------------
@order_ids = @customer.order_ids
-------------------------------------------------------

===== +__collection\_singular_\_ids=ids+

The +__collection\_singular_\_ids=+ method makes the collection contain only the objects identified by the supplied primary key values, by adding and deleting as appropriate.

===== +_collection_.clear+

The +_collection_.clear+ method removes every object from the collection. This destroys the associated objects if they are associated with +:dependent => :destroy+, deletes them directly from the database if +:dependent => :delete_all+, and otherwise sets their foreign keys to +NULL+.

===== +_collection_.empty?+

The +_collection_.empty?+ method returns +true+ if the collection does not contain any associated objects.

[source, ruby]
-------------------------------------------------------
<% if @customer.orders.empty? %>
  No Orders Found
<% end %>
-------------------------------------------------------

===== +_collection_.size+

The +_collection_.size+ method returns the number of objects in the collection.

[source, ruby]
-------------------------------------------------------
@order_count = @customer.orders.size
-------------------------------------------------------

===== +_collection_.find(...)+

The +_collection_.find+ method finds objects within the collection. It uses the same syntax and options as +ActiveRecord::Base.find+.

[source, ruby]
-------------------------------------------------------
@open_orders = @customer.orders.find(:all, :conditions => "open = 1")
-------------------------------------------------------

===== +_collection_.exist?(...)+

The +_collection_.exist?+ method checks whether an object meeting the supplied conditions exists in the collection. It uses the same syntax and options as +ActiveRecord::Base.exists?+.

===== +_collection_.build(attributes = {}, ...)+

The +_collection_.build+ method returns one or more new objects of the associated type. These objects will be instantiated from the passed attributes, and the link through their foreign key will be created, but the associated objects will _not_ yet be saved.

[source, ruby]
-------------------------------------------------------
@order = @customer.orders.build({:order_date => Time.now, :order_number => "A12345"})
-------------------------------------------------------

===== +_collection_.create(attributes = {})+

The +_collection_.create+ method returns a new object of the associated type. This object will be instantiated from the passed attributes, the link through its foreign key will be created, and the associated object _will_ be saved (assuming that it passes any validations).

[source, ruby]
-------------------------------------------------------
@order = @customer.orders.create({:order_date => Time.now, :order_number => "A12345"})
-------------------------------------------------------

==== Options for has_many

In many situations, you can use the default behavior for +has_many+ without any customization. But you can alter that behavior in a number of ways. This section covers the options that you can pass when you create a +has_many+ association. For example, an association with several options might look like this:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :dependent => :delete_all, :validate => :false
end
-------------------------------------------------------

The +has_many+ association supports these options:

// * +:accessible+
* +:as+
* +:class_name+
* +:conditions+
* +:counter_sql+
* +:dependent+
* +:extend+
* +:finder_sql+
* +:foreign_key+
* +:group+
* +:include+
* +:limit+
* +:offset+
* +:order+
* +:primary_key+
* +:readonly+
* +:select+
* +:source+
* +:source_type+
* +:through+
* +:uniq+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:as+

Setting the +:as+ option indicates that this is a polymorphic association, as discussed earlier in this guide.

===== +:class_name+

If the name of the other model cannot be derived from the association name, you can use the +:class_name+ option to supply the model name. For example, if a customer has many orders, but the actual name of the model containing orders is +Transaction+, you'd set things up this way:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :class_name => "Transaction"
end
-------------------------------------------------------

===== +:conditions+

The +:conditions+ option lets you specify the conditions that the associated object must meet (in the syntax used by a SQL +WHERE+ clause).

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :confirmed_orders, :class_name => "Order", :conditions => "confirmed = 1"
end
-------------------------------------------------------

You can also set conditions via a hash:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :confirmed_orders, :class_name => "Order", :conditions => { :confirmed => true }
end
-------------------------------------------------------

If you use a hash-style +:conditions+ option, then record creation via this association will be automatically scoped using the hash. In this case, using +@customer.confirmed_orders.create+ or +@customer.confirmed_orders.build+ will create orders where the confirmed column has the value +true+.

===== +:counter_sql+

Normally Rails automatically generates the proper SQL to count the association members. With the +:counter_sql+ option, you can specify a complete SQL statement to count them yourself. 

NOTE: If you specify +:finder_sql+ but not +:counter_sql+, then the counter SQL will be generated by substituting +SELECT COUNT(*) FROM+ for the +SELECT ... FROM+ clause of your +:finder_sql+ statement.

===== +:dependent+

If you set the +:dependent+ option to +:destroy+, then deleting this object will call the destroy method on the associated objects to delete those objects. If you set the +:dependent+ option to +:delete_all+, then deleting this object will delete the associated objects _without_ calling their +destroy+ method. If you set the +:dependent+ option to +:nullify+, then deleting this object will set the foreign key in the associated objects to +NULL+.

NOTE: This option is ignored when you use the +:through+ option on the association.

===== +:extend+

The +:extend+ option specifies a named module to extend the association proxy. Association extensions are discussed in detail later in this guide.

===== +:finder_sql+

Normally Rails automatically generates the proper SQL to fetch the association members. With the +:finder_sql+ option, you can specify a complete SQL statement to fetch them yourself. If fetching objects requires complex multi-table SQL, this may be necessary.

===== +:foreign_key+

By convention, Rails guesses that the column used to hold the foreign key on the other model is the name of this model with the suffix +_id+ added. The +:foreign_key+ option lets you set the name of the foreign key directly:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :foreign_key => "cust_id"
end
-------------------------------------------------------

TIP: In any case, Rails will not create foreign key columns for you. You need to explicitly define them as part of your migrations.

===== +:group+

The +:group+ option supplies an attribute name to group the result set by, using a +GROUP BY+ clause in the finder SQL.

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :line_items, :through => :orders, :group => "orders.id"
end
-------------------------------------------------------

===== +:include+

You can use the :include option to specify second-order associations that should be eager-loaded when this association is used. For example, consider these models:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class LineItem < ActiveRecord::Base
  belongs_to :order
end
-------------------------------------------------------

If you frequently retrieve line items directly from customers (+@customer.orders.line_items+), then you can make your code somewhat more efficient by including line items in the association from customers to orders:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :include => :line_items
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class LineItem < ActiveRecord::Base
  belongs_to :order
end
-------------------------------------------------------

===== +:limit+

The +:limit+ option lets you restrict the total number of objects that will be fetched through an association.

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :recent_orders, :class_name => "Order", :order => "order_date DESC", :limit => 100
end
-------------------------------------------------------

===== +:offset+

The +:offset+ option lets you specify the starting offset for fetching objects via an association. For example, if you set +:offset => 11+, it will skip the first 11 records.

===== +:order+

The +:order+ option dictates the order in which associated objects will be received (in the syntax used by a SQL +ORDER BY+ clause).

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :order => "date_confirmed DESC"
end
-------------------------------------------------------

===== +:primary_key+

By convention, Rails guesses that the column used to hold the primary key of this model is +id+. You can override this and explicitly specify the primary key with the +:primary_key+ option.

===== +:readonly+

If you set the +:readonly+ option to +true+, then the associated objects will be read-only when retrieved via the association.

===== +:select+

The +:select+ option lets you override the SQL +SELECT+ clause that is used to retrieve data about the associated objects. By default, Rails retrieves all columns.

WARNING: If you specify your own +:select+, be sure to include the primary key and foreign key columns of the associated model. If you do not, Rails will throw an error.

===== +:source+

The +:source+ option specifies the source association name for a +has_many :through+ association. You only need to use this option if the name of the source association cannot be automatically inferred from the association name.

===== +:source_type+

The +:source_type+ option specifies the source association type for a +has_many :through+ association that proceeds through a polymorphic association.

===== +:through+

The +:through+ option specifies a join model through which to perform the query. +has_many :through+ associations provide a way to implement many-to-many relationships, as discussed earlier in this guide.

===== +:uniq+

Specify the +:uniq => true+ option to remove duplicates from the collection. This is most useful in conjunction with the +:through+ option.

===== +:validate+

If you set the +:validate+ option to +false+, then associated objects will not be validated whenever you save this object. By default, this is +true+: associated objects will be validated when this object is saved.

==== When are Objects Saved?

When you assign an object to a +has_many+ association, that object is automatically saved (in order to update its foreign key). If you assign multiple objects in one statement, then they are all saved.

If any of these saves fails due to validation errors, then the assignment statement returns +false+ and the assignment itself is cancelled.

If the parent object (the one declaring the +has_many+ association) is unsaved (that is, +new_record?+ returns +true+) then the child objects are not saved when they are added. All unsaved members of the association will automatically be saved when the parent is saved.

If you want to assign an object to a +has_many+ association without saving the object, use the +_collection_.build+ method.

=== The +has_and_belongs_to_many+ Association

The +has_and_belongs_to_many+ association creates a many-to-many relationship with another model. In database terms, this associates two classes via an intermediate join table that includes foreign keys referring to each of the classes.

==== Methods Added

When you declare a +has_and_belongs_to_many+ association, the declaring class automatically gains 13 methods related to the association:

* +_collection_(force_reload = false)+
* +_collection_<<(object, ...)+
* +_collection_.delete(object, ...)+
* +_collection_=objects+
* +_collection\_singular_\_ids+
* +_collection\_singular_\_ids=ids+
* +_collection_.clear+
* +_collection_.empty?+
* +_collection_.size+
* +_collection_.find(...)+
* +_collection_.exist?(...)+
* +_collection_.build(attributes = {})+
* +_collection_.create(attributes = {})+

In all of these methods, +_collection_+ is replaced with the symbol passed as the first argument to +has_many+, and +_collection_\_singular+ is replaced with the singularized version of that symbol.. For example, given the declaration:

[source, ruby]
-------------------------------------------------------
class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

Each instance of the part model will have these methods:

[source, ruby]
-------------------------------------------------------
assemblies(force_reload = false)
assemblies<<(object, ...)
assemblies.delete(object, ...)
assemblies=objects
assembly_ids
assembly_ids=ids
assemblies.clear
assemblies.empty?
assemblies.size
assemblies.find(...)
assemblies.exist?(...)
assemblies.build(attributes = {}, ...)
assemblies.create(attributes = {})
-------------------------------------------------------

===== Additional Column Methods

If the join table for a +has_and_belongs_to_many+ association has additional columns beyond the two foreign keys, these columns will be added as attributes to records retrieved via that association. Records returned with additional attributes will always be read-only, because Rails cannot save changes to those attributes.

WARNING: The use of extra attributes on the join table in a +has_and_belongs_to_many+ association is deprecated. If you require this sort of complex behavior on the table that joins two models in a many-to-many relationship, you should use a +has_many :through+ association instead of +has_and_belongs_to_many+.


===== +_collection_(force_reload = false)+

The +_collection_+ method returns an array of all of the associated objects. If there are no associated objects, it returns an empty array.

[source, ruby]
-------------------------------------------------------
@assemblies = @part.assemblies
-------------------------------------------------------

===== +_collection_<<(object, ...)+

The +_collection_<<+ method adds one or more objects to the collection by creating records in the join table.

[source, ruby]
-------------------------------------------------------
@part.assemblies << @assembly1
-------------------------------------------------------

NOTE: This method is aliased as +_collection_.concat+ and +_collection_.push+.

===== +_collection_.delete(object, ...)+

The +_collection_.delete+ method removes one or more objects from the collection by deleting records in the join table. This does not destroy the objects.

[source, ruby]
-------------------------------------------------------
@part.assemblies.delete(@assembly1)
-------------------------------------------------------

===== +_collection_=objects+

The +_collection_=+ method makes the collection contain only the supplied objects, by adding and deleting as appropriate.

===== +_collection\_singular_\_ids+

#   Returns an array of the associated objects' ids

The +_collection\_singular_\_ids+ method returns an array of the ids of the objects in the collection.

[source, ruby]
-------------------------------------------------------
@assembly_ids = @part.assembly_ids
-------------------------------------------------------

===== +_collection\_singular_\_ids=ids+

The +_collection\_singular_\_ids=+ method makes the collection contain only the objects identified by the supplied primary key values, by adding and deleting as appropriate.

===== +_collection_.clear+

The +_collection_.clear+ method removes every object from the collection by deleting the rows from the joining tableassociation. This does not destroy the associated objects.

===== +_collection_.empty?+

The +_collection_.empty?+ method returns +true+ if the collection does not contain any associated objects.

[source, ruby]
-------------------------------------------------------
<% if @part.assemblies.empty? %>
  This part is not used in any assemblies
<% end %>
-------------------------------------------------------

===== +_collection_.size+

The +_collection_.size+ method returns the number of objects in the collection.

[source, ruby]
-------------------------------------------------------
@assembly_count = @part.assemblies.size
-------------------------------------------------------

===== +_collection_.find(...)+

The +_collection_.find+ method finds objects within the collection. It uses the same syntax and options as +ActiveRecord::Base.find+. It also adds the additional condition that the object must be in the collection.

[source, ruby]
-------------------------------------------------------
@new_assemblies = @part.assemblies.find(:all, :conditions => ["created_at > ?", 2.days.ago])
-------------------------------------------------------

===== +_collection_.exist?(...)+

The +_collection_.exist?+ method checks whether an object meeting the supplied conditions exists in the collection. It uses the same syntax and options as +ActiveRecord::Base.exists?+.

===== +_collection_.build(attributes = {})+

The +_collection_.build+ method returns a new object of the associated type. This object will be instantiated from the passed attributes, and the link through the join table will be created, but the associated object will _not_ yet be saved.

[source, ruby]
-------------------------------------------------------
@assembly = @part.assemblies.build({:assembly_name => "Transmission housing"})
-------------------------------------------------------

===== +_collection_.create(attributes = {})+

The +_collection_.create+ method returns a new object of the associated type. This objects will be instantiated from the passed attributes, the link through the join table will be created, and the associated object _will_ be saved (assuming that it passes any validations).

[source, ruby]
-------------------------------------------------------
@assembly = @part.assemblies.create({:assembly_name => "Transmission housing"})
-------------------------------------------------------

==== Options for has_and_belongs_to_many

In many situations, you can use the default behavior for +has_and_belongs_to_many+ without any customization. But you can alter that behavior in a number of ways. This section cover the options that you can pass when you create a +has_and_belongs_to_many+ association. For example, an association with several options might look like this:

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :uniq => true, :read_only => true
end
-------------------------------------------------------

The +has_and_belongs_to_many+ association supports these options:

// * +:accessible+
* +:association_foreign_key+
* +:class_name+
* +:conditions+
* +:counter_sql+
* +:delete_sql+
* +:extend+
* +:finder_sql+
* +:foreign_key+
* +:group+
* +:include+
* +:insert_sql+
* +:join_table+
* +:limit+
* +:offset+
* +:order+
* +:readonly+
* +:select+
* +:uniq+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:association_foreign_key+

By convention, Rails guesses that the column in the join table used to hold the foreign key pointing to the other model is the name of that model with the suffix +_id+ added. The +:association_foreign_key+ option lets you set the name of the foreign key directly:

TIP: The +:foreign_key+ and +:association_foreign_key+ options are useful when setting up a many-to-many self-join. For example:

[source, ruby]
-------------------------------------------------------
class User < ActiveRecord::Base
  has_and_belongs_to_many :friends, :class_name => "User", 
    :foreign_key => "this_user_id", :association_foreign_key => "other_user_id"
end
-------------------------------------------------------

===== +:class_name+

If the name of the other model cannot be derived from the association name, you can use the +:class_name+ option to supply the model name. For example, if a part has many assemblies, but the actual name of the model containing assemblies is +Gadget+, you'd set things up this way:

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :class_name => "Gadget"
end
-------------------------------------------------------

===== +:conditions+

The +:conditions+ option lets you specify the conditions that the associated object must meet (in the syntax used by a SQL +WHERE+ clause).

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :conditions => "factory = 'Seattle'"
end
-------------------------------------------------------

You can also set conditions via a hash:

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :conditions => { :factory => 'Seattle' }
end
-------------------------------------------------------

If you use a hash-style +:conditions+ option, then record creation via this association will be automatically scoped using the hash. In this case, using +@parts.assemblies.create+ or +@parts.assemblies.build+ will create orders where the factory column has the value "Seattle".

===== +:counter_sql+

Normally Rails automatically generates the proper SQL to count the association members. With the +:counter_sql+ option, you can specify a complete SQL statement to count them yourself. 

NOTE: If you specify +:finder_sql+ but not +:counter_sql+, then the counter SQL will be generated by substituting +SELECT COUNT(*) FROM+ for the +SELECT ... FROM+ clause of your +:finder_sql+ statement.

===== +:delete_sql+

Normally Rails automatically generates the proper SQL to remove links between the associated classes. With the +:delete_sql+ option, you can specify a complete SQL statement to delete them yourself.

===== +:extend+

The +:extend+ option specifies a named module to extend the association proxy. Association extensions are discussed in detail later in this guide.

===== +:finder_sql+

Normally Rails automatically generates the proper SQL to fetch the association members. With the +:finder_sql+ option, you can specify a complete SQL statement to fetch them yourself. If fetching objects requires complex multi-table SQL, this may be necessary.

===== +:foreign_key+

By convention, Rails guesses that the column in the join table used to hold the foreign key pointing to this model is the name of this model with the suffix +_id+ added. The +:foreign_key+ option lets you set the name of the foreign key directly:

[source, ruby]
-------------------------------------------------------
class User < ActiveRecord::Base
  has_and_belongs_to_many :friends, :class_name => "User", 
    :foreign_key => "this_user_id", :association_foreign_key => "other_user_id"
end
-------------------------------------------------------

===== +:group+

The +:group+ option supplies an attribute name to group the result set by, using a +GROUP BY+ clause in the finder SQL.

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :group => "factory"
end
-------------------------------------------------------

===== +:include+

You can use the :include option to specify second-order associations that should be eager-loaded when this association is used. 

===== +:insert_sql+

Normally Rails automatically generates the proper SQL to create links between the associated classes. With the +:insert_sql+ option, you can specify a complete SQL statement to insert them yourself.

===== +:join_table+

If the default name of the join table, based on lexical ordering, is not what you want, you can use the +:join_table+ option to override the default.

===== +:limit+

The +:limit+ option lets you restrict the total number of objects that will be fetched through an association.

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :order => "created_at DESC", :limit => 50
end
-------------------------------------------------------

===== +:offset+

The +:offset+ option lets you specify the starting offset for fetching objects via an association. For example, if you set +:offset => 11+, it will skip the first 11 records.

===== +:order+

The +:order+ option dictates the order in which associated objects will be received (in the syntax used by a SQL +ORDER BY+ clause).

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :order => "assembly_name ASC"
end
-------------------------------------------------------

===== +:readonly+

If you set the +:readonly+ option to +true+, then the associated objects will be read-only when retrieved via the association.

===== +:select+

The +:select+ option lets you override the SQL +SELECT+ clause that is used to retrieve data about the associated objects. By default, Rails retrieves all columns.

===== +:uniq+

Specify the +:uniq => true+ option to remove duplicates from the collection.

===== +:validate+

If you set the +:validate+ option to +false+, then associated objects will not be validated whenever you save this object. By default, this is +true+: associated objects will be validated when this object is saved.

==== When are Objects Saved?

When you assign an object to a +has_and_belongs_to_many+ association, that object is automatically saved (in order to update the join table). If you assign multiple objects in one statement, then they are all saved.

If any of these saves fails due to validation errors, then the assignment statement returns +false+ and the assignment itself is cancelled.

If the parent object (the one declaring the +has_and_belongs_to_many+ association) is unsaved (that is, +new_record?+ returns +true+) then the child objects are not saved when they are added. All unsaved members of the association will automatically be saved when the parent is saved.

If you want to assign an object to a +has_and_belongs_to_many+ association without saving the object, use the +_collection_.build+ method.

=== Association Callbacks

Normal callbacks hook into the lifecycle of Active Record objects, allowing you to work with those objects at various points. For example, you can use a +:before_save+ callback to cause something to happen just before an object is saved.

Association callbacks are similar to normal callbacks, but they are triggered by events in the lifecycle of a collection. There are four available association callbacks:

* +before_add+
* +after_add+
* +before_remove+
* +after_remove+

You define association callbacks by adding options to the association declaration. For example:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :before_add => :check_credit_limit

  def check_credit_limit(order)
    ...
  end
end
-------------------------------------------------------

Rails passes the object being added or removed to the callback.

You can stack callbacks on a single event by passing them as an array:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :before_add => [:check_credit_limit, :calculate_shipping_charges]

  def check_credit_limit(order)
    ...
  end

  def calculate_shipping_charges(order)
    ...
  end
end
-------------------------------------------------------

If a +before_add+ callback throws an exception, the object does not get added to the collection. Similarly, if a +before_remove+ callback throws an exception, the object does not get removed from the collection.

=== Association Extensions

You're not limited to the functionality that Rails automatically builds into association proxy objects. You can also extend these objects through anonymous modules, adding new finders, creators, or other methods. For example:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders do
    def find_by_order_prefix(order_number)
      find_by_region_id(order_number[0..2])
    end
  end
end
-------------------------------------------------------

If you have an extension that should be shared by many associations, you can use a named extension module. For example:

[source, ruby]
-------------------------------------------------------
module FindRecentExtension
  def find_recent
    find(:all, :conditions => ["created_at > ?", 5.days.ago])
  end
end

class Customer < ActiveRecord::Base
  has_many :orders, :extend => FindRecentExtension
end

class Supplier < ActiveRecord::Base
  has_many :deliveries, :extend => FindRecentExtension
end
-------------------------------------------------------

To include more than one extension module in a single association, specify an array of names:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :extend => [FindRecentExtension, FindActiveExtension]
end
-------------------------------------------------------

Extensions can refer to the internals of the association proxy using these three accessors:

* +proxy_owner+ returns the object that the association is a part of.
* +proxy_reflection+ returns the reflection object that describes the association.
* +proxy_target+ returns the associated object for +belongs_to+ or +has_one+, or the collection of associated objects for +has_many+ or +has_and_belongs_to_many+.

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/11[Lighthouse ticket]

* September 28, 2008: Corrected +has_many :through+ diagram, added polymorphic diagram, some reorganization by link:../authors.html#mgunderloy[Mike Gunderloy] . First release version.
* September 22, 2008: Added diagrams, misc. cleanup by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* September 14, 2008: initial version by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
