Przewodnik po asocjacjach modułu Active Record
==============================================

Niniejszy przewodnik obejmuje opis asocjacji (_associations_) – elementów modułu Active Record. Za pomocą tego przewodnika będziesz w stanie:

* Zadeklarować asocjacje w modelach wykorzystujących moduł Active Record
* Zrozumieć różne typy asocjacji dostępnych w ramach modułu Active Record
* Stosować metody dodane do twoich modeli dzięki stworzeniu asocjacji

== Dlaczego Asocjacje?

Dlaczego potrzebne są asocjacje(_powiązania_, _połączenia_ - przyp. tłum.) między modelami? Ponieważ sprawiają one, że wspólne operacje (czyli operacje na kilku modelach – przyp.tłum.) stają się mniej skomplikowane i łatwe do implementacji w kodzie.
Na przykład, pomyśl o prostej aplikacji zawierającej dwa modele – klienta (_customer_) oraz zamówień (_order(s)_). Każdy klient może składać wiele zamówień.
Bez zdefiniowania powiązania deklaracja modelu mogłaby wyglądać tak:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
end

class Order < ActiveRecord::Base
end
-------------------------------------------------------

Teraz załóżmy, że chcielibyśmy dodać nowe zamówienie złożone przez istniejącego klienta. Należałoby zrobić coś takiego:

[source, ruby]
-------------------------------------------------------
@order = Order.create(:order_date => Time.now, :customer_id => @customer.id)
-------------------------------------------------------

Przypuśćmy, że chcemy teraz usunąć klienta. W takim przypadku powinniśmy zadbać, by wszystkie zamówienia złożone przez niego zostały również usunięte:

[source, ruby]
-------------------------------------------------------
@orders = Order.find_by_customer_id(@customer.id)
@orders.each do |order|
  order.destroy
end
@customer.destroy
-------------------------------------------------------

Z asocjacjami modułu Active Record można znacznie usprawnić tego typu operacje (i wiele innych). Poprzez deklarację możemy _powiedzieć_ Railsom, że istnieje relacja między dwoma modelami. Oto poprawione zgodnie z tymi założeniami modele - klienta i zamówienia:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end

class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

Dzięki tej zmianie stworzenie nowego zamówienia dla konkretnego klienta jest łatwiejsze:

[source, ruby]
-------------------------------------------------------
@order = @customer.orders.create(:order_date => Time.now)
-------------------------------------------------------

Także usuwanie klienta i jego wszystkich zamówień jest _o_ _wiele_ prostsze.

[source, ruby]
-------------------------------------------------------
@customer.destroy
-------------------------------------------------------

Aby dowiedzieć się więcej o różnych rodzajach asocjacji, przeczytaj następny rozdział tego przewodnika. Zapoznasz się tam z kilkoma wskazówkami i trikami przydatnymi w pracy z asocjacjami, a także z kompletnym spisem metod i opcji dla asocjacji w Railsach.

== Typy asocjacji

W Railsach _asocjacja_ to powiązanie ze sobą modeli wykorzystujących moduł Active Record. Asocjacje są realizowane poprzez makro-połączenia, a więc dzięki dodaniu stosownej funkcji do modelu poprzez jej zadeklarowanie. Na przykład, deklarując, że jeden model _należy do_ (+belongs_to+) innego, instruujesz Railsy by utrzymywały powiązanie klucza podstawowego z obcym kluczem między instancjami tych dwóch modeli, a dzięki temu otrzymujesz także szereg narzędzi (metod), które możesz wykorzystać w swoim modelu. Railsy obsługują sześć typów asocjacji:

* +belongs_to+
* +has_one+
* +has_many+
* +has_many :through+
* +has_one :through+
* +has_and_belongs_to_many+

W dalszej części przewodnika dowiesz się jak deklarować asocjacje i jak używać różnych z nich. Ale najpierw – krótkie wprowadzenie do przypadków właściwych użyć poszczególnych asocjacji. 

=== Asocjacja +belongs_to+

Asocjacja +belongs_to+ ustanawia relację  typu jeden-do-jeden z innym modelem w taki sposób, że każda instancja  zadeklarowanego modelu "należy do" (_belongs_ _to_) jednej instancji innego modelu.
Na przykład: jeśli twoja aplikacja zawiera modele klientów i ich zamówienia, a każde zamówienie przypisane jest dokładnie do jednego klienta, można zadeklarować model zamówienia w ten sposób:
 
[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------
 
image:images/belongs_to.png[diagram asocjacji belongs_to]

=== Asocjacja +has_one+

Asocjacja +has_one+ również ustanawia relację typu jeden-do-jeden pomiędzy dwoma modelami, jednak posiada inną semantykę (i jej konsekwencje). Ta asocjacja wskazuje, iż każda instancja jednego modelu posiada jedną instancję drugiego. 
Na przykład: Każdy dostawca (_supplier_) w twojej aplikacji ma tylko jedno konto – możesz zadeklarować model dostawcy w taki sposób:
 
[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end
-------------------------------------------------------
 
image:images/has_one.png[diagram asocjacji has_one]

=== Asocjacja +has_many+
 
Asocjacja +has_many+ wskazuje relację typu jeden-do-wiele. Będziesz mógł często znaleźć tę asocjację "po drugiej stronie" asocjacji +belongs_to+. Ta relacja wskazuje, że każda instancja modelu posiada zero i więcej instancji innego modelu. 
Na przykład, w aplikacji zawierającej klientów i zamówienia, model klienta mógłby zostać zadeklarowany następująco:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------
 
NOTE: Kiedy deklarujemy asocjację +has_many+, nazwa wiązanego modelu jest zamieniana na jej liczbę mnogą (oczywiście mowa tu o gramatyce języka angielskiego - przyp. tłum.).
 
image:images/has_many.png[diagram asocjacji has_many]

=== Asocjacja has_many :through
 
Asocjacja +has_many :through+ (_posiada_wiele :poprzez_) często używana jest do stworzenia relacji wiele-do-wiele z innym modelem. Asocjacja wskazuje, że zadeklarowany model może być powiązany z zerem i większą ilością instancji innego modelu poprzez trzeci model (dzięki użyciu _through_).
Na przykład, wyobraź sobie praktykę lekarską, gdzie pacjenci (_patient(s)_) rezerwują wizyty (_appointment(s)_) u lekarzy (_physician(s)_). Odpowiednio zadeklarowana asocjacja mogłaby wyglądać tak:

[source, ruby]
-------------------------------------------------------
class Physician < ActiveRecord::Base
  has_many :appointments
  has_many :patients, :through => :appointments
end

class Appointment < ActiveRecord::Base
  belongs_to :physician
  belongs_to :patient
end

class Patient < ActiveRecord::Base
  has_many :appointments
  has_many :physicians, :through => :appointments
end
-------------------------------------------------------

image:images/has_many_through.png[diagram asocjacji has_many :through]
 
Asocjacja +has_many :through+ przydaje się także do tworzenia "skrótów" poprzez zagnieżdżone asocjacje +has_many+. Na przykład, jeśli dokument ma wiele rozdziałów (_sections_), a rozdział wiele paragrafów (_paragraph_), możesz czasem chcieć utworzyć prosty zbiór (in. kolekcję - _collection_) wszystkich paragrafów w dokumencie. Da się to zrobić w ten sposób:

[source, ruby]
-------------------------------------------------------
class Document < ActiveRecord::Base
  has_many :sections
  has_many :paragraphs, :through => :sections
end

class Section < ActiveRecord::Base
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ActiveRecord::Base
  belongs_to :section
end
-------------------------------------------------------

=== Asocjacja +has_one :through+

Asocjacja +has_one :through+ (_posiada jeden :poprzez_) ustanawia relację typu jeden-do-jeden z innym modelem. Asocjacja ta wskazuje, że deklaracja jednego modelu może być dopasowana do instancji innego modelu poprzez model trzeci. 
Na przykład, jeśli każdy dostawca posiada jedno konto (_account_), a każde konto jest powiązane (_associate_) z jedną historią konta (_account history_), wtedy model klienta  mógłby wyglądać następująco:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
  has_one :account_history, :through => :account
end

class Account < ActiveRecord::Base
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ActiveRecord::Base
  belongs_to :account
end
-------------------------------------------------------

image:images/has_one_through.png[diagram asocjacji has_one :through]

=== Asocjacja +has_and_belongs_to_many+

Asocjacja has_and_belongs_to_many tworzy bezpośrednią relację typu wiele-do-wiele z innym modelem bez ingerencji modelu pośredniego (nie ma potrzeby deklarowania go, jednak zauważyć należy, iż jest tworzona automatycznie stosowna tabela wiążąca -przyp.tłum.).
Na przykład, jeżeli projekt miałby zawierać zbiory (zestawy - _assembly(ies)_)  i części (_part(s)_) oraz każdy zbiór posiadałby wiele części, a każda część mogłaby pojawić się w wielu zbiorach,  modele można zadeklarować w ten sposób:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

image:images/habtm.png[diagram asocjacji has_and_belongs_to_many]
 
=== Wybór pomiędzy +belongs_to+ i +has_one+
 
Jeśli chcesz ustawić relację typu jeden-do-jeden między dwoma modelami, powinieneś użyć asocjacji +belongs_to+ do jednego i +has_one+ do drugiego. Ale skąd wiedzieć która powinna być w którym modelu?

Rozróżnić to należy sprawdzając, w której tabeli (w którym modelu) ustawiłeś klucz obcy (foreign key) (dla klasy tej tabeli potrzebujesz asocjacji +belongs_to+), ale powinieneś pomyśleć także nad znaczeniem danych. Relacja +has_one+ mówi, że "jednen ze zbioru" należy do ciebie – tzn. że coś wskazuje z powrotem na ciebie. 
Na przykład: Ma większy sens powiedzenie, że dostawca posiada konto, aniżeli konto posiada dostawcę. To sugeruje nam, że poprawne relacje wyglądają tak:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end

class Account < ActiveRecord::Base
  belongs_to :supplier
end
-------------------------------------------------------

Powiązana relacja może wyglądać tak:

[source, ruby]
-------------------------------------------------------
class CreateSuppliers < ActiveRecord::Migration
  def self.up
    create_table :suppliers do |t|
      t.string  :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.integer :supplier_id
      t.string  :account_number
      t.timestamps
    end
  end

  def self.down
    drop_table :accounts
    drop_table :suppliers
  end
end
-------------------------------------------------------

NOTE: Użycie t.integer :supplier_id powoduje, że nazwa klucza obcego jest podana wprost, ale jednocześnie samo użycie
klucza jest niejawne. W obecnej wersji Railsów można ukryć ten szczegół implementacyjny używając składni t.references :supplier
 
=== Wybór pomiędzy +has_many :through+ i +has_and_belongs_to_many+

Railsy oferują dwa sposoby deklaracji relacji tyou wiele-do-wiele między modelami. Łatwiejszym wyjściem jest użycie +has_and_belongs_to_many+, które umożliwia bezpośrednie ustanowienie asocjacji:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

Druga opcja implementacji relacji tyou wiele-do-wiele to użycie +has_many :through+. Ustanawia to asocjację pośrednio, poprzed dołączenie dodatkowego modelu (_join model_): 

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_many :manifests
  has_many :parts, :through => :manifests
end

class Manifest < ActiveRecord::Base
  belongs_to :assembly
  belongs_to :part
end

class Part < ActiveRecord::Base
  has_many :manifests
  has_many :assemblies, :through => :manifests
end
-------------------------------------------------------

Najłatwiejsza zasada polega na tym, że ustawiasz relację +has_many :through+ jeśli chcesz pracować z pośrednim (wiążącym pozostałe dwa) modelem jako niezależnym bytem. Jeśli jednak nie potrzebujesz niczego z nim robić, łatwiejsze będzie wykorzystanie asocjacji +has_and_belongs_to_many+ (choć musisz pamiętać, że należy stworzyć tabelę łączącą)

Należy używać +:has_many :through+ jeśli potrzebujesz opcji walidacji, callback-ów lub dodatkowych atrybutów dla wiążącego modelu.
 
=== Asocjacje polimorficzne

Nieco bardziej zaawansowanym typem asocjacji jest asocjacja polimorficzna. Dzięki polimorficznym asocjacjom model może być powiązany z więcej niż jednym innym modelem, za pomocją pojedynczej asocjacji. 
Na przykład, chcesz mieć model  "zdjęcia" (_picture_), który należy do (+belongs_to+) modelu pracownika (_employee_) lub produktu (_product_). Oto w jaki sposób mogłoby to zostać zadeklarowane:

[source, ruby]
-------------------------------------------------------
class Picture < ActiveRecord::Base
  belongs_to :imageable, :polymorphic => true
end

class Employee < ActiveRecord::Base
  has_many :pictures, :as => :imageable
end

class Product < ActiveRecord::Base
  has_many :pictures, :as => :imageable
end
-------------------------------------------------------

Mógłbyś pomyśleć, że polimofriczna deklaracja +belongs_to+ ustanawia taki interfejs, że żaden inny model nie może go użyć. Z instancji modelu pracownika (+Employee+) można pobrać zbiór zdjęć: +@employee.pictures+. Podobnie, możesz pobrać zdjęcia produktów - +@product.pictures+. Jeśli masz instancję modelu zdjęcia (+Picture+), możesz "dostać się" do jego rodzica dzięki +@picture.imageable+. By to zadziałało, potrzebujesz zadeklarować w modelu, który ma mieć polimorficzny interfejs (tu: +Picture+) dwie rzeczy: klucz obcy (dla id pracownika lub produktu – przyp. tłum.), jak i "typ” wiązanego modelu:

[source, ruby]
-------------------------------------------------------
class CreatePictures < ActiveRecord::Migration
  def self.up
    create_table :pictures do |t|
      t.string  :name
      t.integer :imageable_id
      t.string  :imageable_type
      t.timestamps
    end
  end

  def self.down
    drop_table :pictures
  end
end
-------------------------------------------------------

Migracja dla takiego modelu może być uproszczona dzięki użyciu t.references: 

[source, ruby]
-------------------------------------------------------
class CreatePictures < ActiveRecord::Migration
  def self.up
    create_table :pictures do |t|
      t.string  :name
      t.references :imageable, :polymorphic => true
      t.timestamps
    end
  end

  def self.down
    drop_table :pictures
  end
end
-------------------------------------------------------

image:images/polymorphic.png[diagram asocjacji polimorficznej]
 
=== Samoodniesienie (wiązanie rekurencyjne)

Przy projektowaniu modeli danych, możesz czasem natknąć się na model, który powinien mieć odniesienie do siebie samego. Na przykład, chcesz przechowywać wszystkich pracowników w jednym modelu bazy danych (w jednej tabeli w bazie), ale też chciałbyś móc prześledzić hierarchie między pracownikami (takie jak manager i jego podwładni). Takie powiązanie może być zadeklarowane za pomocą asocjacji samoodniesienia:

[source, ruby]
-------------------------------------------------------
class Employee < ActiveRecord::Base
  has_many :subordinates, :class_name => "Employee", :foreign_key => "manager_id"
  belongs_to :manager, :class_name => "Employee"
end
-------------------------------------------------------

Dzięki takiemu ustawieniu możesz "wyciągnąć" +@employee.subordinates+ (podwładni pracownika) i +@employee.manager+ (manager pracownika).

== Porady, triki i ostrzeżenia

W tym rozdziale znajdziesz kilka rzeczy, które powinieneś wiedzieć, by skutecznie używać modułu Active Record w twoich aplikacjach Rails. 

* Kontrolowanie cachingu
* Unikanie kolizji w nazwach 
* Aktualizacje schematów 
* Kontrolowanie zakresu widoczności asocjacji
 
=== Kontrolowanie cachingu

Wszystkie metody asocjacji są cache-owane tak, że wynik ostatniego zapytania dostępny jest dla następnych operacji. Zawartość _cache_ jest nawet widoczna z innych metod. Na przykład:
 
[source, ruby]
-------------------------------------------------------
customer.orders               # pobiera zamówienia z bazy danych
customer.orders.size          # używa kopii zamówień z cache
customer.orders.empty?        # używa kopii zamówień z cache
-------------------------------------------------------

Ale co zrobić, gdy potrzeba uaktualnić _cache_, bo dane być może zostały zmienione przez inną część aplikacji? Po prostu ustaw +true+ dla wywołania asocjacji:

[source, ruby]
-------------------------------------------------------
customer.orders               # pobiera zamówienia z bazy danych
customer.orders.size          # używa kopii zamówień z cache
customer.orders(true).empty?  # odrzuca kopię zamówień będącą w cache i "wraca" do bazy danych
-------------------------------------------------------

=== Unikanie kolizji nazw
 
Nazwy twoich asocjacji nie mgą być dowolne. Ponieważ tworzenie asocjacji automatycznie dodaje do modelu metodę z taką samą nazwą, złym pomysłem jest nazywanie asocjacji tak samo jak metody instancji ActiveRecord::Base. Metoda asocjacji w takim przypadku przesłoni metodę bazy, a to nie jest pożądane. Przykładem złych nazw asocjacji są +attributes+ albo +connection+. 
 
=== Aktualizacja schematu
 
Asocjacje są bardzo przydatne, ale nie są magiczne. Jesteś odpowiedzialny za utrzymanie schematu  bazy danych w dopasowaniu do swoich asocjacji. W praktyce oznacza to dwie rzeczy, w zależności od tego, którego rodzaju asocjacji użyłeś w swoim modelu. Dla asocjacji +belongs_to+ porzebujesz stworzyć klucze obce, a dla +has_and_belongs_to_many+ - stosowną wiążącą tabelę (w bazie).
 
==== Tworzenie kluczy obcych dla asocjacji +belongs_to+

Kiedy deklarujesz asocjację +belongs_to+, powinieneś stworzyć odpowiednie klucze obce. Na przykład, rozważ taki model:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

Taka deklaracja  powinna być uwzgleniona i "wsparta" odpowiednią deklaracją klucza obcego w tabeli zamówień:

[source, ruby]
-------------------------------------------------------
class CreateOrders < ActiveRecord::Migration
  def self.up
    create_table :orders do |t|
      t.datetime   :order_date
      t.string     :order_number 
      t.integer    :customer_id 
    end
  end

  def self.down
    drop_table :orders
  end
end
-------------------------------------------------------

Jeśli tworzysz asocjację po jakimś czasie od stworzenia modelu bazowego, musisz pamiętać o stworzeniu migracji +add_column+ (dodaj kolumnę) by zapewnić modelowi odpowiedni klucz obcy.

==== Creating Join Tables for +has_and_belongs_to_many+ Associations

Jeśli tworzysz asocjację +has_and_belongs_to_many+ potrzebujesz stworzyć wiążącą tabelę. Dopóki nazwa dołączanej tabeli nie jest wyraźnie określona poprzez użycie opcji +:join_table+, moduł Active Record utworzy nazwę używając leksykalnego (alfabetycznego) )porządku tworzenia nazw. Zatem: połączenie między modelem  klienta (customer) a zamówieniem (order) otrzyma domyślną nazwę tabeli "customers_orders" (zamówienia klientów), bo "c" jest w alfabecie przed "o".

WARNING: Pierwszeństwo między nazwami modeli jest "obliczane" przy użyciu operatora "<" (mniejszości) dla stringów (łańcuchów znaków). To znaczy, ze jeśli słowa są różnej długości, ale początkowy łańcuch jest jednakowy – wtedy wyżej w tym porządku jest słowo dłuższe. Na przykład, możnaby oczekiwać, że dla tabeli paper_boxes i papers wygenerowana nazwa wiążącej tabeli będzie brzmiała "papers_paper_boxes", ze względu na długość łańcucha "paper_boxes". Jednak w rzeczywistości wygenerowana zostanie nazwa "paper_boxes_papers".
 
Niezależnie od nazwy, musisz "ręcznie" wygenerować wiążącą tabelę za pomocą odpowiedniej migracji. Na przykład, rozważ takie asocjacje:

[source, ruby]
-------------------------------------------------------
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

Powinny one zostać zaktualizowane za pomocą migracji, która wygeneruje tabelę +assemblies_parts+. Taka tabela powinna być stworzona bez klucza podstawowego:

[source, ruby]
-------------------------------------------------------
class CreateAssemblyPartJoinTable < ActiveRecord::Migration
  def self.up
    create_table :assemblies_parts, :id => false do |t|
      t.integer :assembly_id
      t.integer :part_id
    end
  end

  def self.down
    drop_table :assemblies_parts
  end
end
-------------------------------------------------------

=== Kontrolowanie zakresu widoczności asocjacji
 
Domyślnie asocjacje "szukają" obiektów tylko w ramach bieżącego zakresu widoczności modułów. To może być ważne, gdy deklarujesz modele wykorzystujące ActiveRecord wewnątrz modułu, na przykład:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    end

    class Account < ActiveRecord::Base
       belongs_to :supplier
    end
  end
end
-------------------------------------------------------

Powyższy kod będzie działał dobrze, bo zarówno klasa dostawcy, jak i klasa konta są zdefiniowane w ramach tego samego zakresu (zakresu widoczności modelu). Ale już poniższy przykład nie będzie działać, bo dostawca i konto są zdefiniowane w różnych zakresach widoczności:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    end
  end

  module Billing
    class Account < ActiveRecord::Base
       belongs_to :supplier
    end
  end
end
-------------------------------------------------------

By powiązać dwa modele istniejące w ramach różnych zakresów – musisz podać pełną nazwę klasy w deklaracji asocjacji:  

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account, :class_name => "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ActiveRecord::Base
       belongs_to :supplier, :class_name => "MyApplication::Business::Supplier"
    end
  end
end
-------------------------------------------------------

== Szczegółowy spis asocjacji

Niniejszy rozdział ukaże ci szczegóły każdego typu asocjacji, w tym informacje o metodach, które dzięki nim zyskujesz oraz opcji, których możesz uzywać dzięki zadeklarowaniu asocjacji.

=== Asocjacja belongs_to
 
Asocjacja +belongs_to+ tworzy relację typu jeden-do-jeden z innym modelem. W języku baz danych, oznacza to że dana klasa zawiera klucz obcy. Jeśli inna klasa zawiera klucz obcy, powinieneś raczej użyć asocjacji +has_one+

==== Metody dodane dzięki +belongs_to+

Kiedy zadeklarujesz asocjację belongs_to, deklarowana klasa automatycznie zyskuje pięć metod odnoszących się do asocjacji:
 
* +_association_(force_reload = false)+
* +_association_=(associate)+
* +_association_.nil?+
* +build___association__(attributes = {})+
* +create___association__(attributes = {})+
 
We wszystkich tych metodach +_association_+ zastępuje się symbolem przekazanym jako pierwszy argument do +belongs_to+. Na przykład gdy mamy deklarację:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
-------------------------------------------------------

Każda instancja wybranego modelu będzie posiadała poniższe metody:

[source, ruby]
-------------------------------------------------------
customer
customer=
customer.nil?
build_customer
create_customer
-------------------------------------------------------

===== +_association_(force_reload = false)+

Metoda +_association_+ zwraca wiązany obiekt, jeśli tylko taki istnieje. Jeśli wiązany obiekt nie został znaleziony, metoda zwraca +nil+.

[source, ruby]
-------------------------------------------------------
@customer = @order.customer
-------------------------------------------------------

Jeśli wiązany obiekt został już pobrany z bazy danych, zwrócona będzie jego wersja przechowywana w _cache_. Aby to zmienić  (i wymusić czytanie z bazy), ustaw +true+ przy argumencie +force_reload+
 
===== +_association_=(associate)+

Metoda +_association_=+ przydziela wiązanemy obiekt do naszego obiektu. Od środka wygląda to tak, że wydobywa ona z wiązanego obiektu klucz podstawowy i ustawia naszemu obiektowi klucz obcy na tę samą wartość.

[source, ruby]
-------------------------------------------------------
@order.customer = @customer
-------------------------------------------------------

===== +_association_.nil?+

metoda +_association_.nil?+ zwraca wartość +true+ jeśli nie znaleziono wiązanego obiektu.

[source, ruby]
-------------------------------------------------------
if @order.customer.nil?
  @msg = "No customer found for this order"
end
-------------------------------------------------------

===== +build___association__(attributes = {})+

Metoda +build__association_+ zwraca nowy obiekt wiązanego typu. Ten obiekt zostanie natychmiast utworzony z ustawionych atrybutów,  będzie ustawiony odnośnik do obcego klucza tego obiektu, ale wiązany obiekt _nie zostanie_ zapisany. 

[source, ruby]
-------------------------------------------------------
@customer = @order.build_customer({:customer_number => 123, :customer_name => "John Doe"})
-------------------------------------------------------

===== +create___association__(attributes = {})+

Metoda +create__association_+ zwraca nowy obiekt wiązanego typu, Ten obiekt zostanie natychmiast utworzony z ustawionych atrybutów i będzie ustawiony odnośnik do obcego klucza tego obiektu. Ponadto wiązany obiekt zostanie zapisany (zakładając, że przejdzie pomyślnie przez walidację).

[source, ruby]
-------------------------------------------------------
@customer = @order.create_customer({:customer_number => 123, :customer_name => "John Doe"})
-------------------------------------------------------

==== Opcje dla +belongs_to+

W wielu sytuacjach możesz użyć asocjacji +belongs_to+ bez potrzeby jej dostosowywania. Ale pomimo Ralisowego nacisku na górowanie konwencji nad dostosowaniem do własnych potrzeb, możesz zmieniać domyślne ustawienia na kilka sposobów. Ten rozdział przedstawi ci opcje, których możesz używać, kiedy zadeklarujesz asocjację +belongs_to+. Na przykład asocjacja z kilkoma opcjami może wyglądać tak:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => true, :conditions => "active = 1"
end
-------------------------------------------------------

Asocjacja +belongs_to+ wspiera następujące opcje

// * +:accessible+
* +:class_name+
* +:conditions+
* +:counter_cache+
* +:dependent+
* +:foreign_key+
* +:include+
* +:polymorphic+
* +:readonly+
* +:select+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:class_name+

Jeśli nazwa innego modelu nie może zostać utworzona z nazwy asocjacji, możesz użyć opcji +:class-name+, by dostarczyć własną nazwę modelu. Na przykład, jeśli zamówienie należy [_belongs to_] do klienta, ale aktualna nazwa zawierająca klientów to +Patron+, możesz to ustawić w ten sposób:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :class_name => "Patron"
end
-------------------------------------------------------

===== +:conditions+

Opcja +:conditions+ pozwala określić warunki, jakie wiązany obiekt musi spełniać (W składni SQL użyłbyś klauzuli WHERE).

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :conditions => "active = 1"
end
-------------------------------------------------------

===== +:counter_cache+

Opcja +:counter_cache+ może sprawić, że znajdowanie liczby powiązanych obiektów będzie bardziej wydajne (szybsze). Rozważ te modele:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Z powyższymi deklaracjami, znalezienie wartości +@customer.orders.size+ (wielkość [ilość] zamówień klientów) wymaga zapytania do bazy wykorzystującego +COUNT(*)+. Aby uniknąć tego połączenia możesz dodać :counter_cache ("licznik w cache") do modelu: 

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => true
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------
 
Dzięki tej deklaracji Railsy będą pobierały bieżącą wartość cache i zwrócą ją w odpowiedzi na metodę +.size+.

Pomimo, że opcja +:counter_cache+ jest określona dla modelu zawierającego deklarację +belongs_to+, bieżąca kolumna musi być dodana do wiązanego modelu. W powyższym przypadku musisz dodać kolumnę o nazwie+orders_count+ do modelu klienta [+Customer+]. Możesz zamienić domyślną nazwę kolumny, jeśli tylko chcesz:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :counter_cache => :count_of_orders
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Kolumny _licznika_ są dodawane do listy atrybutów tylko-do-odczytu wiązanego modelu (poprzez +attr_readonly+)

===== +:dependent+

Jeśli ustawisz opcję +:dependent+ na :destroy, wtedy usunięcie tego obiektu wywoła metodę destroy na wiązanym obiekcie, by usunąć ten obiekt. Jeżeli ustawisz opcję +:dependent+ na +:delete+, wtedy usunięcie tego obiektu spowoduje usunięcie obiektu wiązanego _bez_ wywoływania dla niego metody +destroy+.

WARNING: Nie używaj tej opcji w asocjacji +belongs_to+, która jest połączona z asocjacją +has_many+ w innej klasie. W przeciwnym wypadku w twojej bazie pojawią się rekordy osierocone.

===== +:foreign_key+

Zgodnie z konwencją, Railsy "domyślają się", że kolumna używana do przechowywania klucza obcego to nazwa asocjacji z dodanym przyrostkiem +_id+. Opcja +:foreign_key+ umożliwia ustawienie nazwy klucza obcego bezpośrednio:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  belongs_to :customer, :class_name => "Patron", :foreign_key => "patron_id"
end
-------------------------------------------------------

TIP: W żadnym z wypadków Railsy nie będą same tworzyły dla ciebie kolumn klucza obcego. Musisz zdefiniować te klucze w swoich migracjach.

===== +:include+

Możesz użyć opcji +:include+ do podania drugorzędnych asocjacji, które zostaną załadowane wtedy, gdy zostanie użyta dana asocjacja. Na przykład, rozważmy takie modele:

[source, ruby]
-------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Jeśli często pobierasz klienta bezpośrednio z pozycji w jego zamówieniu [_line item_] (+@line_item.order.customer+), możesz sprawić, że twój kod będzie wydajniejszy, włączając klienta w asocjacji z pozycją w zamówieniu do zamówienia:

[source, ruby]
-------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order, :include => :customer
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

NOTE: Nie ma potrzeby stosowania +:include+ do bezpośrednich asocjacji, to znaczy: jeśli masz zdefiniowaną w modelu relację zamówień należących do  (_belongs to_) klientów, wtedy "klient" jest przygotowany do wczytania zawsze, kiedy tylko jest potrzebny.

===== +:polymorphic+

Ustawienie +true+ dla opcji +:polymorphic+ wskazuje, że asocjacja jest polimorficzna. Asocjacje polimorficzne zostały omówione wcześniej w tym przewodniku.

===== +:readonly+

Jeśli ustawisz +true+ dla opcji +:readonly+, asocjowany obiekt będzie tylko do odczytu, gdy wywoływana jest asocjacja.

===== +:select+

Użyj opcji +:select+ by zastąpić klauzulę SQL +SELECT+, która służy do wyszukiwania danych w wiązanym obiekcie. Domyślnie Railsy pobierają wszystkie kolumny. 

TIP: Po ustawieniu opcji +:select+ dla asocjacji +belongs_to+, powinieneś też ustawić opcję +:foreign_key+, by mieć pewność, że uzyskasz poprawny wynik zapytania

===== +:validate+

Kiedy ustawisz na +true+ opcję +:validate+,  wiązane obiekty będą walidowane zawsze, kiedy będziesz je zapisywać. Domyślne ustawienie to +false+: wiązane obiekty nie są walidowane kiedy je zapisujesz.

==== Kiedy obiekty są zapisywane?

Przypisywanie obiektu do asocjacji +belongs_to+ nie zapisuje go automatycznie. Nie zapisuje to także wiązanego obiektu.

=== Asocjacja +has_one+

Asocjacja has_one tworzy relację typu jeden-do-jeden pomiędzy modelami. W języku baz danych oznacza to, że inna klasa zawiera klucz obcy. Jeżeli to rozpatrywana aktualnie klasa zawiera klucz obcy, należy użyć asocjacji +belongs_to+ zamiast +has_one+.

==== Metody dodane dzięki +has_one+

Kiedy zadeklarujesz asocjację +has_one+, deklarowana klasa automatycznie zyskuje pięć metod odnoszących się do asocjacji:

* +_association_(force_reload = false)+
* +_association_=(associate)+
* +_association_.nil?+
* +build___association__(attributes = {})+
* +create___association__(attributes = {})+

We wszystkich tych metodach +_association_+ zastępuje się symbolem przekazanym jako pierwszy argument do +has_one+. Na przykład gdy mamy deklarację:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end
-------------------------------------------------------

Każda instancja modelu dostawcy (+Supplier+) będzie posiadała poniższe metody:

[source, ruby]
-------------------------------------------------------
account
account=
account.nil?
build_account
create_account
-------------------------------------------------------

===== +_association_(force_reload = false)+

Metoda +_association_+ zwraca wiązany obiekt, jeśli tylko taki istnieje. Jeśli wiązany obiekt nie został znaleziony, metoda zwraca +nil+.

[source, ruby]
-------------------------------------------------------
@account = @supplier.account
-------------------------------------------------------

Jeśli wiązany obiekt został już pobrany z bazy danych, zwrócona będzie jego wersja przechowywana w _cache_. Aby to zmienić (i wymusić czytanie z bazy), ustaw +true+ przy argumencie +force_reload+
 
===== +_association_=(associate)+

Metoda +_association_=+ przydziela wiązanemu obiekt do naszego obiektu. Od środka wygląda to tak, że wydobywa ona z naszego obiektu klucz podstawowy i ustawia wiązanemu obiektowi klucz obcy na tę samą wartość.

[source, ruby]
-------------------------------------------------------
@suppler.account = @account
-------------------------------------------------------

===== +_association_.nil?+

Metoda +_association_.nil?+ zwraca wartość +true+ jeśli nie znaleziono wiązanego obiektu.

[source, ruby]
-------------------------------------------------------
if @supplier.account.nil?
  @msg = "No account found for this supplier"
end
-------------------------------------------------------

===== +build___association__(attributes = {})+

Metoda +build__association_+ zwraca nowy obiekt wiązanego typu. Ten obiekt zostanie natychmiast utworzony z ustawionych atrybutów, będzie ustawiony odnośnik do jego obcego klucza tego obiektu, ale wiązany obiekt _nie zostanie_ zapisany.
 
[source, ruby]
-------------------------------------------------------
@account = @supplier.build_account({:terms => "Net 30"})
-------------------------------------------------------

===== +create___association__(attributes = {})+

Metoda +create___association_+ zwraca nowy obiekt wiązanego typu, Ten obiekt zostanie natychmiast utworzony z ustawionych atrybutów i będzie ustawiony odnośnik do jego obcego klucza. Ponadto wiązany obiekt zostanie zapisany (zakładając, że przejdzie pomyślnie przez walidację).

[source, ruby]
-------------------------------------------------------
@account = @supplier.create_account({:terms => "Net 30"})
-------------------------------------------------------

==== Opcje dla +has_one+

W wielu sytuacjach możesz użyć asocjacji +has_one+ bez potrzeby jej dostosowywania. Ale pomimo Ralisowego nacisku na górowanie konwencji nad dostosowaniem do własnych potrzeb, możesz zmieniać domyślne ustawienia na kilka sposobów. Ten rozdział przedstawi ci opcje, których możesz używać, kiedy zadeklarujesz asocjację +has_one+. Na przykład asocjacja z kilkoma opcjami może wyglądać tak:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :class_name => "Billing", :dependent => :nullify
end
-------------------------------------------------------

Asocjacja +has_one+ wspiera następujące opcje

// * +:accessible+
* +:as+
* +:class_name+
* +:conditions+
* +:dependent+
* +:foreign_key+
* +:include+
* +:order+
* +:primary_key+
* +:readonly+
* +:select+
* +:source+
* +:source_type+
* +:through+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:as+

Użycie opcji +:as+  wskazuje, że mamy do czynienia z asocjacją polimorficzną. Polimorficzne asocjacje zostały omówione szczegółowo ww wcześniejszej części podręcznika.

===== +:class_name+

Jeśli nazwa innego modelu nie może zostać utworzona z nazwy asocjacji, możesz użyć opcji +:class-name+, by dostarczyć własną nazwę modelu. Na przykład, jeśli dostawca posiada konto, ale aktualna nazwa zawierająca konta to +Billing+, możesz to ustawić w ten sposób:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :class_name => "Billing"
end
-------------------------------------------------------

===== +:conditions+

Opcja +:conditions+ pozwala określić warunki, jakie wiązany obiekt musi spełniać (W składni SQL użyłbyś klauzuli WHERE).

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :conditions => "confirmed = 1"
end
-------------------------------------------------------

===== +:dependent+

Jeśli ustawisz opcję +:dependent+ na :destroy, wtedy usunięcie tego obiektu wywoła metodę destroy na wiązanym obiekcie, by usunąć ten obiekt. Jeżeli ustawisz opcję +:dependent+ na +:delete+, wtedy usunięcie tego obiektu spowoduje usunięcie obiektu wiązanego _bez_ wywoływania dla niego metody +destroy+. Jeśli ustawisz opcję +:dependent+ na +:nullify+, usunięcie tego obiektu sprawi, że klucz obcy w wiązanym obiekcie zostanie zastąpiony przez +NULL+.

===== +:foreign_key+

Zgodnie z konwencją, Railsy "domyślają się", że kolumna używana do przechowywania klucza obcego w innym modelu to nazwa pierwszego modelu z przyrostkiem _id. Opcja +:foreign_key+ umożliwia ustawienie nazwy klucza obcego bezpośrednio:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :foreign_key => "supp_id"
end
-------------------------------------------------------

TIP: W żadnym z wypadków Railsy nie będą same tworzyły dla ciebie kolumn klucza obcego. Musisz zdefiniować te klucze w swoich migracjach.

===== +:include+

Możesz użyć opcji +:include+ do podania drugorzędnych asocjacji, które zostaną załadowane wtedy, gdy zostanie użyta dana asocjacja. Na przykład, rozważmy takie modele:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account
end
class Account < ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end
class Representative < ActiveRecord::Base
  has_many :accounts
end
-------------------------------------------------------

Jeśli często pobierasz przedstawicieli bezpośrednio od dostawców (+@supplier.account.representative+), możesz sprawić, że twój kod będzie wydajniejszy, załączając przedstawicieli w asocjacji poszczególnych dostawców do kont:

[source, ruby]
-------------------------------------------------------
class Supplier < ActiveRecord::Base
  has_one :account, :include => :representative
end
class Account < ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end
class Representative < ActiveRecord::Base
  has_many :accounts
end
-------------------------------------------------------

===== +:order+

Opcja +:order+ (_uporządkuj_) ustawia porządek w jakim powiązane obiekty będą "wyciągane" z bazy (w składni SQL użyłbyś klauzuli +ORDER BY+). Ponieważ +has_one+ pobierać będzie tylko jeden wiązany obiekt, opcja ta nie będzie potrzebna.

===== +:primary_key+

Zgodnie z konwencją Railsy "domyślają się" że kolumna z kluczem podstawowym w modelu to "id". Możesz to zmienić i samodzielnie określić klucz podstawowy dzięki opcji +:primary_key+.

===== +:readonly+

Jeśli ustawisz +true+ dla opcji +:readonly+, asocjowany obiekt będzie tylko do odczytu, gdy wywoływana jest asocjacja.

===== +:select

Użyj opcji +:select+ by zastąpić klauzuję SQL +SELECT+, która służy do wyszukiwania danych w wiązanym obiekcie. Domyślnie Railsy pobierają wszystkie kolumny.

===== +:source+

Opcja source określa źródło asocjacji dla asocjacji typu  +has_one :through+.

===== +:source_type+

Opcja +:source_type+ określa typ źródła asocjacji dla asocjacji +has_one :through+; związane jest to z asocjacją polimorficzną.

===== +:through+

Opcja +:through+ (_poprzez_) określa wiążący model, poprzez który wykonywane sż zapytania. Asocjacje +has_one :through+ są omówione w dalszej części przewodnika.

===== +:validate+

Kiedy ustawisz na +true+ opcję +:validate+, wiązane obiekty będą walidowane zawsze, kiedy będziesz je zapisywać. Domyślne ustawienie to +false+: wiązane obiekty nie są walidowane kiedy je zapisujesz.

==== Kiedy obiekty są zapisywane?

Kiedy przypisujesz obiekt do asocjacji +has_one+, jest on zapisywany automatycznie (by zaktualizować jego klucz obcy). Ponadto każdy obiekt, który został zmieniony jest również automatycznie zapisywany, ponieważ jego klucz obcy także się zmienił.

Jeśli którykolwiek z tych zapisów nie powiedzie się z winy błędu walidacji, wtedy rozkaz przypisania zwróci +false+, a samo przypisanie jest anulowane.

Jeśli obiekt-rodzic (ten, w którym zadeklarowałeś asocjację +has_one+) nie został zapisany (to jest, gdy +new_record?+ zwraca wartość +true+), wtedy obiekt-dziecko nie jest zapisywany.

Jeśli chcesz przypisać obiekt do asocjacji has_one bez zapisywania obiektu, użyj metody +association.build+.

=== The has_many Association

Asocjacja +has_many+ tworzy relację typu jeden-do-wiele z innym modelem. W języku baz danych oznacza to, że inna klasa zawiera klucz obcy, który odnosi się do instancji rozpatrywanej klasy.

==== Dodane metody

Kiedy zadeklarujesz asocjację +has_many+, deklarowana klasa automatycznie zyskuje 13 metod odnoszących się do tej asocjacji:

* +_collection_(force_reload = false)+
* +_collection_<<(object, ...)+
* +_collection_.delete(object, ...)+
* +_collection_=objects+
* +_collection\_singular_\_ids+
* +_collection\_singular_\_ids=ids+
* +_collection_.clear+
* +_collection_.empty?+
* +_collection_.size+
* +_collection_.find(...)+
* +_collection_.exist?(...)+
* +_collection_.build(attributes = {}, ...)+
* +_collection_.create(attributes = {})+

We wszystkich wymienionych metodach +_collection_+ zastępuje się symbolem przekazanym jako pierwszy argument do +has_many+ oraz +_collection\_singular_+ zastępowany jest nazwą tegoż symbolu w liczbie pojedynczej (w języku angielskim). Na przykład, biorąc pod uwagę deklarację:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end
-------------------------------------------------------

Każda instancja modelu klienta będzie posiadała poniższe metody:

[source, ruby]
-------------------------------------------------------
orders(force_reload = false)
orders<<(object, ...)
orders.delete(object, ...)
orders=objects
order_ids
order_ids=ids
orders.clear
orders.empty?
orders.size
orders.find(...)
orders.exist?(...)
orders.build(attributes = {}, ...)
orders.create(attributes = {})
-------------------------------------------------------

===== +_collection_(force_reload = false)+

Metoda +_collection_+ zwraca tablicę [_array_] wszystkich wiązanych obiektów. Jeśli nie istnieją żadne wiązane obiekty, zwraca pustą tablicę.

[source, ruby]
-------------------------------------------------------
@orders = @customer.orders
-------------------------------------------------------

===== +_collection_<<(object, ...)+

Metoda +_collection_<<+ dodaje jeden lub więcej obiektów do zbioru poprzez ustawienie ich kluczy obcych na wartość klucza podstawowego wywoływanego modelu

[source, ruby]
-------------------------------------------------------
@customer.orders << @order1
-------------------------------------------------------

===== +_collection_.delete(object, ...)+

Metoda +_collection_.delete+ usuwa jeden lub więcej obiektów ze zbioru, poprzez ustawienie ich kluczy obcych na +NULL+.

[source, ruby]
-------------------------------------------------------
@customer.orders.delete(@order1)
-------------------------------------------------------

WARNING: Obiekty będą dodatkowo niszczone, jeśli są powiązane przez  +:dependent => :destroy+ lub usuwane, jeśli są powiązane z +:dependent => :delete_all+.

===== +_collection_=objects+

Metoda +_collection_=+ usuwa i dodaje odpowiednie obiekty tak, żeby dana kolekcja zawierała tylko podane (wymienione) obiekty.

===== +_collection\_singular_\_ids+

Metoda +_collection\_singular_\_ids+ zwraca tablicę identyfikatorów (_ids_) obiektów w zbiorze

[source, ruby]
-------------------------------------------------------
@order_ids = @customer.order_ids
-------------------------------------------------------

===== +__collection\_singular_\_ids=ids+

Metoda +__collection\_singular_\_ids=+ sprawia, że w zbiorze znajdują się tylko te obiekty, których wartość podstawowego klucza równa jest wartościom dostarczonym do metody.

===== +_collection_.clear+

Metoda +_collection_.clear+ usuwa wszystkie elementy zbioru. Niszczy ona też wiązane obiekty jeśli zostały związane poprzez +:dependent => :destroy+, usuwa te wiązane poprzez +:dependent => :delete_all+ lub (w przeciwnym przypadku do dwóch wymienionych) ustawia klucze obce obiektów na +NULL+.

===== +_collection_.empty?+

Metoda +_collection_.empty?+ zwraca wartośc +true+, jeśli zbiór nie posiada żadnych związanych obiektów.

[source, ruby]
-------------------------------------------------------
<% if @customer.orders.empty? %>
  Nie znaleziono zamówień
<% end %>
-------------------------------------------------------

===== +_collection_.size+

Metoda +_collection_.size+ zwraca liczbę obiektów w zbiorze. 

[source, ruby]
-------------------------------------------------------
@order_count = @customer.orders.size
-------------------------------------------------------

===== +_collection_.find(...)+

Metoda +_collection_.find+ służy do wyszukiwania obiektów w zbiorze. Korzysta ona z tej samej składni i tych samych opcji, co ActiveRecord::Base.find.

[source, ruby]
-------------------------------------------------------
@open_orders = @customer.orders.find(:all, :conditions => "open = 1")
-------------------------------------------------------

===== +_collection_.exist?(...)+

Metoda +_collection_.exist?+ sprawdza, czy obiekt spełniający podane warunki istnieje w danej kolekcji. Metoda ta używa takiej samej składni i tych samych opcji, co ActiveRecord::Base.exists?.

===== +_collection_.build(attributes = {}, ...)+

Metoda +_collection_.build+ zwraca jeden lub więcej nowych obiektów wiązanego typu. Obiekty te będą konstruowane na podstawie podanych atrybutów. Połączenie poprzez ich klucz obcy zostanie stworzone, ale powiązane obiekty _nie_ będą zapisane.

[source, ruby]
-------------------------------------------------------
@order = @customer.orders.build({:order_date => Time.now, :order_number => "A12345"})
-------------------------------------------------------

===== +_collection_.create(attributes = {})+

Metoda +_collection_.create+ zwraca nowy obiekt wiązanego typu. Te obiekty będą konstruowane na podstawie podanych atrybutów. Połączenie poprzez ich klucz obcy zostanie stworzone, a powiązane obiekty _zostaną_ zapisane (zakładając że przejdą przez wszystkie walidacje)

[source, ruby]
-------------------------------------------------------
@order = @customer.orders.create({:order_date => Time.now, :order_number => "A12345"})
-------------------------------------------------------

==== Opcje dla has_many

W wielu sytuacjach możesz użyć domyślnych ustawień asocjacji +has_many+ bez potrzeby jej dostosowywania. Pamiętaj jednak, że możesz zmieniać domyślne ustawienia według swoich potrzeb. Ten rozdział przedstawi ci opcje, których możesz używać kiedy zadeklarujesz asocjację +has_many+. Na przykład asocjacja z kilkoma opcjami może wyglądać tak:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :dependent => :delete_all, :validate => :false
end
-------------------------------------------------------

Asocjacja +has_many+ wspiera następujące opcje: 

// * +:accessible+
* +:as+
* +:class_name+
* +:conditions+
* +:counter_sql+
* +:dependent+
* +:extend+
* +:finder_sql+
* +:foreign_key+
* +:group+
* +:include+
* +:limit+
* +:offset+
* +:order+
* +:primary_key+
* +:readonly+
* +:select+
* +:source+
* +:source_type+
* +:through+
* +:uniq+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:as+

Użycie opcji +:as+ wskazuje, że mamy do czynienia z asocjacją polimorficzną. Polimorficzne asocjacje zostały omówione we wcześniejszej części podręcznika.

===== +:class_name+

Jeśli nazwa wiązanego modelu nie może zostać utworzona z nazwy asocjacji, możesz użyć opcji +:class-name+, by dostarczyć własną nazwę modelu. Na przykład jeśli klient ma wiele zamówień, ale aktualna nazwa modelu zawierającego zamówienia to "Transaction", możesz to ustawić w ten sposób:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :class_name => "Transaction"
end
-------------------------------------------------------

===== +:conditions+

Opcja :conditions pozwala określić warunki, jakie wiązany obiekt musi spełniać (W składni SQL użyłbyś klauzuli WHERE).

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :confirmed_orders, :class_name => "Order", :conditions => "confirmed = 1"
end
-------------------------------------------------------

możesz także określać warunki używając hash-a:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :confirmed_orders, :class_name => "Order", :conditions => { :confirmed => true }
end
-------------------------------------------------------

Jeżeli użyjesz opcji +:conditions+ (w notacji z hashem), tworzenie rekordów przez tą asocjację zostanie zautomatyzowane według zawartości hasha. W tym przypadku, używając +@customer.confirmed_orders.create+ albo +@customer.confirmed_orders.build+, tworzy się zamówienia tam, gdzie kolumna confirmed ma wartość +true+.

===== +:counter_sql+

Zwykle Railsy automatycznie tworzą odpowiednie zapytanie SQL do liczenia uczestników asocjacji. Z opcją +:counter_sql+ możesz zdefiniować własne zapytanie sql do policzenia ich.

NOTE: Jeśli określisz +:finder_sql+l, ale nie stworzysz+:counter_sql+ , wtedy funkcja licząca sql +SELECT COUNT(*) FROM+ zostanie zastąpiona klauzulą +SELECT ... FROM+, wykorzystującą deklaracje z +:finder_sql+.

===== +:dependent+

Jeśli ustawisz opcję +:dependent+ na +:destroy+, wtedy usunięcie tego obiektu wywoła metodę +:destroy+ dla obiektów powiązanych, żeby je usunąć. Jeśli ustawisz opcję +:dependent+ na +:delete_all+, wtedy usunięcie tego obiektu usunie obiekty powiązane bez wywoływania ich metody +:destroy+. Jeśli ustawisz opcję +:dependent+ na +:nullify+, wtedy usunięcie tego obiektu ustawi klucz obcy w powiązanych obiektach na NULL.

NOTE: Ta opcja jest ignorowana, jeśli używasz w asocjacji opcji +:through+.

===== +:extend+

Opcja +:extend+ sprawia, że nazwany moduł rozszerza proxy asocjacji. Rozszerzenia asocjacji są opisane dalej w tym podręczniku.

===== +:finder_sql+

Zwykle Railsy automatycznie tworzą odpowiednie zapytanie SQL do pobrania _uczestników_ asocjacji. Z opcją +:finder_sql+ możesz zdefiniować takie zapytanie samodzielnie. Jeśli pobieranie obiektów wymaga wielu skomplikowanych operacji na wielu tabelach, może to być konieczne.

===== +:foreign_key+

Zgodnie z konwencją, Railsy "domyślają się", że kolumna używana do przechowywania klucza obcego w innym modelu to nazwa pierwszego modelu z przyrostkiem +_id+. Opcja F+:foreign_key+ umożliwia ustawienie nazwy klucza obcego bezpośrednio:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :foreign_key => "cust_id"
end
-------------------------------------------------------

TIP: W żadnym z wypadków Railsy nie będą same tworzyły dla ciebie kolumn klucza obcego. Musisz zdefiniować teklucze w swoich migracjach.

===== +:group+

Opcja +:group+ dostarcza nazwę atrybutu według której wyniki mają być pogrupowane, W SQL użyłbyś klauzuli +GROUP BY+.

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :line_items, :through => :orders, :group => "orders.id"
end
-------------------------------------------------------

===== +:include+

Możesz użyć opcji +:include+ do podania drugorzędnych asocjacji, które zostaną załadowane wtedy, gdy zostanie użyta dana asocjacja. Na przykład, rozważmy takie modele:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class LineItem < ActiveRecord::Base
  belongs_to :order
end
-------------------------------------------------------

Jeśli często pobierasz pojedyncze pozycje zamówień bezpośrednio od klientów (+@customer.orders.line_items+), możesz sprawić, by wój kod był wydajniejszy, załączając pozycje w zamówieniu w asocjacji z zamówieniami do klientów:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :include => :line_items
end
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
class LineItem < ActiveRecord::Base
  belongs_to :order
end
-------------------------------------------------------

===== +:limit+

Opcja +:limit+  pozwala ograniczyć liczbę obiektów, które będą pobierane dzięki asocjacji.

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :recent_orders, :class_name => "Order", :order => "order_date DESC", :limit => 100
end
-------------------------------------------------------

===== +:offset+

Opcja +:offset+ pozwala zdefiniować _offset_ dla obiektów pobieranych w asocjacji. Na przykład, jeśli ustawisz +:offset => 11+, zostanie pominiętych pierwszych 11 rekordów (por. z klauzulą SQL +LIMIT 0,1+. Offset jest tą pierwszą liczbą – przyp.tłum)

===== +:order+

Opcja +:order+ ustawia porządek w jakim powiązane obiekty będą "wyciągane" (w składni SQL użyłbyś klauzuli +ORDER BY+).

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :order => "date_confirmed DESC"
end
-------------------------------------------------------

===== +:primary_key+

Zgodnie zkonwencją Railsy "domyślają się" że kolumna z kluczem podstawowym w modelu to "id". Możesz to zmienić i samodzielnie okreslić klucz postawowy dzieki opcji +:primary_key+

===== +:readonly+

Jeśli ustawisz +true+ dla opcji +:readonly+, asocjowany obiekt będzie tylko do odczytu, gdy wywoływana jest asocjacja.

===== +:select+

Użyj opcji : select by zastąpić klauzulę SQL +SELECT+, która służy do wyszukiwania danych w wiązanym obiekcie. Domyślnie Railsy pobierają wszystkie kolumny.

Jeśli określisz opcję +:select+, musisz być pewien, że zawarłeś w nim kolumnę klucza podstawowego (lub klucza obcego) asocjowanego modelu. Jeśli tego nie zrobisz, możesz spowodować błąd Railsów.

===== +:source+

Opcja source określa źródło asocjacji dla asocjacji typu  +has_many :through+. Tylko wtedy potrzebujesz korzystać z tej opcji, kiedy nazwa źródła asocjacji nie może być automatycznie wygenerowana (stworzona) z nazwy asocjacji.

===== +:source_type+

Opcja +:source_type+ określa typ źródła asocjacji dla asocjacji +has_one :through+; związane jest to z asocjacją polimorficzną.

===== +:through+

Opcja +:through+  określa model, za pośrednictwem którego wykonywane są zapytania. Asocjacje +has_many :through+ umożliwiają implementację relacji wiele-do-wiele jak to opisano wcześniej w tej instrukcji.

===== +:uniq+

Ustaw opcję  +:uniq => true+ aby usunąć ze zbiorów duplikaty. Ta opcja jest najbardziej użyteczna w połączeniu z opcją +:through+.

===== +:validate+

Kiedy ustawisz na +false+ opcję +:validate+, wiązane obiekty nie będą nidy walidowane, kiedy będziesz zapisywać obiekt. Domyślne ustawienie to +true+: wiązane obiekty są walidowane kiedy je zapisujesz.

==== Kiedy obiekty są zapisywane?

Kiedy przypisujesz obiekt do asocjacji +has_many+ , obiekt jest automatycznie zapisywani (żeby zaktualizować jego klucz obcy). Jeśli wiążesz wiele obiektów wjednym zapytanie, wszystkie zostaną zapisane.

Jeśli którykolwiek z tych zapisów nie powiedzie się z winy błędu walidacji, wtedy rozkaz przypisania zwróci false, a samo przypisanie jest anulowane.

Jeśli obiekt-rodzic (ten, w którym jest deklaracja +has_many+) nie został zapisany (czyli +new_record?+ zwróci +true+), wtedy dodane obiekty-dzieci również nie zostaną zapisane. Wszyscy niezapisani uczestnicy asocjacji będą automatycznie zapisani, kiedy rodzic zostanie zapisany.

Jeśli chcesz przypisać obiekt do asocjacji +has_many+ bez jego zapisywania, użyj metody +_collection_.build+

=== Asocjacja +has_and_belongs_to_many+

Asocjacja +has_and_belongs_to_many+ tworzy relację wiele-do-wiele z innym modelem. W języku baz danych wiąże się się dwie klasy poprzez załączenie pośredniej tabeli, która zawiera klucze obce odnoszące się do każdej z klas.

==== Methods Added

Kiedy zadeklarujesz asocjację +has_and_belongs_to_many+, zyskujesz automatycznie 13 metod  powiązanych z tą asocjacją:

* +_collection_(force_reload = false)+
* +_collection_<<(object, ...)+
* +_collection_.delete(object, ...)+
* +_collection_=objects+
* +_collection\_singular_\_ids+
* +_collection\_singular_\_ids=ids+
* +_collection_.clear+
* +_collection_.empty?+
* +_collection_.size+
* +_collection_.find(...)+
* +_collection_.exist?(...)+
* +_collection_.build(attributes = {})+
* +_collection_.create(attributes = {})+

We wszystkich wymienionych metodach  +_collection_+ zastępuje się symbolem przekazanym jako pierwszy argument do has_many, a także +_collection_\_singular+ zastępuje się nazwą tegoż symbolu w liczbie pojedynczej (w języku angielskim). Na przykład, w takiej deklaracji:

[source, ruby]
-------------------------------------------------------
class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

Każda instancja modelu _part_ będzie posiadała poniższe metody

[source, ruby]
-------------------------------------------------------
assemblies(force_reload = false)
assemblies<<(object, ...)
assemblies.delete(object, ...)
assemblies=objects
assembly_ids
assembly_ids=ids
assemblies.clear
assemblies.empty?
assemblies.size
assemblies.find(...)
assemblies.exist?(...)
assemblies.build(attributes = {}, ...)
assemblies.create(attributes = {})
-------------------------------------------------------

===== Metody dla dodatkowych kolumn

Jeżeli dołączana do asocjacji +has_and_belongs_to_many+ posiada dodatkowe kolumny poza dwoma kluczami obcymi, kolumny te powinny zostać dodane jako atrybuty do rekordów pobieranych za pomocą tej asocjacji. Rekordy zwrócone z dodatkowymi atrybutami będą zawsze tylko do odczytu, ponieważ Railsy nie potrafią zapisywać zmian dla tych atrybutów

WARNING: Użycie dodatkowych atrybutów w dołączanej tabeli w asocjacji +has_and_belongs_to_many+ jest dawną tendencją i nie wspiera się jej. Jeśli potrzebujesz tego rodzaju skomplikowanych zachowań w tabeli łączącej dwa modele w relacji wiele-do-wiele, powinieneś użyć asocjacji +has_many :through+ zamiast +has_and_belongs_to_many+.

===== +_collection_(force_reload = false)+

Metoda +_collection_+ zwraca tablicę [_array_] wszystkich wiązanych obiektów. Jeśli nie istnieją żadne wiązane obiekty, zwraca pustą tablicę.

[source, ruby]
-------------------------------------------------------
@assemblies = @part.assemblies
-------------------------------------------------------

===== +_collection_<<(object, ...)+

Metoda +_collection_<<+ dodaje jeden lub więcej obiektów do zbioru poprzez dodanie rekordów w tabeli łączącej (pośredniej).

[source, ruby]
-------------------------------------------------------
@part.assemblies << @assembly1
-------------------------------------------------------

NOTE: Ta metoda jest aliasowana przez +_collection_.concat+ i +_collection_.push+.

===== +_collection_.delete(object, ...)+

Metoda +_collection_.delete+ usuwa jeden lub więcej obiektów ze zbioru, poprzez usunięcie rekordów z tabeli łączącej. Ta metoda nie usuwa żadnych innych obiektów poza tymi z tabeli łączącej.

[source, ruby]
-------------------------------------------------------
@part.assemblies.delete(@assembly1)
-------------------------------------------------------

===== +_collection_=objects+

Metoda +_collection_=+ usuwa i dodaje odpowiednie obiekty tak, żeby dana kolekcja zawierała tylko podane (wymienione) obiekty.

===== +_collection\_singular_\_ids+

#  Zwraca tablicę zawierającą identyfikatory wiązanych obiektów.

+_collection\_singular_\_ids+ zwraca tablicę identyfikatorów (_ids_) obiektów w zbiorze

[source, ruby]
-------------------------------------------------------
@assembly_ids = @part.assembly_ids
-------------------------------------------------------

===== +_collection\_singular_\_ids=ids+

Metoda +__collection\_singular_\_ids=+ sprawia, że w zbiorze znajdują się tylko te obiekty, których wartość podstawowego klucza równa jest wartościom dostarczonym do metody.
 
===== +_collection_.clear+

Metoda +_collection_.clear+ usuwa wszystkie elementy zbioru poprzez usunięcie wierszy z dołączanej tabeli. Nie niszczy to żadnych wiązanych obiektów. 

===== +_collection_.empty?+

Metoda +_collection_.empty?+ zwraca wartośc +true+, jeśli zbiór nie posiada żadnych związanych obiektów.

[source, ruby]
-------------------------------------------------------
<% if @part.assemblies.empty? %>
  Ta część nie została użyta w żadnym zbiorze
<% end %>
-------------------------------------------------------

===== +_collection_.size+

Metoda +_collection_.size+ zwraca liczbę obiektów w zbiorze.

[source, ruby]
-------------------------------------------------------
@assembly_count = @part.assemblies.size
-------------------------------------------------------

===== +_collection_.find(...)+

Metoda +_collection_.find+ służy do wyszukiwania obiektów w zbiorze. Korzysta ona z tej samej składni i tych samych opcji, co ActiveRecord::Base.find. To także daje nam warunek konieczności istnienia obiektu w zbiorze
 
[source, ruby]
-------------------------------------------------------
@new_assemblies = @part.assemblies.find(:all, :conditions => ["created_at > ?", 2.days.ago])
-------------------------------------------------------

===== +_collection_.exist?(...)+

Metoda collection.exist? sprawdza, czy obiekt spełniający podane warunki istnieje w danym zbiorze. Metoda ta używa takiej samej składni i takich samych opcji jak +ActiveRecord::Base.exists?+.

===== +_collection_.build(attributes = {})+

Metoda +_collection_.build+ zwraca jeden lub więcej nowych obiektów wiązanego typu. Obiekty te będą konstruowane na podstawie podanych atrybutów. Połączenie poprzez ich klucz obcy zostanie stworzone, ale powiązane obiekty _nie_ będą zapisane.

[source, ruby]
-------------------------------------------------------
@assembly = @part.assemblies.build({:assembly_name => "Transmission housing"})
-------------------------------------------------------

===== +_collection_.create(attributes = {})+

Metoda collection.create zwraca nowy obiekt wiązanego typu. Ten obiekt będzie konstruowany z ustawionych atrybutów. Powiązanie z pośrednią tabelą będzie stworzone, a wiązany obiekt _zostanie_ zapisany (jeśli przejdzie pomyślnie przez walidację).

[source, ruby]
-------------------------------------------------------
@assembly = @part.assemblies.create({:assembly_name => "Transmission housing"})
-------------------------------------------------------

==== Opcje dla +has_and_belongs_to_many+

W wielu sytuacjach możesz użyć asocjacji +has_and_belongs_to_many+ bez potrzeby jej dostosowywania. Ale możesz też zmieniać domyślne ustawienia na kilka sposobów. Ten rozdział przedstawi ci opcje, których możesz używać, kiedy zadeklarujesz asocjację +has_and_belongs_to_many+. Na przykład asocjacja z kilkoma opcjami może wyglądać tak:

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :uniq => true, :read_only => true
end
-------------------------------------------------------

Asocjacja +has_and_belongs_to_many+ wspiera takie opcje: 

// * +:accessible+
* +:association_foreign_key+
* +:class_name+
* +:conditions+
* +:counter_sql+
* +:delete_sql+
* +:extend+
* +:finder_sql+
* +:foreign_key+
* +:group+
* +:include+
* +:insert_sql+
* +:join_table+
* +:limit+
* +:offset+
* +:order+
* +:readonly+
* +:select+
* +:uniq+
* +:validate+

// ===== +:accessible+
//
// The +:accessible+ option is the association version of +ActiveRecord::Base#attr_accessible+. If you set the +:accessible+ option to true, then mass // assignment is allowed for this association.
//
===== +:association_foreign_key+

Zgodnie z konwencją Railsy "domyślają się", że kolumna w tabeli łączącej, używana do przechowywania klucza obcego wskazującego na inny model to nazwa tego modelu z przyrostkiem +_id+. Opcja +:association_foreign_key+ pozwala Ci ustawić nazwę obcego klucza bezpośrednio.

TIP: Opcje +:foreign_key+ oraz +:association_foreign_key+ są przydatne gdy ustawiasz samodniesienie się tabeli (odwołanie rekurencyjne) dla typu relacji wiele-do wiele. Na przykład:

[source, ruby]
-------------------------------------------------------
class User < ActiveRecord::Base
  has_and_belongs_to_many :friends, :class_name => "User", 
    :foreign_key => "this_user_id", :association_foreign_key => "other_user_id"
end
-------------------------------------------------------

===== +:class_name+

Jeśli nazwa innego modelu nie może zostać utworzona z nazwy asocjacji, możesz użyć opcji +:class-name+, by dostarczyć nazwę modelu. Na przykład jeśli _part_ (część) ma wiele _assemblies_ (zadań), ale aktualna nazwa zawierająca _assemblies_ to "Gadget", możesz to ustawić w ten sposób:

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :class_name => "Gadget"
end
-------------------------------------------------------

===== +:conditions+

Opcja +:conditions+ pozwala określić warunki, jakie wiązany obiekt musi spełniać (W składni SQL użyłbyś klauzuli WHERE).

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :conditions => "factory = 'Seattle'"
end
-------------------------------------------------------

Możesz także określać warunki używając hash-a:

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :conditions => { :factory => 'Seattle' }
end
-------------------------------------------------------

Jeżeli użyjesz opcji +:conditions+ (w notacji z hashem), tworzenie rekordów przez tą asocjację zostanie zautomatyzowane według zawartości hasha. W tym przypadku, używając +@parts.assemblies.create+ lub +@parts.assemblies.build+, tworzy się zamówienia tam, gdzie kolumna factory ma wartość "Seattle".

===== +:counter_sql+

Zwykle Railsy automatycznie tworzą odpowiednie zapytanie SQL do liczenia uczestników asocjacji. Z opcją +:counter_sql+ możesz zdefiniować własne zapytanie sql do policzenia ich.

NOTE: Jeśli określisz +:finder_sql+, ale nie stworzysz +:counter_sql+, wtedy funkcja licząca sql +SELECT COUNT(*) FROM+ zostanie zastąpiona klauzulą +SELECT ... FROM+, wykorzystującą deklaracje z +:finder_sql+.
 

===== +:delete_sql+

Zwykle Railsy automatycznie generują właściwe zapytanie SQL w celu usunięcia związków pomiędzy związanymi klasami. Dzięki opcji delete_sql możesz zdefiniować własne zapytanie SQL by usunąć je samodzielnie.

===== +:extend+

Opcja +:extend+ sprawia, że nazwany moduł rozszerza proxy asocjacji. Rozszerzenia asocjacji są opisane dalej w tym podręczniku.

===== +:finder_sql+

Zwykle Railsy automatycznie tworzą odpowiednie zapytanie SQL do pobrania _uczestników_ asocjacji. Z opcją +:finder_sql+ możesz zdefiniować takie zapytanie samodzielnie. Jeśli pobieranie obiektów wymaga wielu skomplikowanych operacji na wielu tabelach, może to być konieczne.

===== +:foreign_key+

Zgodnie z konwencją, Railsy "domyślają się", że kolumna używana do przechowywania klucza obcego w innym modelu to nazwa pierwszego modelu z przyrostkiem +_id+. Opcja +:foreign_key+ umożliwia ustawienie nazwy klucza obcego bezpośrednio:

[source, ruby]
-------------------------------------------------------
class User < ActiveRecord::Base
  has_and_belongs_to_many :friends, :class_name => "User", 
    :foreign_key => "this_user_id", :association_foreign_key => "other_user_id"
end
-------------------------------------------------------

===== +:group+

Opcja +:group+ dostarcza nazwę atrybutu według której wyniki mają być pogrupowane, W SQL użyłbyś klauzuli +GROUP BY+.
 
[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :group => "factory"
end
-------------------------------------------------------

===== +:include+

Możesz użyć opcji +:include+ do podania drugorzędnych asocjacji, które zostaną załadowane wtedy, gdy zostanie użyta dana asocjacja.

===== +:insert_sql+

Zwykle Railsy generują automatycznie odpowiednie zapytanie SQL do stworzenia powiązania między asocjowanymi klasami. Jednak z opcją +:insert_sql+ możesz sam określić kompletne zapytanie SQL do tworzenia klas.

===== +:join_table+

Jeśli domyślna nazwa tabeli łączącej utworzona w oparciu o porządek alfabetyczny nie jest tym, czego oczekujesz, możesz uzyć opcji +:join_table+ by nadpisać domyślne ustawienia

===== +:limit+

Opcja +:limit+  pozwala ograniczyć liczbę obiektów, które będą pobierane dzięki asocjacji.

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :order => "created_at DESC", :limit => 50
end
-------------------------------------------------------

===== +:offset+

Opcja +:offset+ pozwala zdefiniować _offset_ dla obiektów pobieranych w asocjacji. Na przykład, jeśli ustawisz +:offset => 11+, zostanie pominiętych pierwszych 11 rekordów (por. z klauzulą SQL +LIMIT 0,1+. Offset jest tą pierwszą liczbą – przyp.tłum)

===== +:order+

Opcja +:order+ ustawia porządek w jakim powiązane obiekty będą "wyciągane" (w składni SQL użyłbyś klauzuli +ORDER BY+).

[source, ruby]
-------------------------------------------------------
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, :order => "assembly_name ASC"
end
-------------------------------------------------------

===== +:readonly+

Jeśli ustawisz +true+ dla opcji +:readonly+, asocjowane obiekty będą tylko do odczytu, gdy wywoływana jest asocjacja.

===== +:select+

Użyj opcji : select by zastąpić klauzulę SQL +SELECT+, która służy do wyszukiwania danych w wiązanym obiekcie. Domyślnie Railsy pobierają wszystkie kolumny

===== +:uniq+

Ustaw opcję +:uniq => true+ aby usunąć ze zbiorów duplikaty.
 
===== +:validate+

Kiedy ustawisz na +false+ opcję +:validate+, wiązane obiekty nie będą nidy walidowane, kiedy będziesz zapisywać obiekt. Domyślne ustawienie to +true+: wiązane obiekty są walidowane kiedy je zapisujesz.

==== Kiedy obiekty są zapisywane?

Kiedy przypisujesz obiekt do asocjacji +has_and_belongs_to_many+, obiekt jest automatycznie zapisywany (żeby zaktualizować tabelę wiążącą). Jeśli wiążesz wiele obiektów w jednym zapytanie, wszystkie zostaną zapisane.

Jeśli którykolwiek z tych zapisów nie powiedzie się z winy błędu walidacji, wtedy rozkaz przypisania zwróci +false+, a samo przypisanie będzie anulowane.

Jeśli obiekt-rodzic (ten, w którym jest deklaracja +has_and_belongs_to_many+) nie został zapisany (czyli +new_record?+ zwróci +true+), wtedy dodane obiekty-dzieci również nie zostaną zapisane. Wszyscy niezapisani uczestnicy asocjacji będą automatycznie zapisani, kiedy rodzic zostanie zapisany.

Jeśli chcesz przypisać obiekt do asocjacji +has_many+ bez jego zapisywania, użyj metody +_collection_.build+.
 
=== Callback asocjacji

Funkcje z callback-iem "zaczepiają się" o cykl życia obiektów Active Record, pozwalając na pracę z tymi obiektami w różnych momentach. Na przykład, możesz użyć callback-a +:before_save+ i sprawić, by coś się stało tuż przed tym, kiedy obiekt zostanie zapisany.

Callback-i w asocjacjach podobne są do zwykłych callback-ów, z tym, że (te pierwsze - przyp.tłum) uruchamiane są przez zdarzenia w cyklu życia zbioru. W asocjacjach dostępne są cztery callback-i:

* +before_add+
* +after_add+
* +before_remove+
* +after_remove+

Callback asocjacji definiuje się dodając opcje do deklaracji asocjacji. Na przykład:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :before_add => :check_credit_limit

  def check_credit_limit(order)
    ...
  end
end
-------------------------------------------------------

Railsy przekazują do callback-a obiekt, który ma być dodany lub wymazany. 

Możesz użyć stosu [_stack_] wywołań, które będą traktowane jak pojedynczy callback, przekazując wywołania do w tablicy:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :before_add => [:check_credit_limit, :calculate_shipping_charges]

  def check_credit_limit(order)
    ...
  end

  def calculate_shipping_charges(order)
    ...
  end
end
-------------------------------------------------------

Jeśli callback +before_add+ "wyrzuci" wyjątek, obiekt nie może zostać dodany do zbioru. Podobnie jeśli +before_remove+ "wyrzuci" wyjątek, nie można obiektu usunąć ze zbioru.

=== Rozszerzenia asocjacji

Nie jesteś ograniczony do funkcjonalności, którą Railsy automatycznie wbudowuje w obiekty proxy. Możesz rozszerzać te obiekty używając anonimowych modułów, dodawanie nowych finderów, kreatorów i innych metod. Na przykład:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders do
    def find_by_order_prefix(order_number)
      find_by_region_id(order_number[0..2])
    end
  end
end
-------------------------------------------------------

Jeśli posiadasz rozszerzenia, które powinny zostać udostępnione dla wielu asocjacji, możesz użyć modułu o nazwie _extension_ (rozszerzenie). Na przykład:

[source, ruby]
-------------------------------------------------------
module FindRecentExtension
  def find_recent
    find(:all, :conditions => ["created_at > ?", 5.days.ago])
  end
end

class Customer < ActiveRecord::Base
  has_many :orders, :extend => FindRecentExtension
end

class Supplier < ActiveRecord::Base
  has_many :deliveries, :extend => FindRecentExtension
end
-------------------------------------------------------

By załączyć więcej niż jeden moduł rozszerzeń w jednej asocjacji, użyj tablicy nazw:

[source, ruby]
-------------------------------------------------------
class Customer < ActiveRecord::Base
  has_many :orders, :extend => [FindRecentExtension, FindActiveExtension]
end
-------------------------------------------------------

Rozszerzenia mogą odnosić się do wnętrz asocjacji proxy, dzięki użyciu tych trzech dodatków [_accessors_]:

* +proxy_owner+ zwraca obiekt, którego asocjacja jest częścią.
* +proxy_reflection+ zwraca ‘odbicie’ obiektu opisywanego przez asocjację.
* +proxy_target+ zwraca powiązany element dla +belongs_to+ lub +has_one+ lub zbiór wiązanych obiektów dla +has_many+ lub +has_and_belongs_to_many+.

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/11[Lighthouse ticket]

* February 11, 2009, Initial version of polish translation.
* September 28, 2008: Corrected +has_many :through+ diagram, added polymorphic diagram, some reorganization by link:../authors.html#mgunderloy[Mike Gunderloy] . First release version.
* September 22, 2008: Added diagrams, misc. cleanup by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* September 14, 2008: initial version by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)

