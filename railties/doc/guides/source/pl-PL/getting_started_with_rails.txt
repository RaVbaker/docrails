Zaczynamy z Ruby on Rails
=========================

Ten przewodnik jest wprowadzeniem do Ruby on Rails. Po jego przeczytaniu będziesz zaznajomiony z:

* instalowaniem Railsów, tworzeniem nowej aplikacji oraz zestawianiem połączenia z bazę danych
* ogólnym układem aplikacji
* podstawami wzorca MVC (Model, View, Controller) oraz architektury RESTful
* szybkim generowaniem podstawowych elementów aplikacji

== Co obejmuje przewodnik?

Ten przewodnik jest przeznaczony dla początkujących, którzy chcą rozpocząć
tworzenie aplikacji opartych na Railsach. Nie zakłada, że masz wcześniejsze
doświadczenia z Railsami. Niemniej jednak, do najlepszego wykorzystania
tego przewodnika, konieczna jest instalacja:

* języka link:http://www.ruby-lang.org/en/downloads/[Ruby]
* link:http://rubyforge.org/frs/?group_id=126[RubyGems] - narzędzie do dystrybuowania i instalowania paczek zawierających moduły i rozszerzenia języka Ruby
* systemu zarządzania bazą danych link:http://www.sqlite.org/[SQLite] (preferowane), link:http://www.mysql.com/[MySQL] lub link:http://www.postgresql.org/[PostgreSQL]

Zdecydowanie zaleca się zapoznanie z językiem Ruby przed rozpoczęciem przygody z Railsami. Znacznie łatwiej jest śledzić, co się dzieje w Railsach, rozumiejąc podstawowy składni Ruby. Railsy nie będą w stanie w magiczny sposób zrewolucjonizować sztuki pisania aplikacji internetowych, jeżeli nie masz doświadczenia w używaniu języka. W Internecie istnieje kilka dobrych darmowych źródeł pomocnych w nauce języka Ruby, w tym:

* link:http://www.humblelittlerubybook.com/[Mr. Neigborly's Humble Little Ruby Book]
* link:http://www.rubycentral.com/book/[Programming Ruby]
* link:http://poignantguide.net/ruby/[Why's (Poignant) Guide to Ruby]
* link:http://www.apohllo.pl/dydaktyka/ruby/intro/[Wprowadzenie do języka Ruby (po polsku)]

== Co to są Railsy?

Railsy są frameworkiem służącym do tworzenia aplikacji internetowych napisanym w języku
Ruby. Zostały one tak zaprojektowane, aby ułatwić programowanie aplikacji internetowych,
poprzez przyjęcie kilku założeń, dotyczących tego czego potrzebuje każdy
programista aby rozpocząć pracę. Pozwalają one na
pisanie krótszego kodu, jednocześnie umożliwiając osiąganie lepszych rezultatów niż 
ma to miejsce w większości innych języków i
frameworków. Poza tym, programiści którzy od dawna używają Railsów uważają, że
pisanie aplikacji z ich użyciem sprawia przyjemność.

Railsy są "upartym" oprogramowaniem. Oznacza to, że były tworzone z
przekonaniem, że istnieje najlepszy sposób rozwiązywania pewnych problemów i
zostały zaprojektowane tak, by zachęcać do wyboru tego sposobu, a w niektórych przypadkach -  
by zniechęcić do wyboru alternatywy. Jeśli nauczysz się "The Rails Way", odkryjesz
ogromny wzrost produktywności. Jednak jeżeli podczas pracy z Railsami pozostaniesz przy
nawykach charakterystycznych dla programowania w innych językach lub będziesz
wykorzystywać wzorce, których już kiedyś się nauczyłeś, efekty mogą nie być aż tak pomyślne. 

Filozofia Railsów obejmuje kilka zasad:

* DRY - "Don't Repeat Yourself" (Nie powtarzaj się) - sugeruje, że pisanie w
  kółko tego samego kodu jest złe.
* Konwencja Ponad Konfiguracją - Railsy przyjmują pewne założenia, odnośnie tego,
  co i jak zamierzasz zrobić, dlatego nie zmuszają Cię do samodzielnego ustawiania 
  każdej najdrobniejszej opcji w plikach konfiguracyjnych.
* REST jest najlepszym wzorcem dla aplikacji internetowych - organizowanie aplikacji wokół zasobów i 
  standardowych zapytań HTTP pozwala szybko kroczyć do przodu.

=== Architektura MVC 

Railsy są zorganizowane wokół trzech warstw aplikacji: 
modelu (_model_), widoku (_view_) oraz kontrolera (_controller_), co w skrócie nazywamy MVC. Wzorzec MVC obejmuje: 

* odizolowanie logiki biznesowej od interfejsu użytkownika 
* łatwość utrzymania kodu zgodnie z zasadą DRY 
* wyraźne wskazanie, gdzie powinny znajdować się różne elementy kodu, co
  ułatwia zarządzenie nim 

==== Modele

Model reprezentuje dane aplikacji i reguły do manipulowania tymi danymi. W przypadku
Railsów, modele są głównie wykorzystywane do zarządzania zasadami interakcji z
odpowiednią tabelą bazy danych. W większości przypadków jednej tabeli bazy danych
odpowiada jeden model w Twojej aplikacji. Większość logiki biznesowej Twoich aplikacji 
będzie skoncentrowana w modelach.

==== Widoki

Widoki tworzą interfejs użytkownika aplikacji. W Railsach, widoki są często plikami HTML
zawierającymi kod w języku Ruby, wykonujący zadania związane wyłącznie z prezentacją
danych. Przede wszystkim są one odpowiedzialne za dostarczanie danych do przeglądarki
internetowej lub innego narzędzia, które jest używane do oglądania efektów działania Twojej aplikacji.

==== Kontrolery 

Kontrolery "sklejają" modele i widoki. W Railsach odpowiadają za przetwarzanie żądań
przychodzących z przeglądarki internetowej, pozyskiwanie danych z modeli i przekazywanie
ich do widoków w celu prezentacji.

=== Składniki Railsów

Railsy dostarczają pełny zestaw komponentów do tworzenia aplikacji internetowych. Są to: 

* Action Controller
* Action View
* Active Record
* Action Mailer
* Active Resource
* Railties
* Active Support

==== Action Controller

Moduł Action Controller jest komponentem zarządzającym kontrolerami w Railsowej aplikacji.
Action Controller przetwarza przychodzące zapytania, wydobywa z
nich parametry i wysyła je do odpowiedniej akcji. Usługi świadczone przez Action
Controller obejmują zarządzanie sesją, renderowanie szablonów i zarządzanie
przekierowaniami.

==== Action View

Moduł Action View zarządza widokami Twojej Railsowej aplikacji. Może domyślnie tworzyć zarówno
widok HTML jak i XML. Action View zarządza renderowaniem szablonów (w tym szablonami
zagnieżdżonymi oraz podszablonami) i dostarcza wsparcie dla AJAXa.

==== Active Record

Moduł Active Record jest podstawą dla modeli w Railsowej aplikacji. Zapewnia
niezależność od bazy danych, dostarcza podstawowe funkcjonalności CRUD (create, read, update and
delete - utwórz, odczytaj, aktualizuj, usuń), zaawansowane możliwości
wyszukiwania i zdolność do wiązania modeli oraz wiele innych usług.

==== Action Mailer

Moduł Action Mailer służ do tworzenia usług e-mail. Action Mailer może być używany do
wysyłania e-maili w oparciu o elastyczne szablony lub do odbioru i przetwarzania przychodzących wiadomości.

==== Active Resource

Moduł Active Resource pozwala na zarządzanie powiązaniami pomiędzy obiektami
biznesowymi oraz internetowymi serwisami RESTful. Implementuje mapowanie
zasobów internetowych na obiekty lokalne w oparciu o semantykę CRUD.

==== Railties

Moduł Railties jest rdzeniem kodu Rails, służącym do tworzenia nowych aplikacje i 
łączenia w nich poszczególnych elementów frameworku.

==== Active Support

Moduł Active Support jest obszernym zbiorem użytecznych klas oraz rozszerzeń 
standardowych bibliotek języka Ruby, które są wykorzystywane w Railsach, 
zarówno przez rdzeń kodu, jak i Twoją aplikację.

=== REST

Praca doktorska Roya Fieldinga 
link:http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm[Architectural Styles and the Design of Network-based Software Architectures] 
jest powszechnie uznawana za fundament architektury RESTful. Na
szczęście, nie musisz czytać tego dokumentu w całości, aby zrozumieć, jak działa REST w Rails. 
REST (Representational State Transfer) jest stylem architektury oprogramowania 
sprowadzającym się do dwóch podstawowych zasad: 

* Korzystanie z identyfikatorów zasobów (które na potrzeby tego przewodnika
  możesz traktować jako adresy URL) do reprezentowania zasobów.
* Przesyłanie reprezentacji stanu zasobów pomiędzy elementami systemu. 

Na przykład, dla aplikacja Railsowej następujące żądanie:

+DELETE /photos/17+

będzie rozumiane jako odnoszące się do zdjęcia o ID 17 oraz jako wskazanie żądanego
działania - usunięcie tego zasoby. REST jest naturalnym stylem architektury aplikacji
internetowych, które Railsy czynią jeszcze bardziej intuicyjnym, poprzez korzystanie z
konwencji, które pozwalają na nieprzejmowanie się jego złożonością oraz różnicami pomiędzy przeglądarkami.

Jeśli chciałbyś dowiedzieć się czegoś więcej na temat REST jako stylu architektonicznego,
polecam bardziej przystępne źródła od tezy Fieldinga: 

* link:http://www.infoq.com/articles/rest-introduction[Krótkie wprowadzenie do REST Stefana Tilkov] 
* link:http://bitworking.org/news/373/An-Introduction-to-REST[Wprowadzenie do REST - Joe Gregorio] (video)
* link:http://en.wikipedia.org/wiki/Representational_State_Transfer[REST - artykuł w Wikipedii] 

== Tworzenie nowego projektu w Railsach

Z pomocą tego przewodnika, będziesz mógł utworzyć projekt prostego bloga w
Railsach. Zanim przystąpisz do tworzenia aplikacji, upewnij się jednak, że masz zainstalowane Railsy.

=== Instalacja środowiska Rails 

W większości przypadków, najprostszym sposobem zainstalowania Railsów jest skorzystania z RubyGems:

[source, shell]
-------------------------------------------------------
$ gem install rails
-------------------------------------------------------

NOTE: Istnieją pewne szczególne okoliczności, w których można zastosować alternatywną strategię instalacji:

* Jeśli pracujesz w systemie Windows, będzie Ci łatwiej zainstalować
  link:http://instantrails.rubyforge.org/wiki/wiki.pl[Instant Rails]. Pamiętaj jednak, że
  Instant Rails rzadko zawierają aktualną wersją Railsów. Ponadto, Windowsowa wersja Railsów
  jest ogólnie mniej przyjazna w użytkowaniu niż te przeznaczone dla innych
  systemów operacyjnych. Jeśli to możliwe, polecamy korzystanie z Linuksowej maszyny wirtualnej. 

* Jeżeli chcesz być na bieżąco z najnowszymi zmianami w środowisku Rails, proponujemy skopiowanie kodu źródłowego z  link:http://github.com/rails/rails/tree/master[githuba], aczkolwiek nie jest to opcja zalecana dla początkujących

=== Tworzenie bloga 

Otwórz terminal i przejdź do folderu, w którym posiadasz odpowiednie uprawnienia do tworzenia plików, a następnie wpisz polecenie:

[source, shell]
-------------------------------------------------------
$ rails blog
-------------------------------------------------------

To stworzy Railsową aplikację, która korzysta z bazy danych SQLite. Jeśli wolisz korzystać z MySQL, uruchom zamiast tego polecenie:

[source, shell]
-------------------------------------------------------
$ rails blog -d mysql
-------------------------------------------------------

A jeśli używasz PostgreSQL do przechowywania danych, zastosuj polecenie:

[source, shell]
-------------------------------------------------------
$ rails blog -d postgresql
-------------------------------------------------------

NOTE: Uruchamiając +railis -h+ możesz zobaczyć wszystkie akceptowane przez aplikację Railsową przełączniki.

Po utworzeniu aplikacji, przejdź do odpowiedniego folderu, aby móc kontynuować swoją pracę:

[source, shell]
-------------------------------------------------------
$ cd blog
-------------------------------------------------------

Railsy utworzy folder o nazwie +blog+ w Twoim roboczym katalogu. Otwórz ten
folder i przyjrzyj się jego zawartości. Podczas pracy z tym przewodnikiem, w
większości będziemy korzystać z folderu +app/+, ale poniżej możesz zapoznać
się z podstawowymi funkcjami katalogów i plików, które domyślnie utworzą Railsy.

[options="header"]
|==========================================================================================================
|File/Folder |Purpose
|+README+		|Jest to krótka instrukcja dla danej aplikacji. Za jej pomocą możesz poinformować innych na przykład o tym, jak działa Twoja aplikacja i jak ją można uruchomić.
|+Rakefile+	|Plik ten zawiera listę zadań, które można uruchomić poprzez terminal.
|+app/+		|Folder zawiera kontrolery, modele i widoki dla danej aplikacji. Na tym folderze będziemy koncentrować się w dalszej części tego przewodnika.
|+config/+		|Folder zawierający pliki konfiguracyjne aplikacji, obejmujące zmienne czasu uruchomienia, konfigurację bazę danych, ścieżki dostępu etc.
|+db/+			|Pokazuje aktualny schemat bazy danych, jak również jego migracje (o których niedługo będziemy się uczyć). 
|+doc/+		|Pełna dokumentacja Twojej aplikacji.
|+lib/+		|Dodatkowe moduły dla Twojej aplikacji (nieuwzględnione w tym przewodniku).
|+log/+		|Logi aplikacji.
|+public/+		|Jedyny całkowicie dostępny publicznie folder. Zawiera wszelkie zdjęcia, JavaScript, arkusze stylów (CSS) i inne statyczne pliki.
|+script/+		|Skrypty dostarczone przez Rails w celu wykonywania powtarzających się zadań, takich jak benchmarking, instalowanie wtyczek (plugin) i uruchamianiu konsoli lub serwera WWW
|+test/+		|Testy jednostkowe, tak zwane "fixtures" oraz inne narzędzia służące do przeprowadzania testów.  Są one opisane w: link:/testing_rails_applications.html[Testowanie aplikacji Rails]
|+tmp/+		|Pliki tymczasowe
|+vendor/+		|Miejsce na kod, którego sami nie napisaliśmy, ale chcemy wykorzystać. W standardowej aplikacji Rails zawiera Ruby Gems, kod źródłowy Railsów (jeśli zainstalujesz go w swoim projekcie) i wszystkie dodatkowe wtyczki z gotowym kodem.
|==========================================================================================================

=== Konfiguracja bazy danych

Prawie każda aplikacja Railsowa korzysta z bazy danych. Rodzaj baza danych, której używamy, jest określony w pliku konfiguracyjnym +config/database.yml+.
Jeśli otworzysz ten plik w nowej aplikacji Railsowej, zostanie wyświetlona
domyślna konfiguracja bazy danych SQLite. Plik zawiera części dla trzech
różnych środowisk, w których Railsy mogą być domyślnie uruchomione: 

* środowisko +development+ (rozwojowe) jest używane na komputerze programisty, aby mógł
  oglądać bezpośrednio rezultaty wprowadzanych zmian
* środowisko +test+ (testowe) służy do uruchamiania automatycznych testów
* środowisko +production+ (produkcyjne) jest używane kiedy aplikacja uruchomiona jest na
  serwerze produkcyjnym

==== Konfiguracja bazy danych SQLite 

Railsy mają wbudowaną obsługę link:http://www.sqlite.org/[SQLite], który jest
lekkim, pozbawionym serwera systemem zarządzania bazą danych. 
Mimo możliwości przeciążenia SQLite'a w środowisku produkcyjne, działa on
zadowalająco podczas pisania programu oraz testów. Railsy domyślnie używają SQLite 
przy tworzeniu nowego projektu, ale zawsze można to zmienić.

Poniżej znajduje się część domyślnej konfiguracji pliku z informacją dla środowiska rozwojowego:

[source, ruby]
-------------------------------------------------------
development:
  adapter: sqlite3
  database: db/development.sqlite3
  timeout: 5000
-------------------------------------------------------

Jeśli nie masz żadnej zainstalowanej bazy danych, najłatwiej będzie Ci
skorzystać z SQLite'a, w czym może być pomocny Ruby Gems (posiadacze Maca z OS
X w wersji 10.5 lub nowszej mają go zainstalowanego domyślnie):

[source, shell]
-------------------------------------------------------
$ gem install sqlite3-ruby
-------------------------------------------------------

==== Konfiguracja bazy danych MySQL

Jeżeli zdecydujesz się na używanie bazy danych MySQL, Twój plik +config/database.yml+ będzie wyglądał trochę inaczej:

[source, ruby]
-------------------------------------------------------
development:
  adapter: mysql
  encoding: utf8
  database: blog_development
  username: root
  password:
  socket: /tmp/mysql.sock
-------------------------------------------------------
Ta konfiguracja powinna działac bez problemu, jeśli Twoja instalacja MySQLa nie ma wprowadzonego hasła dla super-uzytkownika (root user). Jeśli jednak jest inaczej, koniecznie zmień nazwę użytkownika oraz hasło w powyższym kodzie.

==== Konfiguracja Bazy Danych PostgreSQL

Używając PostgreSQL Twój plik +config/database.yml+ powinien zostać zmodyfikowany do pracy z tą bazą danych:

[source, ruby]
-------------------------------------------------------
development:
  adapter: postgresql
  encoding: unicode
  database: blog_development
  username: blog
  password:
-------------------------------------------------------

Konieczna jest zmiana nazwy użytkownika oraz hasła w konfiguracji środowiska
rozwojowego.

==== Tworzenie Bazy Danych

Teraz, gdy masz już skonfigurowaną bazę danych, czas by Railsy stworzyły dla ciebie pustą bazę danych. Możesz to zrobić uruchamiając komendę +rake+:

[source, shell]
-------------------------------------------------------
$ rake db:create
-------------------------------------------------------
NOTE: Rake jest poleceniem startującym ogólnego zastosowania, które Railsy
używają do wielu rzeczy. By zobaczyć listę dostępnych komend uruchom +rake -T+.

== Witajcie Railsy!

Jednym z tradycyjnych sposobów uczenia się nowego języka jest pobieżne przeglądnięcie jego tekstu. By tak zrobić w Railsach, konieczne jest stworzenie przynajmniej kontrolera oraz widoku. Na szczęście możesz to zrobić używając pojedynczej komendy, wpisując ją do terminala:

[source, shell]
-------------------------------------------------------
$ script/generate controller home index
-------------------------------------------------------

TIP: Jeżeli używasz systemu Windows lub gdy twój Ruby jest skonfigurowany w
niestandardowy sposób, możliwe że będziesz musiał przekazać komendę +script+
bezpośrednio do Ruby'ego: +ruby script/generate controller home index+.

Railsy stworzyły dla Ciebie parę plików, włączając w to +app/views/home/index.html.erb+
- czyli szablon, który będzie używany do pokazywania efektów akcji (metody) +index+ w
kontrolerze +home+. Otwórz ten plik w Twoim edytorze tekstów i dopisz do niego tę
pojedynczą linijkę kodu:


[source, html]
-------------------------------------------------------
<h1>Hello, Rails!</h1>
-------------------------------------------------------

=== Uruchamianie serwera WWW.

Teraz, za pomocą jedynie dwóch komend, masz gotowy i działający Railsowy program!
Będziesz mógł go zobaczyć uruchamiając przeglądarkę na swoim komputerze, za pomocą
kolejnej komendy startowej:

[source, shell]
-------------------------------------------------------
$ script/server
-------------------------------------------------------

Domyślnie spowoduje to odpalenie instancji serwera aplikacyjnego Mongrel
(Railsy mogą wykorzystywać kilka innych serwerów aplikacji). By zobaczyć jak działa Twój
program, otwórz okno przeglądarki i przejdź pod adres +http://localhost:3000+. Powinieneś
zobaczyć Railsową, domyślną stronę informacyjną:

image:images/rails_welcome.png[Welcome Aboard screenshot]

TIP: By zatrzymać serwer WWW naciśnij Ctrl+C w oknie terminala podczas jego działania.
Generalnie, Railsy w trybie rozwojowym nie wymagają zatrzymywania
serwera, po wprowadzeniu zmian w Twoich plikach - zostaną one automatycznie
zauważone przez serwer.

Ekran powitalny jest pierwszym testem dla nowego programu napisanego w Railsach - upewnia
nas, że oprogramowanie którym dysponujemy jest poprawnie skonfigurowane do działania 
naszej aplikacji. Aby zobaczyć nowoutworzoną stronę, przejdź pod adres +http://localhost:3000/home/index+.

=== Konfiguracja Strony Domowej Programu.

Prawdopodobnie chcesz zamienić domyślną stronę startową ze stroną Twojego programu.
Pierwszym krokiem jest wykasowanie z katalogu +public+ strony domyślnej:

[source, shell]
-------------------------------------------------------
$ rm public/index.html
-------------------------------------------------------

Powinieneś teraz wskazać Railsom gdzie jest zlokalizowana Twoja strona domowa.
Otwórz plik +config/routes.rb+ w swoim edytorze -  jest on plikiem routingu Twojego
programu. Zawiera wpisy w specjalnym DSLu (specyficzny język domeny), które pokazują
Railsom w jaki sposób połączyć żądania kontrolerów oraz akcji. Na dole tego pliku
znajdują się domyślne drogi:

[source, ruby]
-------------------------------------------------------
map.connect ':controller/:action/:id'
map.connect ':controller/:action/:id.:format'
-------------------------------------------------------

Domyślne drogi obsługują proste żądania, takie jak +/home/index+: Railsy
tłumaczą je na wywołanie akcji +index+ w kontrolerze +home+. Kolejny przykład,
+/posts/edit/1+ uruchomi akcję +edit+ w kontrolerze +posts+ z +id+ równym 1.

By połączyć Twoją stronę domową, musisz dodać jeden wpis do pliku routingu, 
powyżej drogi domyślnej:

[source, ruby]
-------------------------------------------------------
map.root :controller => "home"
-------------------------------------------------------

Ta linijka ilustruje jeden mały kawałek podejścia "konwencja ponad
konfiguracją": jeżeli nie podasz żadnej akcji, Railsy uruchomią domyślnie akcję +index+.

Po przejściu do strony +http://localhost:3000+ , zobaczysz widok +home/index+ .

NOTE: Więcej informacji na temat routingu znajdziesz w przewodniku
link:routing_outside_in.html[Routing w Railsach].

== Szybki start dzięki rusztowaniu.

Railsowe rusztowanie (_scaffolding_) jest szybkim sposobem na napisanie znacznej części
programu. Jeśli chcesz stworzyć modele, widoki i kontrolery dla nowych zasobów w
pojedynczej operacji, to jest to odpowiednie narzędzie dla Ciebie.

== Tworzenie zasobu

W przypadku programów takich jak blog, możesz zacząć od stworzenia zasobu
+Post+ z rusztowaniem, który będzie reprezentował pojedynczy wpis w blogu. Aby to zrobić,
wprowadź następującą komendę w terminalu:

[source, shell]
-------------------------------------------------------
$ script/generate scaffold Post name:string title:string content:text
-------------------------------------------------------

NOTE: Chociaż rusztowanie pozwoli Ci szybko rozpocząć pisanie programu, ten uniwersalny
kod raczej nie będzie idealnie pasować do Twojej aplikacji. W większości przypadków
będziesz musiał samodzielnie dokonać w nim zmian. Wielu doświadczonych programistów
Rails unika używania rusztowań na rzecz pisania większości kodu źródłowego od podstaw,
bez używania gotowych wzorców.

Generator rusztowania utworzy w Twoim programie 14 plików, wspólnie z paroma folderami,
i jeden dodatkowo zmodyfikuje. Oto krótki przegląd tego co tworzy powyższa
komenda:

[options="header"]
|==========================================================================================================
|File                                          |Purpose
|app/models/post.rb                            |Model dla posta
|db/migrate/20081013124235_create_posts.rb     |Migracja do tworzenia tabeli postów w Twojej bazie danych (nazwa która pojawi się u Ciebie będzie zawierała inny znacznik czasowy)
|app/views/posts/index.html.erb                |Widok indeksu wszystkich postów 
|app/views/posts/show.html.erb                 |Widok pojedynczego posta
|app/views/posts/new.html.erb                  |Widok tworzenia nowego posta
|app/views/posts/edit.html.erb                 |Widok edycji posta
|app/views/layouts/posts.html.erb              |Widok określający całościowy wygląd i działanie innych widoków dla postów
|public/stylesheets/scaffold.css               |Arkusz stylów poprawiający wygląd widoków w rusztowaniu
|app/controllers/posts_controller.rb           |Kontroler postów
|test/functional/posts_controller_test.rb      |Testy funkcjonalności dla kontrolera postów
|app/helpers/posts_helper.rb                   |Helpery używane w widokach postów
|config/routes.rb                              |Modyfikacja polegająca na uwzględnieniu postów w routingu
|test/fixtures/posts.yml                       |Posty testowe
|test/unit/post_test.rb                        |Testy jednostkowe dla modelu postów
|test/unit/helpers/posts_helper_test.rb        |Testy jednostkowe dla helpera dla postów
|==========================================================================================================

=== Uruchamianie Migracji

Jednym z produktów komendy: +script/generate scaffold+ jest migracja bazy danych.
Migracje są klasami Rubiego, które upraszczają tworzenie i modyfikowanie tabel baz danych. 
Railsy używają komend rake'a do uruchamiania migracji i pozwalają na
wycofywanie ich po tym, jak zostały zaaplikowane w Twojej bazie danych. Nazwy plików migracji
zawierają znaczniki czasowe by zapewnić ich przetwarzanie w porządku, w jakim zostały stworzone.

Gdy zajrzysz do pliku +db/migrate/20090113124235_create_posts.rb+ (jego nazwa
może się u Ciebie trochę różnić), zobaczysz następującą zawartość:

[source, ruby]
-------------------------------------------------------
class CreatePosts < ActiveRecord::Migration
  def self.up
    create_table :posts do |t|
      t.string :name
      t.string :title
      t.text :content

      t.timestamps
    end
  end

  def self.down
    drop_table :posts
  end
end
-------------------------------------------------------

Gdybyś chciał ująć ten kod w słowa, brzmiałby on mniej więcej tak: gdy migracja
jest uruchomiona, tworzy tabelę o nazwie +posts+ z dwoma kolumnami
łańcuchowymi (+name+ i +title+) i jedną kolumną tekstową (+content+), a wraz z nimi
kolumny znaczników czasu by śledzić czas jej utworzenia oraz ostatniej
aktualizacji. Więcej szczegółów na temat sposobu pisania migracji
znajdziesz w przewodniku link:migrations.html[Migracje].

Teraz możesz użyć komendy +rake+ by uruchomić migracje:

[source, shell]
-------------------------------------------------------
$ rake db:create
$ rake db:migrate
-------------------------------------------------------

NOTE: Ponieważ domyślnie pracujesz w środowisku rozwojowym, ta komenda wykona się na bazie danych zdefiniowanej w sekcji +development+ pliku: +config/database.yml+.

=== Dodawanie hiperłącza

By połączyć posty ze stroną domową, którą już stworzyłeś, możesz dodać do niej hiperłącze. 
Otwórz plik +/app/views/home/index.html.erb+ i dopisz do niego:

[source, ruby]
-------------------------------------------------------
<h1>Hello, Rails!</h1>

<%= link_to "My Blog", posts_path %>
-------------------------------------------------------

Metoda +link_to+ jest jednym z wbudowanych helperów dla widoków. Tworzy
ona link z tekstem do wyświetlenia oraz informacją, gdzie prowadzi – w tym wypadku
ze ścieżką do postu.

=== Praca z postami w przeglądarce

Teraz jesteś już gotowy do pracy z postami. Na początek przejdź do:
+http://localhost:3000+ i kliknij w link +My Blog+.

image:images/posts_index.png[Posts Index screenshot]

Jest to rezultat renderowania  Twoich postów z użyciem widoku +index+. Aktualnie nie ma żadnych
wpisów w bazie danych, ale zawsze możesz je utworzyć klikając w link +New Post+.
Możesz również przeglądać i edytować posty, a nawet je wykasować. Cały logika i
HTML stworzone były za pomocą pojedynczego polecenia +script/generate scaffold+.

TIP: W  środowisku rozwojowym (na nim domyślnie pracujesz) z każdym żądaniem
przeglądarki Railsy wgrywają od nowa program, dzięki czemu nie jest konieczne
restartowanie serwera WWW.

Gratulację! Napisałeś swoją pierwszą aplikację w Railsach! Nadszedł czas, aby przyjrzeć się efektom pracy.

=== Model

Plik modelu +app/models/post.rb+ jest niemal tak samo prosty jak jego tworzenie:

[source, ruby]
-------------------------------------------------------
class Post < ActiveRecord::Base
end
-------------------------------------------------------

Nie zawiera on zbyt wiele treści – zauważ jednak że klasa +Post+
dziedziczy z +ActiveRecord::Base+. Moduł Active Record za darmo dostarcza wielu funkcji dla
Twoich modeli, włączając w to podstawowe operacje na danych CRUD (create, read,
update, delete) czy weryfikowanie danych, jak również wsparcie dla 
zaawansowanego wyszukiwania i zdolność do wiązania  ze sobą wielu różnych
modeli.

=== Sprawdzanie poprawności danych

Railsy są wyposażone w metody, które pomogą Ci sprawdzić poprawność danych wysyłanych do modeli. Wprowadź poniższe zmiany do pliku: +app/models/post.rb+

[source, ruby]
-------------------------------------------------------
class Post < ActiveRecord::Base
  validates_presence_of :name, :title
  validates_length_of :title, :minimum => 5
end
-------------------------------------------------------

Dzięki nim mamy pewność, że każdy post będzie mieć nazwę oraz tytuł, a ten ostatni nie będzie miał mniej niż 5 znaków. Railsy mogą sprawdzać różne warunki w modelu, włączając w to obecność lub unikalność kolumn, ich format i istnienie związanych z nimi obiektów.

=== Używanie konsoli

By zobaczyć, jak sprawdzanie poprawności danych działa w praktyce, użyjemy konsoli.
Konsola, będąca narzędziem linii poleceń, umożliwia Ci wykonywanie kodu
Ruby’ego w kontekście Twojej aplikacji:

[source, shell]
-------------------------------------------------------
$ script/console
-------------------------------------------------------

Możesz jej użyć do pracy z modelami Twojego programu::

[source, shell]
-------------------------------------------------------
>> p = Post.create(:content => "A new post")
=> #<Post id: nil, name: nil, title: nil, content: "A new post", 
created_at: nil, updated_at: nil>
>> p.save
=> false
>> p.errors
=> #<ActiveRecord::Errors:0x23bcf0c @base=#<Post id: nil, name: nil, 
title: nil, content: "A new post", created_at: nil, updated_at: nil>, 
@errors={"name"=>["can't be blank"], "title"=>["can't be blank", 
"is too short (minimum is 5 characters)"]}>
-------------------------------------------------------

Powyższy kod przedstawia informację, jaką otrzymasz, gdy chcesz stworzyć nowy, ale błędny +Post+. Mechanizm jest następujący: przy próbie zapisania pojawia się wartość zwrotna +false+ (oznaczającą, że zapisanie się nie powiodło), a kod wyszczególnia nam wszystkie znalezione błędy w postaci +errors+.

TIP: W przeciwieństwie do serwerów WWW, konsola nie wprowadza automatycznie Twojego kodu na nowo z każdą linią. By dokonać zmian w Twoim modelu za pomocą konsoli, musisz użyć komendy +reload!+

=== Listowanie postów

Najłatwiejszym sposobem na zapoznanie się z możliwościami programu jest kod, który listuje wszystkie posty. Otwórz plik: +app/controllers/posts_controller.rb+ i przyjrzy się akcji +index+

[source, ruby]
-------------------------------------------------------
def index
  @posts = Post.find(:all)

  respond_to do |format|
    format.html # index.html.erb
    format.xml  { render :xml => @posts }
  end
end
-------------------------------------------------------

Powyższy kod przypisuje przykładowa zmienną +@posts+ do tablicy wszystkich postów w bazie danych. +Post.find(:all)+ lub +Post.all+ tworzy zawołanie dla modelu +Post+, który bezwarunkowo zwraca wszystkie posty z bazy danych.

TIP: Więcej informacji na temat znajdowania rekordów za pomocą Active Record znajdziesz w link:../finders.html[Active Record Finders]

Blok +respond_to+ obsługuje obydwa zawołania dla tej akcji - zarówno HTML jak i XML. Jeśli przejdziesz do +http://localhost:3000/posts.xml+, to zobaczysz wszystkie posty w formacie XML. Natomiast format HTML znajduję się w widoku +app/views/posts+, nazwanym tak samo jak odpowiadająca mu akcja. Railsy same przenoszą wszystkie przykładowe zmienne z dostępnych akcji do widoku. Oto +app/view/posts/index.html.erb+:

[source, ruby]
-------------------------------------------------------
<h1>Listing posts</h1>

<table>
  <tr>
    <th>Name</th>
    <th>Title</th>
    <th>Content</th>
  </tr>

<% for post in @posts %>
  <tr>
    <td><%=h post.name %></td>
    <td><%=h post.title %></td>
    <td><%=h post.content %></td>
    <td><%= link_to 'Show', post %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
    <td><%= link_to 'Destroy', post, :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New post', new_post_path %>
-------------------------------------------------------

Widok wyświetla treść tablicy +@posts+, by pokazać zawartość oraz linki. Przyjrzymy się uważnie paru jego aspektom:

* +h+ to helper metody który ujednolica wyświetlane danych, zapobiegający atakom „cross-site scripting”
* +link_to+ buduje hiperłącze dla określonej lokalizacji
* +edit_post_path+ jest helperem, który Railsy udostępniają w ramach routingu RESTful. Zobaczysz jeszcze sporo różnych rodzajów takich helperów dla wielu, znajdujących się w kontrolerze, akcji.

TIP: Więcej szczegółów na temat procesu renderingu znajdziesz w link:../layouts_and_rendering.html[Layouts and Rendering in Rails].

=== Personalizacja Layoutu

Widok stanowi tylko część całego procesu przedstawiania przez HTML Twojej strony www. Railsy posiadają też różne gotowe layouty +layouts+, w których trzymane są widoki. Renderowanie widoku dla przeglądarki odbywa się poprzez umieszczanie widoku HTML wewnątrz layoutu HTML. Komenda +script/generate scaffold+ automatycznie tworzy dla postu domyślny layout: +app/views/layouts/posts.html.erb+. Używając edytora zmodyfikuj go w następujący sposób:

[source, ruby]
-------------------------------------------------------
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <title>Posts: <%= controller.action_name %></title>
  <%= stylesheet_link_tag 'scaffold' %>
</head>
<body style="background: #EEEEEE;">

<p style="color: green"><%= flash[:notice] %></p>

<%= yield  %>

</body>
</html>
-------------------------------------------------------

Gdy teraz odświeżysz stronę +/posts+, zobaczysz szare tło. Takie samo będzie używane dla wszystkich widoków postów.

=== Tworzenie nowego postu.

Nowy post kreuje się za pomocą dwóch akcji. Pierwszą jest +new+, która tworzy nowy, pusty obiekt +Post+:

[source, ruby]
-------------------------------------------------------
def new
  @post = Post.new

  respond_to do |format|
    format.html # new.html.erb
    format.xml  { render :xml => @post }
  end
end
-------------------------------------------------------

Widok +new.html.erb+ wyświetli dla użytkownika pusty Post:

[source, ruby]
-------------------------------------------------------
<h1>New post</h1>

<% form_for(@post) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </p>
  <p>
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </p>
  <p>
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </p>
  <p>
    <%= f.submit "Create" %>
  </p>
<% end %>

<%= link_to 'Back', posts_path %>
-------------------------------------------------------

Blok +form_for+ jest używany do tworzenia formy HTML. Wewnątrz niego masz dostęp do metod, które umożliwiają zbudowanie różnorodnych sposobów kontroli form. Przykładowo: +f.text_field :name+ prosi Railsy, by stworzyły w danej formie pole do wprowadzania tekstu i połączyły go z nazwą przykładowo wyświetlanego atrybutu. Możesz użyć tej metody tylko z takimi atrybutami modelu, które są podstawą formy (w tym wypadku +name+, +title+, i +content+). Rails preferencyjnie uzywa +form_for+ do stworzenia surowego kodu HTML. Dzięki temu jest on bardziej zwięzły i wyraźnie widać związek formy z konkretnym modelem.

TIP: Jeśli potrzebujesz stworzyć formę HTML, która pokazuje dowolne pole, niezwiązane z modelem, powinieneś użyć metody +form_tag+. Umożliwia ona szybkie zbudowanie form, których nie trzeba łączyć z konkretnym modelem.

Gdy użytkownik kliknie na przycisk +create+, przeglądarka wyśle informacje zwrotną do metody kontrolera +create+ (Railsy wiedzą, że mają posłużyć się metodą +create+, ponieważ forma jest wysyłana za pomocą żądania HTTP POST – jest to jedna z tych umownych rzeczy, o których wspomniałem wcześniej):

[source, ruby]
-------------------------------------------------------
def create
  @post = Post.new(params[:post])

  respond_to do |format|
    if @post.save
      flash[:notice] = 'Post was successfully created.'
      format.html { redirect_to(@post) }
      format.xml  { render :xml => @post, :status => :created, :location => @post }
    else
      format.html { render :action => "new" }
      format.xml  { render :xml => @post.errors, :status => :unprocessable_entity }
    end
  end
end
-------------------------------------------------------

Akcja +create+ tworzy nowy obiekt Post z danych przekazanymi przez użytkownika w formie, który Railsy udostępnią w +params+. Po zapisaniu nowego postu, używają one +flash[:notice]+ do stworzenia wiadomości informacyjnej dla użytkownika oraz przekierowują do wyświetlanej akcji. Jeśli napotka jakiś problem, akcja +create+ pokaże po prostu widok +new+ drugi raz, wraz z wiadomością o błędzie.

Railsy zapewniają hash: +flash+ (zwyczajowo nazywany Flashem), przez co wiadomość może być przeniesiona do nastepnej akcji, dając użytkownikowi przydatne informacje o statusie jego żądania. W przypadku +create+ użytkownik nigdy nie widzi strony renderowanej podczas procesu tworzenia postu, ponieważ jest przekierowywany do nowego postu dopiero po zapisaniu rekordu. Flash przenosi informacje do następnej akcji, zatem gdy użytkownik jest przekierowywany ponownie do akcji +show+, ukazuje mu się informacja „Post został stworzony”.

=== Prezentacja pojedynczego postu

Gdy klikniesz w link +show+ dla postu na stronie głównej, przeniesie Cię ona do adresu +http://localhost:3000/posts/1+ (lub podobnego). Railsy traktują to jako prośbę o zasoby skierowaną do akcji +show+ i przechodzącą w +1+ z parametrem +:id+. Akcja +show+ wygląda tak:

[source, ruby]
-------------------------------------------------------
def show
  @post = Post.find(params[:id])

  respond_to do |format|
    format.html # show.html.erb
    format.xml  { render :xml => @post }
  end
end
-------------------------------------------------------

Akcja +show+ używa +Post.find+, by znaleźć w bazie danych pojedynczy rekord z jej wartością id.
Railsy wyświetlają go używając +show.html.erb+:

[source, ruby]
-------------------------------------------------------
<p>
  <b>Name:</b>
  <%=h @post.name %>
</p>

<p>
  <b>Title:</b>
  <%=h @post.title %>
</p>

<p>
  <b>Content:</b>
  <%=h @post.content %>
</p>


<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
-------------------------------------------------------

=== Edytowanie postów

Edytowanie postu, podobnie jak tworzenie nowego, odbywa się dwustopniowo. Pierwszym krokiem jest żadanie +edit_post_path(@post)+ odnoszące się do konkretnego postu. To wywołuje nam akcję +edit+ w kontrolerze:

[source, ruby]
-------------------------------------------------------
def edit
  @post = Post.find(params[:id])
end
-------------------------------------------------------

Railsy do wyświetlenia znalezionego postu używają +edit.html.erb+ :

[source, ruby]
-------------------------------------------------------
<h1>Editing post</h1>

<% form_for(@post) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </p>
  <p>
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </p>
  <p>
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </p>
  <p>
    <%= f.submit "Update" %>
  </p>
<% end %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
-------------------------------------------------------
Składając stworzoną przez ten widok formę, odwołujemy się do akcji +update+ wewnątrz kontrolera:

[source, ruby]
-------------------------------------------------------
def update
  @post = Post.find(params[:id])

  respond_to do |format|
    if @post.update_attributes(params[:post])
      flash[:notice] = 'Post was successfully updated.'
      format.html { redirect_to(@post) }
      format.xml  { head :ok }
    else
      format.html { render :action => "edit" }
      format.xml  { render :xml => @post.errors, :status => :unprocessable_entity }
    end
  end
end
-------------------------------------------------------

Railsy, by móc zlokalizować edytowany rekord bazy danych, wykorzystują znajdujący się w widoku edycji parametr +:id+ na samym początku akcji +update+. +Update_attributes+ wywołuje, a następnie wykorzystuje pozostałe parametry, które zażądaliśmy i dołącza je do tego rekordu. Gdy wszystko pójdzie dobrze użytkownik jest przekierowywany do widoku +show+ postu. Jeśli jednak wystąpią jakieś problemy, Railsy skierują go spowrotem do +edit+, aby umożliwić mu poprawienie błędów.

NOTE: Uważni czytelnicy zapewne zauważyli, że deklaracja +form_for+ jest taka sama dla widoków +new+ i +edit+. Railsy generują inny kod dla każdego z formularzy, ponieważ są na tyle bystre, żeby zauważyć, że w jednym przypadku otrzymują nowy rekord, który jeszcze nie był zapisany, natomiast w drugim istniejący rekord, który już został zapisany w bazie danych. Podczas pisania programu w Railsach normalnie wyeliminowałbyś tę duplikację poprzez przeniesienie powtarzającego się kodu do podszablonu, który następnie byłby włączany w oba nadrzędne szablony. Jednakże generator rusztowań próbuje nie tworzyć zbyt wielu założeń i generuje kod, który łatwo modyfikować, gdy chcesz mieć różne formularze do akcji +create+ i +edit+.

=== Kasowanie Postu

Wreszcie, kliknięcie na jednym z linków kategorii +destroy+ wysyła powiązane id do akcji +destroy+:

[source, ruby]
-------------------------------------------------------
def destroy
  @post = Post.find(params[:id])
  @post.destroy

  respond_to do |format|
    format.html { redirect_to(posts_url) }
    format.xml  { head :ok }
  end
end
-------------------------------------------------------

Metoda +destroy+ modelu Active Record natychmiast usuwa odpowiadający mu rekord z bazy danych. Po tej operacji nie ma już żadnego rekordu do wyświetlenia, dlatego Railsy przekierowują przeglądarkę użytkownika prosto do widoku index tego modelu.

== Wykorzystanie zasady DRY

W tym miejscu warto przyjrzeć się paru narzędziom, które Railsy oferują do usuwania duplikatów w Twoim kodzie. Szczególnie zwrócimy uwagę na _partials_, które możesz używać do eliminacji duplikatów z widoków oraz filtrach (_filters_), które pomagają się z nimi uporać w kontrolerach.

=== Używanie podszablonów do eliminacji duplikatów w widokach.

Jak już widziałeś wcześniej, widok generatora rusztowania dla akcji +new+ i +edit+ jest bardzo podobny. Możesz przenieść dzielony kod prosto do podszablonu. Wymaga to edytowania widoków +new+ i +edit+ oraz dodania nowego szablonu. Nowy +_form.html.erb+ szablon powinien być zapisany w tym samym folderze +app/views/posts+ co plik, z którego został on wyprowadzony. Zauważ, że nazwa tego pliku zaczyna się od podkreślenia ' _ ' - jest to przyjęte przez Rails nazewnictwo dla podszablonów.

+new.html.erb+:

[source, ruby]
-------------------------------------------------------
<h1>New post</h1>

<%= render :partial => "form" %>

<%= link_to 'Back', posts_path %>
-------------------------------------------------------

+edit.html.erb+:

[source, ruby]
-------------------------------------------------------
<h1>Editing post</h1>

<%= render :partial => "form" %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
-------------------------------------------------------

+_form.html.erb+:

[source, ruby]
-------------------------------------------------------
<% form_for(@post) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </p>
  <p>
    <%= f.label :title, "title" %><br />
    <%= f.text_field :title %>
  </p>
  <p>
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </p>
  <p>
    <%= f.submit "Save" %>
  </p>
<% end %>
-------------------------------------------------------

Teraz, gdy Railsy renderują widok +new+ lub +edit+, umieszczą go w szablonie +_form+ we wskazanym punkcie. Zwróć uwagę na nazewnictwo dla szablonów: jeśli odnosisz się do szablonu o nazwie +form+ wewnątrz widoku, to +_form.html.erb+ jest odpowiadającym mu plikiem (z podkreśleniem ' _ ' na początku).

Więcej informacji na temat szablonów uzyskasz w przewodniku link:../layouts_and_rendering.html[Layouts and Rending in Rails].

=== Używanie filtrów do eliminacji powtórzeń w kontrolerze

Teraz, gdy popatrzysz na kontroler pod kątem postów, zobaczysz parę duplikatów:

[source, ruby]
-------------------------------------------------------
class PostsController < ApplicationController
  # ...
  def show
    @post = Post.find(params[:id])
	# ... 
  end

  def edit
    @post = Post.find(params[:id])
  end

  def update
    @post = Post.find(params[:id])
    # ...
  end

  def destroy
    @post = Post.find(params[:id])
    # ...
  end
end
-------------------------------------------------------

Cztery wystąpienia tej samej linii kodu są niezgodne z zasadą DRY. Railsy zapewniają _filtry_ jako sposób na tego typu powtarzający się kod. W tym przypadku możesz poprawić pewne części używając +before_filter+:

[source, ruby]
-------------------------------------------------------
class PostsController < ApplicationController
  before_filter :find_post, :only => [:show, :edit, :update, :destroy]
  # ...
  def show
	# ... 
  end

  def edit
  end

  def update
    # ...
  end

  def destroy
    # ...
  end

  private
    def find_post
      @post = Post.find(params[:id])
    end
end
-------------------------------------------------------

Railsy uruchamiają _before filters_  przed każdą akcją w kontrolerze. Możesz użyć polecenia +:only+ by ograniczyć działanie _before filters_ tylko do określonych akcji, lub polecenia +:except+, by wyłączyć działanie _before filters_ dla niektórych z nich. Railsy dają Ci też możliwośc skorzystania z _after filters_, które uruchamiają się po przetworzeniu akcji, analogicznie jak _around filters_ otaczają akcje w trakcie jej przetwarzania. Do tego filtry mogą być także definiowane jako zewnętrzne klasy, by ułatwić przenoszenie ich pomiędzy kontrolerami.

Więcej informacji o filtrach znajdziesz w przewodniku:link:actioncontroller_basics.html[Action Controller Basics].

== Dodawanie kolejnego modelu

Skoro widziałeś już, jak wygląda model zbudowany za pomocą rusztowania, nadszedł czas by dodać do tego programu kolejny. Na nim opierać się będą komentarze w postach na blogu.

=== Tworzenie modelu 

Modele w Rails używają nazw w liczbie pojedynczej, a do komunikowania się z bazą danych nazw w liczbie mnogiej. Przyjęło się, że dla modelu, w którym znajdują się komentarze używamy nazwy Komentarz (_Comment_). Nawet jeśli nie hcesz używać całej aparatury opartej na rusztowaniu, pamiętaj, że większość programistów piszących w Railsach by stworzyć takie rzeczy jak modele czy kontrolery dalej używa generatorów. Aby stworzyć nowy model, wprowadź do terminalu następującą komendę: 

[source, shell]
-------------------------------------------------------
$ script/generate model Comment commenter:string body:text post:references
-------------------------------------------------------

Wygeneruje ona 4 pliki:

* +app/models/comment.rb+ - Model
* +db/migrate/20081013214407_create_comments.rb+ - Migracje
* +test/unit/comment_test.rb+ i +test/fixtures/comments.yml+ - Test.

Przyjrzyjmy się
 +comment.rb+:

[source, ruby]
-------------------------------------------------------
class Comment < ActiveRecord::Base
  belongs_to :post
end
-------------------------------------------------------

To model bardzo podobny do +post.rb+, który widziałeś już wcześniej. Różnica znajduję się w lini  +belongs_to :post+ , która uruchamia asocjacje Active Record. Nauczysz się więcej na temat asocjacji w następnej części niniejszego poradnika.

Dodatkowo do tego modelu Railsy tworzą tabele bazy danych za pomocą migracji:

[source, ruby]
-------------------------------------------------------
class CreateComments < ActiveRecord::Migration
  def self.up
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end
  end

  def self.down
    drop_table :comments
  end
end
-------------------------------------------------------

Linijka +t.references+ tworzy zewnętrzny klucz kolumn dla asocjacji pomiędzy dwoma modelami. Możesz spróbować uruchomić migracje:

[source, shell]
-------------------------------------------------------
$ rake db:migrate
-------------------------------------------------------

Railsy są na tyle sprytne, że wykonują tylko te migracje, które nie są sprzeczne z działającą bazą danych.

=== Asocjacja modeli

Asocjacja Active Record pozwala Ci łatwo zdefiniować związek (asocjacje) pomiędzy dwoma modelami. W przypadku komentarzy oraz postów możesz go zapisać w ten sposób:

* Każdy komentarz należy do jednego postu
* Jeden post może mieć wiele komentarzy

Składnia jest bardzo podobna do tej, jaką Railsy używają do deklarowania asocjacji. Widziałeś już linie kodu umieszczoną w modelu komentarza, która przypisuje każdy komentarz do postu:

[source, ruby]
-------------------------------------------------------
class Comment < ActiveRecord::Base
  belongs_to :post
end
-------------------------------------------------------

Żeby dodać drugą stronę asocjacji konieczna jest edycja pliku +post.rb+ :

[source, ruby]
-------------------------------------------------------
class Post < ActiveRecord::Base
  validates_presence_of :name, :title
  validates_length_of :title, :minimum => 5
  has_many :comments
end
-------------------------------------------------------

Dzięki tym dwóm deklaracjom w znaczny sposób automatyzujemy sposób zachowania się naszego programu. Praktycznie wygląda to tak: jeśli masz przykładową zmienną +@post+ zawierającą post, możesz otrzymać wszystkie komentarze, które do niego należą jako tablicę +@post.comments+.

TIP: Po więcej informacji na temat asocjacji Active Record zajrzyj do przewodnika: link:../association_basics.html[Active Record Associations].

=== Dodawanie Ścieżek

Ścieżki (_Routes_) to wpisy w pliku +config/routes.rb+, które informują Railsy jak interpretować nadchodzące żądania HTTP, w celu wykonania danych akcji. Otwórz ten pliku i znajdź w nim linię kodu odwołującą się do +posts+ (znajduje się ona na samym początku pliku), a następnie edytuj ją następująco:

[source, ruby]
-------------------------------------------------------
map.resources :posts do |post|
  post.resources :comments
end
-------------------------------------------------------

Tworzy to +comments+ jako zagnieżdżony zasób (_nested resource_) wewnątrz +posts+. W ten sposób jesteśmy coraz bliżej zrozumienia hierarchicznych zależności pomiędzy istniejącymi postami i komentarzami.

TIP: Po więcej informacji na temat tworzenia ścieżek sięgnij do poradnika: link:../routing_outside_in.html[Rails Routing from the Outside In].

=== Tworzenie Kontrolera

Mając już przygotowany  model, czas zacząć tworzyć pasujący do niego kontroler. I znów posłużymy się generatorem:

[source, shell]
-------------------------------------------------------
$ script/generate controller Comments index show new edit
-------------------------------------------------------

Tworzy to siedem plików:

* +app/controllers/comments_controller.rb+ - Kontroler
* +app/helpers/comments_helper.rb+ - Widok pliku helpera
* +app/views/comments/index.html.erb+ - Widok akcji _Index_
* +app/views/comments/show.html.erb+ - Widok akcji _Show_
* +app/views/comments/new.html.erb+ - Widok nowej akcji
* +app/views/comments/edit.html.erb+ - Widok akcji _Edit_
* +test/functional/comments_controller_test.rb+ - Testy funkcjonalności kontrolera

Kontroler zostanie wygenerowany z pustymi metodami oraz widokami dla każdej akcji, które zdefiniowałeś w zawołaniu +script/generate controller+:

[source, ruby]
-------------------------------------------------------
class CommentsController < ApplicationController
  def index
  end

  def show
  end

  def new
  end

  def edit
  end

end
-------------------------------------------------------

Należy to rozwinąć za pomocą kodu do aktualnego procesu żądania stosownie do każdej metody. By to rozjaśnić, poniżej znajduje się uproszczony przykład, który odpowiada jedynie na żądania wymagane przez HTML:

[source, ruby]
-------------------------------------------------------
class CommentsController < ApplicationController
  def index
    @post = Post.find(params[:post_id])
    @comments = @post.comments
  end

  def show
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
  end

  def new
    @post = Post.find(params[:post_id])
    @comment = @post.comments.build
  end

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.build(params[:comment])
    if @comment.save
      redirect_to post_comment_url(@post, @comment)
    else
      render :action => "new"
    end
  end
  
  def edit
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
  end

  def update
    @post = Post.find(params[:post_id])
    @comment = Comment.find(params[:id])
    if @comment.update_attributes(params[:comment])
      redirect_to post_comment_url(@post, @comment)
    else
      render :action => "edit"
    end
  end
  
end
-------------------------------------------------------

Jak widzisz, jest to trochę bardziej skomplikowane niż wcześniejsze operacje w kontrolerze dla postów. Jest to uboczny efekt zagnieżdżania które tworzyłeś; każde żądanie komentarza musi pilnować do którego posta jest dołączony. 

Dodatkowo, kod posiada przewagę w niektórych rodzajach metod dostępnych dla asocjacji. Przykładowo - w metodzie +new+ wywołuję się to tak:

[source, ruby]
-------------------------------------------------------
@comment = @post.comments.build
-------------------------------------------------------

Tworzy to jedną operacją nowy obiekt: +Comment+ i ustanawia pole: +post_id+, które przyjmuje +id+ z określonego obiektu +Post+.


=== Budowanie Widoków

Ponieważ przestałeś korzystać z rusztowania, konieczne będzie ręczne zbudowanie widoków dla komentarzy. Przywołanie +script/generate controller+ da ci szkielet widoków, które jednak będą pozbawione aktualnej zawartości. Oto pierwszy krok do uszczegółowienia widoków komentarza.

Widok +index.html.erb+:

[source, ruby]
-------------------------------------------------------
<h1>Comments for <%= @post.title %></h1>

<table>
  <tr>
    <th>Commenter</th>
    <th>Body</th>
  </tr>

<% for comment in @comments %>
  <tr>
    <td><%=h comment.commenter %></td>
    <td><%=h comment.body %></td>
    <td><%= link_to 'Show', post_comment_path(@post, comment) %></td>
    <td><%= link_to 'Edit', edit_post_comment_path(@post, comment) %></td>
    <td><%= link_to 'Destroy', post_comment_path(@post, comment), :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New comment', new_post_comment_path(@post) %>
<%= link_to 'Back to Post', @post %>
-------------------------------------------------------

Widok +new.html.erb+ :

[source, ruby]
-------------------------------------------------------
<h1>New comment</h1>

<% form_for([@post, @comment]) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit "Create" %>
  </p>
<% end %>

<%= link_to 'Back', post_comments_path(@post) %>
-------------------------------------------------------

Widok +show.html.erb+ :

[source, ruby]
-------------------------------------------------------
<h1>Comment on <%= @post.title %></h1>

<p>
  <b>Commenter:</b>
  <%=h @comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%=h @comment.body %>
</p>

<%= link_to 'Edit', edit_post_comment_path(@post, @comment) %> |
<%= link_to 'Back', post_comments_path(@post) %>
-------------------------------------------------------

Widok +edit.html.erb+ :

[source, ruby]
-------------------------------------------------------
<h1>Editing comment</h1>

<% form_for([@post, @comment]) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit "Update" %>
  </p>
<% end %>

<%= link_to 'Show', post_comment_path(@post, @comment) %> |
<%= link_to 'Back', post_comments_path(@post) %>
-------------------------------------------------------

Obecna, coraz większa komplikacja (w porównaniu do widoków dla zarządzania postami, które do tej pory widziałeś) ponownie bierze się z konieczności żonglowania postami i ich komentarzami w tym samym czasie.

=== Przyłączanie komentarzy do postów

W następnym kroku zmodyfikuje widok: +show.html.erb+, by pokazać komentarze oraz umożliwić zarządzanie nimi dla tego postu: 

[source, ruby]
-------------------------------------------------------
<p>
  <b>Name:</b>
  <%=h @post.name %>
</p>

<p>
  <b>Title:</b>
  <%=h @post.title %>
</p>

<p>
  <b>Content:</b>
  <%=h @post.content %>
</p>

<h2>Comments</h2>
<% @post.comments.each do |c| %>
	<p>
	  <b>Commenter:</b>
	  <%=h c.commenter %>
	</p>

	<p>
	  <b>Comment:</b>
	  <%=h c.body %>
	</p>
<% end %>

<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
<%= link_to 'Manage Comments', post_comments_path(@post) %>
-------------------------------------------------------

Zapamiętaj, że każdy post ma swój osobny zbiór komentarzy, dostępny przez +@post.comments+. Wynika to z zadeklarowanych asocjacji w modelach. Ścieżka helperów, taka jak +post_comments_path+ pochodzi od zagnieżdżonej ścieżki deklaracji w +config/routes.rb+.

== Co dalej?

Teraz, gdy masz przed sobą swój pierwszy Railsowy program, możesz go uatrakcyjniać według własnych potrzeb. Ale nie musisz do wszystkich rozwiązań dochodzić samodzielnie. Jeśli potrzebujesz wsparcia przy tworzeniu i uruchamianiu aplikacji Rails skorzystaj z tych poradników:

* link:http://guides.rubyonrails.org/[Ruby On Rails guides]
* link:http://groups.google.com/group/rubyonrails-talk[Ruby on Rails mailing list]
* Kanał #rubyonrails na irc.freenode.net
* link:http://wiki.rubyonrails.org/rails[Rails wiki]

Railsy mają równiez wbudowaną pomoc, która możesz wywołać przy użyciu komendy rake w linii komend:

* Uruchomienie +rake doc:guides+ umieści kopię Rails Guides (przewodnik Rails) w folderze +/doc/guides+ Twojego programu. Znajdujący się tam plik +/doc/guides/index.html+ możesz przeglądać używając Twojej przeglądarki.

* Uruchomienie +rake doc:rails+ umieści kopię dokumentacji API dla Rails w folderze +/doc/api+ Twojej aplikacji. Znajdujący się tam plik +/doc/api/index.html+ możesz przeglądać używając Twojej przeglądarki.


== Zmiany ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/2[Lighthouse ticket]

* November 3, 2008: Formatting patch from Dave Rothlisberger
* November 1, 2008: First approved version by link:../authors.html#mgunderloy[Mike Gunderloy]
* October 16, 2008: Revised based on feedback from Pratik Naik by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* October 13, 2008: First complete draft by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* October 12, 2008: More detail, rearrangement, editing by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* September 8, 2008: initial version by James Miller (not yet approved for publication)
