Zaczynamy z Rails
=================

Ten przewodnik jest wprowadzeniem do Ruby on Rails. Po jego przeczytaniu będziesz zaznajomiony z:

* Instalowaniem Railsów, tworzeniem nowej aplikacji oraz zestawianiem połączenia z bazę danych
* Ogólnym układem aplikacji
* Podstawami modelu MVC (Model, View, Controller) oraz architektury RESTful
* Szybkim generowaniem podstawowych elementów aplikacji

== Co obejmuje przewodnik?

Ten przewodnik jest przeznaczony dla początkujących, którzy chcą rozpocząć tworzenie aplikacji opartych na Railsach. Nie zakładamy, że masz wcześniejsze doświadczenia z Railsami. Niemniej jednak, do jak najlepszego wykorzystania tego przewodnika, konieczne jest:

* link:http://www.ruby-lang.org/en/downloads/ [Ruby] - podstawowa wiedza z zakresu języka Ruby
* link:http://rubyforge.org/frs/?group_id=126[RubyGems] - narzędzie do dystrybuowania i instalowania paczek zawierających moduły i rozszerzenia języka Ruby
* Zarządzanie bazą danych link:http://www.sqlite.org/[SQLite] (preferowane), link:http://www.mysql.com/[MySQL] lub link:http://www.postgresql.org/[PostgreSQL]

Zdecydowanie zaleca się zapoznanie z językiem Ruby przed rozpoczęciem przygody z Railsami. Znacznie łatwiej jest śledzić, co się dzieje w Railsach, rozumiejąc podstawowy składni Ruby. Rails nie będzie w stanie w sposób magiczny zrewolucjonizować sztuki pisania aplikacji internetowych, jeżeli nie masz doświadczenia w używaniu języka. W Internecie istnieje kilka dobrych darmowych źródeł pomocnych w nauce języka Ruby, w tym:

* link:http://www.humblelittlerubybook.com/[Mr. Neigborlyâs Humble Little Ruby Book]
* link:http://www.rubycentral.com/book/[Programming Ruby]
* link:http://poignantguide.net/ruby/[Why's (Poignant) Guide to Ruby]

== Co to jest Rails?

Rails to internetowo rozwijany framework napisany w języku Ruby. Został on tak zaprojektowany, aby ułatwić programowanie aplikacji internetowych, dostarczając zbiór wytycznych, od których każdy deweloper musi zacząć. Pozwala on na pisanie krótszego kodu, niż jest to możliwe podczas używania większości innych języków i frameworków. Poza tym, projektanci uważają, że wykorzystanie Railsów przy tworzeniu aplikacjach internetowych sprawia przyjemność.

Railsy są "upartym" oprogramowaniem. Oznacza to, że są stworzone, aby zachęcić do wyboru najlepszej drogi, a w niektórych przypadkach -  by zniechęcić do wyboru alternatywy. Jeśli nauczysz się "The Rails Way", odkryjesz ogromny wzrost produktywności. Jednak jeżeli podczas pracy z Railsami pozostaniesz przy nawykach charakterystycznych dla programowania w innych językach lub będziesz wykorzystywać wzorce, których już kiedyś się nauczyłeś, efekty mogą nie być aż tak pomyślne. 

Filozofia Railsów zawiera kilka zasad:

* DRY - "Don't Repeat Yourself" (Nie powtarzaj się) - sugeruje, że pisanie tego samego kodu przez cały czas jest złe.
* Konwencja Ponad Konfiguracją - Railsy wychodzą z założenia, że wiesz co chcesz zrobić i w jaki sposób, dlatego nie zmuszają Cię do samodzielnego ustawiania każdego najdrobniejszego szczegółu
* REST jest najlepszym wzorem dla aplikacji internetowych - organizowanie aplikacji wokół zasobów i standardowych zapytań HTTP jest najszybszym możliwym rozwiązaniem

=== Architektura MVC 

Railsy są zorganizowane wokół trzech komponentów aplikacji: modelu (model), widoku (view), kontrolera (controller), co w skrócie nazywany MVC. Wzorzec MVC obejmuje: 

* Odizolowanie logiki biznesowej od interfejsu użytkownika 
* Łatwość utrzymania kodu zgodnie z zasadą DRY 
* Wyraźne zaznaczenie, gdzie powinny się znajdować różne elementy kodu, co ułatwia zarządzenie tym kodem

==== Models

Model przedstawia informacje (dane) dla aplikacji i reguły do manipulowania tymi danymi. W przypadku Rails, modele są głównie wykorzystywane do zarządzania zasadami interakcji z odpowiednią tabelą bazy danych. W większości przypadków jednej tabeli bazy danych odpowiada jeden model w Twojej aplikacji. Większość Twoich aplikacji realizujących logikę biznesową będzie skoncentrowana w modelach.

==== Widoki

Widoki tworzą interfejs użytkownika aplikacji. W Railsach, widoki są często plikami HTML zawierającymi kod w języku Ruby, wykonujący zadania związane wyłącznie z prezentacją danych. Przede wszystkim są odpowiedzialne za dostarczanie danych do przeglądarki internetowej lub innego narzędzia, które jest używane do oglądania efektów działania Twojej aplikacji.

==== Kontrolery 

Kontrolery "sklejają" modele i widoki. W Railsach odpowiadają za przetwarzanie żądań przychodzących z przeglądarki internetowej, pozyskiwanie danych z modeli i przekazywanie ich do widoków w celu prezentacji.

=== Składniki Railsów

Rails dostarcza pełnego zestawu komponentów do tworzenia aplikacji internetowych. Są to: 

* Action Controller
* Action View
* Active Record
* Action Mailer
* Active Resource
* Railties
* Active Support

==== Action Controller

Action Controller jest komponentem zarządzającym kontrolerami w Railsowej aplikacji. Framework kontrolera Action Controller przetwarza przychodzące do aplikacji Railsowej zapytania, wydobywa z nich parametry i wysyła je do odpowiedniej akcji. Usługi świadczone przez Action Controller obejmują zarządzanie sesją (session), szablon renderowania (template rendering) i przekierowanie zarządzania.

==== Action View

Action View zarządza widokami Twojej Railsowej aplikacji. Możne tworzyć zarówno HTML i XML wyjście domyślnie. Action View zarządza szablonami renderowania, w tym zagnieżdżonymi szablonami i podszablonami (partial templates) i zagnieżdżonych szablonów, wykorzystując wbudowane wsparcie AJAX.

==== Active Record

Active Record jest podstawą dla modeli w Railsowej aplikacji. Dostarcza on niezależną bazę danych, dostarcza podstawowe funkcje aplikacji - CRUD (create, read, update and delete - utwórz, odczytaj, aktualizuj, usuń), zaawansowane znajdywanie możliwości i zdolność do wiązania modeli ze sobą pomiędzy różnymi usługami.

==== Action Mailer

Action Mailer to framework dla tworzenia usług e-mail. Action Mailer może być uzywany do wysyłania e-maili w oparciu o elastyczne szablony lub do odbioru i przetwarzania przychodzących wiadomości.

==== Active Resource

Active Resource dostarcza framework dla zarządzania połączeniami pomiędzy obiektami biznesowymi internetowych serwisów RESTful. Implementuje sposób mapowania obiektów internetowych na lokalne obiekty w oparciu o semantykę CRUD.

==== Railties

Railties jest rdzeniem kodu Rails, który buduje nowe aplikacje Railsowe i skleja ze sobą różne frameworki w Railsowych aplikacjach.

==== Active Support

Active Support jest obszernym zbiorem użytecznych klas oraz standardowych bibliotek rozszerzeń dla Ruby, które są wykorzystywane w Railsach, zarówno przez rdzeń kodu, jak i Twoje aplikacje.

=== REST

Praca doktorska Roya Fieldinga link:http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm[Architectural Styles and the Design of Network-based Software Architectures] jest powszechnie uznawana za podstawę działania architektury RESTful. Na szczęście, nie musisz czytać tego całego dokumentu, aby zrozumieć, jak działa REST w Rails. REST (Representational State Transfer) jest stylem architektury oprogramowania sprowadzającym się do dwóch podstawowych zasad: 

* Korzystanie z zasobów identyfikatorów (które na potrzeby tego przewodnika możesz traktować jakoadresy URL) w celu reprezentacji tych zasobów

* Przesyłanie reprezentacji stanów tego zasobu pomiędzy elementami systemu. 

Na przykład, aplikacja Railsowa takie zapytanie:

+DELETE /photos/17+

będzie rozumiała jako odniesienia do źródła zdjęcia o ID 17, oraz wskaże żądane działanie - usunięcie tego źródła. REST to naturalny styl architektury aplikacji internetowych i Rails czyni go jeszcze bardziej naturalnym, poprzez korzystanie z konwencji, które pozwalają na nie przejmowanie się złożnością RESTful oraz różnicami pomiędzy przeglądarkami.

Jeśli chciałbyś dowiedzieć się czegoś więcej na temat REST jako styl architektonicznego, polecam bardziej przystępne źródła od tezy Fieldinga: 

* link:http://www.infoq.com/articles/rest-introduction[Krótkie wprowadzenie do REST Stefana Tilkov] 
* link:http://bitworking.org/news/373/An-Introduction-to-REST[Wprowadzenie do REST - Joe Gregorio] (video tutorial)
* link:http://en.wikipedia.org/wiki/Representational_State_Transfer[REST - artykuł w Wikipedii] 

== Tworzenie nowego projektu w Railsach

Z pomocą tego przewodnika, będziesz mógł utworzyć projekt prostego bloga w Railsach. Zanim przystąpisz do tworzenia aplikacji, upewnij się, że masz zainstalowane Railsy.

=== Instalacja środowiska Rails 

W większości przypadków, najprostszym sposobem zainstalowania Railsów jest skorzystania z RubyGems:

[source, shell]
-------------------------------------------------------
$ gem install rails
-------------------------------------------------------

NOTE: Istnieją pewne szczególne okoliczności, w których można zastosować alternatywną strategię instalacji:

* Jeśli pracujesz w systemie Windows, będzie Ci łatwiej zainstalować link:http://instantrails.rubyforge.org/wiki/wiki.pl[Instant Rails]. Powinieneś jednak uważać instalując Instant Rails, aby wersja Railsów była aktualna. Ponadto, Windowsowa wersja Railsów jest ogólnie mniej przyjazna w użyciu niż na innych systemach operacyjnych. Jeśli to możliwe, polecamy korzystanie z Linuksowej maszyny wirtualnej. 

* Jeżeli chcesz być na bieżąco z najnowszymi zmianami w środowisku Rails, proponujemy skopiowanie kodu źródłowego z  link:http://github.com/rails/rails/tree/master[githuba] Aczkolwiek nie jest to zalecane dla początkujących

=== Tworzenie bloga 

Otwórz terminal i przejdź do folderu, w którym posiadasz odpowiednie uprawnienia do tworzenia plików, a następnie wpisz polecenie:

[source, shell]
-------------------------------------------------------
$ rails blog
-------------------------------------------------------

To stworzy Railsową aplikację, która korzysta z bazy danych SQLite. Jeśli wolisz korzystać z MySQL, uruchom zamiast tego polecenie:

[source, shell]
-------------------------------------------------------
$ rails blog -d mysql
-------------------------------------------------------

A jeśli używasz PostgreSQL do przechowywania danych, zastosuj polecenie:

[source, shell]
-------------------------------------------------------
$ rails blog -d postgresql
-------------------------------------------------------

NOTE: Uruchamiając raili -h możesz zobaczyć wszystkie akceptowane przez aplikację Railsową przełączniki. :

Po utworzeniu aplikacji, przejdź do odpowiedniego folderu, aby móc kontynuować swoją pracę:

[source, shell]
-------------------------------------------------------
$ cd blog
-------------------------------------------------------

Railsy utworzy folder o nazwie "blog" w Twoim roboczym katalogu. Otwórz ten folder i przyjrzyj się jego zawartości. Podczas pracy z tym przewodnikiem, w większości będziemy korzystać z folderu app/, ale poniżej możesz zapoznać się z podstawowymi funkcjami, które domyślnie utworzą Railsy.

[options="header"]
|==========================================================================================================
|File/Folder |Purpose
|+README+		|Jest to krótka instrukcja dla danej aplikacji. Użyj jej, aby poinformować innych między innymi o tym, jak działa Twoja aplikacja i jak ją można uruchomić.
|+Rakefile+	|Plik ten zawiera listę działań aplikacji, które można uruchomić poprzez terminal.
|+app/+		|Folder zawiera kontrolery, modele i widoki dla danej aplikacji. Na tym folderze będziemy koncentrować się w dalszej części tego przewodnika.
|+config/+		|Folder zawierający pliki konfiguracyjne dla aplikacji, odpowiadające za sposoby uruchamiania, bazę danych, ścieżki dostępu etc.
|+db/+			|Pokazuje aktualny schemat bazy danych, jak również migracje (migration) baz danych. 
|+doc/+		|Pełna dokumentacja Twojej aplikacji.
|+lib/+		|Dodatkowe moduły dla Twojej aplikacji, których nie uwzględniono w tym przewodniku
|+log/+		|Archiwum plików
|+public/+		|Jedyny całkowicie dostępny publicznie folder. Są to wszelkie zdjęcia, arkusze stylów (CSS),  To właśnie zdjęcia, JavaScript, arkuszy stylów (CSS), JavaScript i inne statyczne pliki wyjściowe
|+script/+		|Skrypty dostarczone przez Rails w celu wykonywania powtarzających się zadań, takich jak analiza porównawcza, instalowanie wtyczek (plugin) i uruchamianiu konsoli lub serwera WWW
|+test/+		|Testy jednostkowe, tak zwane "fixtures" oraz inne narzędzia służące do przeprowadzania testów.  Są one opisane w: link:../testing_rails_applications.html[Testowanie aplikacji Rails]
|+tmp/+		|Pliki tymczasowe
|+vendor/+		|Miejsce na kod którego sami nie napisaliśmy, ale chcemy wykorzystać (tak zwani "trzeci dostawcy"). W standardowej aplikacji środowiska Rails, zawiera Ruby Gems, kod źródłowy Rubiego (jeśli zastosujesz go w swoim projekcie) i wszystkie dodatkowe wtyczki z gotowym kodem.
|==========================================================================================================

=== Konfiguracja bazy danych

Każda aplikacja Railsowa korzysta z bazy danych. Rodzaj baza danych, której używamy, jest określony w pliku konfiguracyjnym +config/database.yml+.
Jeśli otworzysz ten plik w nowej aplikacji Railsowej, zostanie wyświetlona domyślna konfiguracja bazy danych SQLite. Plik zawiera części dla trzech różnych środowisk, w których Rails może być uruchomiony domyślnie: 

* środowisko +rozwojowe+ jest używane na komputerze programisty jako interfejs użytkownika. 
* środowisko +badawcze+ służy do uruchamiania automatycznych testów
* środowisko +produkcyjne+ jest używane podczas przystosowywania aplikacji dla zwykłych użytkowników

==== Konfiguracja bazy danych SQLite 

ails ma wbudowaną obsługę link:http://www.sqlite.org/[SQLite], który jest lekką, nie obciążającą serwera aplikacją bazy danych. Podczas przeciążenia SQLite przez środowisko produkcyjne, wciąż dobrze działa środowisko testowe i rozwojowe. Railsy domyślnie używają SQLite tworząc nowy projekt, ale zawsze można to później zmienić.

Poniżej prezentujemy częśc domyślnej konfiguracji pliku z informacji dla środowiska rozwojowego:

[source, ruby]
-------------------------------------------------------
development:
  adapter: sqlite3
  database: db/development.sqlite3
  timeout: 5000
-------------------------------------------------------

Jeśli nie masz żadnej zainstalowanej bazy danych, najłatwiej będzie Ci skorzystać z SQLite, w czym może być pomocny Ruby Gems (Posiadacze Maca z OS X 10.5 lub nowszym mają to zainstalowane domyślnie):

[source, shell]
-------------------------------------------------------
$ gem install sqlite3-ruby
-------------------------------------------------------

==== Konfiguracja bazy danych MySQL

Jeżeli zdecydujesz się na używanie bazy danych MySQL, Twój plik +config/database.yml+ będzie wyglądał trochę inaczej:

[source, ruby]
-------------------------------------------------------
development:
  adapter: mysql
  encoding: utf8
  database: blog_development
  username: root
  password:
  socket: /tmp/mysql.sock
-------------------------------------------------------
Ta konfiguracja powinna działac bez problemu, jeśli Twoja instalacja MySQLa nie ma wprowadzonego hasła dla super-uzytkownika (root user). Jeśli jednak jest inaczej, koniecznie zmień nazwę użytkownika oraz hasło w powyższym kodzie.

==== Konfiguracja Bazy Danych PostgreSQL

Używając PostgreSQL Twój +config/database.yml+ zostanie zmodyfikowany do pracy z tą bazą danych:

[source, ruby]
-------------------------------------------------------
development:
  adapter: postgresql
  encoding: unicode
  database: blog_development
  username: blog
  password:
-------------------------------------------------------

Konieczna jest zmiana nazwy użytkownika oraz hasła w kodzie dla części projektowej,

==== Tworzenie Bazy Danych

Teraz, gdy masz już skonfigurowaną bazę danych, czas by Rails stworzył dla ciebie pustą baze danych. Możesz to zrobić uruchamiając komendę "rake":

[source, shell]
-------------------------------------------------------
$ rake db:create
-------------------------------------------------------
NOTE: "Rake" jest poleceniem startującym ogólnego zastosowania, które Rails używa do wielu rzeczy. By zobaczyć dostępne dla niego komendy uruchom "rake -T". :

== Witaj Rails!

Jednym z tradycyjnych sposobów uczenia się nowego języka jest pobieżne przeglądnięcie jego tekstu. By tak zrobić w Railsach, konieczne jest stworzenie przynajmniej kontrolera oraz widoku.. Na szczęście możesz to zrobić używając pojedynczej komendy, wpisując ją do terminala:

[source, shell]
-------------------------------------------------------
$ script/generate controller home index
-------------------------------------------------------

TIP: Jeżeli używasz Windows, lub gdy twój Ruby jest skonfigurowany w niestandardowy sposób, możliwe że będziesz potrzebował przekazać komendy +script+ Railsów bezpośrednio do Rubyego: +ruby script/generate controller home index+.

Rails stworzy dla Ciebie parę plików, włączając w to +app/views/home/index.html.erb+ - czyli szablon, który będzie używany do pokazywania efektów +index+ action (method) w +home+ kontrolerze. Otwórz ten plik w Twoim edytorze tekstów i dopisz do niego ta pojedynczą linijkę kodu:


[source, html]
-------------------------------------------------------
<h1>Hello, Rails!</h1>
-------------------------------------------------------

=== Uruchamianie serwera WWW.

W chwili obecnej, za pomocą jedynie dwóch komend, masz gotowy i działający Railsowy program! Uruchamiając przeglądarkę na swoim komputerze programisty, za pomocą kolejnej komendy startowej: $ script/Server, będziesz mógł go zobaczyć.

[source, shell]
-------------------------------------------------------
$ script/server
-------------------------------------------------------

Domyślnie spowoduje to odpalenie instancji serwera aplikacyjnego Mongrel. By zobaczyć jak działa Twój program, otwórz okno przeglądarki i przejdź do +http://localhost:3000+. Powinieneś zobaczyć Railsową, domyślną stronę informacyjną:

image:images/rails_welcome.png[Welcome Aboard screenshot]

TIP: By zatrzymać serwer WWW naciśnij Ctrl+C w oknie terminalu podczas jego działania. Generalnie, Raily w "trybie tworzenia" (development mode) nie wymaga zatrzymywania serwera by wprowadzić Twoje zmiany w plikach - zostaną one automatycznie wprowadzone na serwer.

Ekran powitalny jest pierwszą próbą dla nowego programu napisanego w Raily - upewnia nas, że oprogramowanie którym dysponujemy jest poprawnie skonfigurowana do działania strony. By ją zobaczyć, przejdź do +http://localhost:3000/home/index+.

=== Konfiguracja Strony Domowej Programu.

Prawdopodobnie chcesz zamienić domyślną stronę startową z tą Twojego programu. Pierwszym krokiem jest wykasowanie strony domyślnej z Twojego programu:

[source, shell]
-------------------------------------------------------
$ rm public/index.html
-------------------------------------------------------

Powinieneś teraz wskazać Railsowi gdzie Twoja strona domowa jest zlokalizowana. Otwórz plik +config/routes.rb+ w swoim edytorze -  jest on plikiem routingowy (_routing file_) Twojego programu. Zawiera wpisy w specjalnym DSL (specyficzny język domeny) które pokazują Railsowi w jaki sposób połączyć żądania kontrolerów oraz akcji. Na dole tego pliku znajdują się domyślne ścieżki (_default routes_):

[source, ruby]
-------------------------------------------------------
map.connect ':controller/:action/:id'
map.connect ':controller/:action/:id.:format'
-------------------------------------------------------

Domyślne ścieżki przenoszą proste żądania, takie jak +/home/index+: Railsy tłumaczą je w postaci prośby do akcji +index+ w +home+ kontrolerze. Kolejny przykład, +/posts/edit/1+ uruchomi akcję +edit+ w +posts+ kontrollera z +id+ 1.

By połączyć Twoją stronę domową, będziesz potrzebować kolejnej linii do pliku routingu, powyżej domyślnej ścieżki: 

[source, ruby]
-------------------------------------------------------
map.root :controller => "home"
-------------------------------------------------------

Ta linijka ilustruje jeden mały kawałek podejścia zwanego „konwencja ponad konfiguracją” ("convention over configuration"): jeżeli nie podasz żadnej akcji, Rails założy domyślnie akcję +index+.

Po przejściu do strony +http://localhost:3000+ , zobaczysz widok +home/index+ .

NOTE: Więcej informacji na temat routingu znajdziesz w link:../routing_outside_in.html[Rails Routing from the Outside In].

== Szybki start dzięki rusztowaniu.

Railsowe rusztowanie (_scaffolding_) jest szybkim sposobem na stworzenia znacznej części programu. Jeśli chcesz stworzyć modele, widoki i kontrolery dla nowych zasobów w pojedynczej operacji, to jest to odpowiednim narzędziem dla Ciebie.

== Creating a Resource

W przypadku programów takich jak blog, możesz zacząć od stworzenia obiektu typu Post („Post resource”), który odpowiada za pojedynczy post blogu, w oparciu o rusztowania. By to zrobić, wprowadź następującą komendę do terminalu:

[source, shell]
-------------------------------------------------------
$ script/generate scaffold Post name:string title:string content:text
-------------------------------------------------------

NOTE: Chociaż rusztowanie pozwoli Ci szybko rozpocząć pisanie programu, ten uniwersalny, działający wszędzie kod raczej nie będzie idealnie pasować do Twojej aplikacji. W większości przypadków będziesz musiał samodzielnie dokonać w nim zmian. Wielu doświadczonych programistów Rails unika używania rusztowań na rzecz pisania większości kodu źródłowego od podstaw, bez używania gotowych wzorców.

Generator rusztowania zbuduje w Twoim programie 14 plików, wspólnie z paroma folderami, i jeden dodatkowo edytuje. Oto krótki przegląd tego co tworzy:

[options="header"]
|==========================================================================================================
|File                                          |Purpose
|app/models/post.rb                            |Model Postu
|db/migrate/20081013124235_create_posts.rb     |Migracja do tworzenia tabel postów w Twojej bazie danych (nazwa którą wpiszesz będzie zawierać rózne znaczniki czasowe)
|app/views/posts/index.html.erb                |Widok dla indeksu wszystkich postów 
|app/views/posts/show.html.erb                 |Widok dla pojedynczego postu
|app/views/posts/new.html.erb                  |Widok dla tworzenia nowego postu
|app/views/posts/edit.html.erb                 |Widok dla edycji postu
|app/views/layouts/posts.html.erb              |Widok określający całościowy wygląd i działanie innych widoków dla postów.
|public/stylesheets/scaffold.css               |Poprawianie wyglądu przy użyciu szablonu stylów CSS
|app/controllers/posts_controller.rb           |Kontroler postów
|test/functional/posts_controller_test.rb      |Testy funkcjonalności dla kontrolerów postów
|app/helpers/posts_helper.rb                   |Helpery (helper functions) używane przy widokach postów
|config/routes.rb                              |Plik zawierający informacje routingowe dla postów
|test/fixtures/posts.yml                       |Posty testowe
|test/unit/post_test.rb                        |Testy funkcjonalności dla modeli postów
|==========================================================================================================

=== Uruchamianie Migracji

Jednym z produktów komendy: +script/generate scaffold+ jest _database migration_. Migracje są jedną z klas Ruby które upraszczają tworzenie i modyfikowanie baz danych tabel. Railsy używają komendy „rake” by uruchamiać migracje, ale możliwe jest jej wycofanie po tym jak została dodana do Twojej bazy danych. Nazwy pilków migracji uwzględniają znaczniki czasowe by zapewnić ich przetwarzanie w porządku w jakim zostały stworzone.

Oto co znajdziesz, gdy zajrzysz do pliku +db/migrate/20090113124235_create_posts.rb+ (jego nazwa u Ciebie może się trochę różnić):

[source, ruby]
-------------------------------------------------------
class CreatePosts < ActiveRecord::Migration
  def self.up
    create_table :posts do |t|
      t.string :name
      t.string :title
      t.text :content

      t.timestamps
    end
  end

  def self.down
    drop_table :posts
  end
end
-------------------------------------------------------

Gdybyś chciał zawrzeć ten kod w słowach, brzmiałby on mniej więcej tak: gdy migracja jest uruchomiona, tworzy tabele o nazwie +posts+ z dwoma szeregami kolumn (+name+ i +title+) i tekst kolumny (+content+), a wraz z nią pola znaczników czasu by śledzić jej tworzenie oraz aktualizowanie. Więcej szczegółów na temat sposobu pisania migracji znajdziesz w przewodniku link:../migrations.html[Rails Database Migrations].

Teraz możesz użyć komendy „rake” by uruchomić migracje:

[source, shell]
-------------------------------------------------------
$ rake db:create
$ rake db:migrate
-------------------------------------------------------

NOTE: Ponieważ domyślnie pracujesz w środowisku rozwojowym, ta komenda wykona się na bazie danych zdefiniowanej w sekcji +development+ pliku: +config/database.yml+.

=== Dodawanie hiperłącza.

By połączyć posty ze stroną domową, którą już stworzyłeś, możesz dodać do niej hiperłącze. Otwórz +/app/views/home/index.html.erb+ i dopisz do niego:

[source, ruby]
-------------------------------------------------------
<h1>Hello, Rails!</h1>

<%= link_to "My Blog", posts_path %>
-------------------------------------------------------

Metoda +link_to+ jest jednym z helperów pomagających kreować widoki w Railsach. Tworzy ona hiperłącze z tekstem do wyświetlenia oraz informacją, gdzie prowadzi – w tym wypadku ze ścieżką do postu.

=== Praca z postami w przeglądarce

Teraz jesteś już gotowy do pracy z postami. Na początek przejdź do: +http://localhost:3000+ i kliknij w link „Mój blog”.

image:images/posts_index.png[Posts Index screenshot]

Jest to rezultat renderingu indeksu widoku Twoich postów. Aktualnie nie ma żadnych wpisów w bazie danych, ale zawsze możesz je utworzyć klikając w link „nowa wiadomość”.  Możesz również przeglądać i edytować posty, a nawet je wykasować. Cały układ logiczny i HTML obsługuje pojedyncze polecenie +script/generał scaffold+.

TIP: W  środowisku rozwojowym (na nim domyślnie pracujesz) z każdym żądaniem przeglądarki Railsy wgrywają od nowa program, dzięki czemu nie jest konieczne wyłączanie serwera WWW.

Gratulację! Wykonałeś swoją pierwszą aplikację w Railsach! Nadszedł czas, aby przyjrzeć się efektom pracy.

=== Model

Plik modelu +app/models/post.rb+ jest tak samo prosty w obsłudze jak jego tworzenie:

[source, ruby]
-------------------------------------------------------
class Post < ActiveRecord::Base
end
-------------------------------------------------------

Możliwości zmian tego pliku nie jest dużo – nie wolno jednak zapomnieć, że klasa +Post+ dziedziczy z +ActiveRecord:: Base+. Active Rekord za darmo dostarcza wielu funkcji dla Twoich Railsów, włączając w to podstawową baze danych operacji CRUD (Tworzenie, Czytanie, Aktualizowanie, Niszczenie) czy uwierzytelnianie danych – podobnie jak wsparcie  zaawansowanego wyszukiwania i zdolność do wiązania wielu różnych modeli jeden z drugim.

=== Sprawdzanie poprawności danych

Railsy są wyposażone w metodę, która pomoże Ci sprawdzić poprawność danych wysyłanych do modeli. Wprowadź poniższe zmiany do pliku: +app/models/post.rb+

[source, ruby]
-------------------------------------------------------
class Post < ActiveRecord::Base
  validates_presence_of :name, :title
  validates_length_of :title, :minimum => 5
end
-------------------------------------------------------

Dzięki nim mamy pewność, że każdy post będzie mieć nazwę oraz tytuł, a ten ostatni nie będzie miał mniej niż 5 znaków. Railsy mogą sprawdzać różne warunki w modelu, włączając w to obecność lub unikalność kolumn, ich format, i istnienie związanych z nimi obiektów.

=== Używanie konsoli

By zobaczyć, jak sprawdzanie poprawności danych działa w praktyce, użyjemy konsoli. Konsola, w postaci linii komend, jest narzędziem które umożliwia Ci wykonywanie kodów Ruby’ego w ramach działania Twojej aplikacji:

[source, shell]
-------------------------------------------------------
$ script/console
-------------------------------------------------------

Możesz jej użyć do pracy z modelami Twojego programu::

[source, shell]
-------------------------------------------------------
>> p = Post.create(:content => "A new post")
=> #<Post id: nil, name: nil, title: nil, content: "A new post", 
created_at: nil, updated_at: nil>
>> p.save
=> false
>> p.errors
=> #<ActiveRecord::Errors:0x23bcf0c @base=#<Post id: nil, name: nil, 
title: nil, content: "A new post", created_at: nil, updated_at: nil>, 
@errors={"name"=>["can't be blank"], "title"=>["can't be blank", 
"is too short (minimum is 5 characters)"]}>
-------------------------------------------------------

Powyższy kod przedstawia informację jaką otrzymasz, gdy chcesz stworzyć nowy, ale błędny +Post+. Mechanizm jest następujący: przy próbie zapisania pojawia się wartość zwrotna +false+ (oznaczającą, że zapisanie się nie powiodło), a kod wyszczególnia nam wszystkie znalezione błędy +errors+.

TIP: W przeciwieństwie do serwerów WWW, konsola nie wprowadza automatycznie Twojego kodu na nowo z każdą linią. By dokonać zmian w Twoim modelu za pomocą konsoli, musisz użyć komendy +reload!+

=== Listowanie postów

Najłatwiejszym sposobem na zapoznanie się z możliwościami programu jest kod, który listuje wszystkie posty. Otwórz plik: +app/controllers/posts_controller.rb + i przyjrzy się akcji +index+

[source, ruby]
-------------------------------------------------------
def index
  @posts = Post.find(:all)

  respond_to do |format|
    format.html # index.html.erb
    format.xml  { render :xml => @posts }
  end
end
-------------------------------------------------------

Powyższy kod przypisuje przykładowa zmienną +@posts+ do tablicy wszystkich postów w bazie danych. +Post.find(:all)+ lub +Post.all+ tworzy zawołanie dla modelu Post który bezwarunkowo zwraca wszystkie posty z bazy danych.

TIP: Więcej informacji na temat znajdowania rekordów za pomocą Active Record znajdziesz w link:../finders.html[Active Record Finders]

Blok +respond_to+ obsługuje obydwa zawołania dla tej akcji - zarówno HTML jak i XML. Jeśli przejdziesz do +http://localhost:3000/posts.xml+ to zobaczysz wszystkie posty w formacie XML. Natomiast format HTML znajduję się w widoku +app/views/posts+ nazwanym tak samo jak odpowiadająca mu akcja. Rails same przenoszą wszystkie przykładowe zmienne z dostępnych akcji do widoku. Oto +app/view/posts/index.html.erb+:

[source, ruby]
-------------------------------------------------------
<h1>Listing posts</h1>

<table>
  <tr>
    <th>Name</th>
    <th>Title</th>
    <th>Content</th>
  </tr>

<% for post in @posts %>
  <tr>
    <td><%=h post.name %></td>
    <td><%=h post.title %></td>
    <td><%=h post.content %></td>
    <td><%= link_to 'Show', post %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
    <td><%= link_to 'Destroy', post, :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New post', new_post_path %>
-------------------------------------------------------

Widok wyświetla treść tablicy +@posts+, by pokazać zawartość oraz linki. Przyjrzymy się uważnie paru jego aspektom:

* +h+ to helper metody który ujednolica wyświetlane danych, zapobiegający atakom „cross-site scripting”
* +link_to+ buduje hiperłącze dla określonej lokalizacji
* +edit_post_path+ jest helperem, który Rails udostępniają w ramach routingu RESTful. Zobaczysz jeszcze sporo różnych rodzajów takich helperów dla wielu, znajdujących się w kontrolerze, akcji.

TIP: Więcej szczegółów na temat procesu renderingu znajdziesz w link:../layouts_and_rendering.html[Layouts and Rendering in Rails].

=== Personalizacja Layoutu

Widok stanowi tylko część całego procesu przedstawiania przez HTML Twojej strony www. Rails posiada też różne gotowe layouty +layouts+, w których trzymane są widoki. Renderowanie widoku dla przeglądarki odbywa się poprzez umieszczanie widoku HTML wewnątrz layoutu HTML. Komenda +script/generate scaffold+ automatycznie tworzy dla postu domyślny layout: +app/views/layouts/posts.html.erb+. Używając edytora zmodyfikuj go w następujący sposób:

[source, ruby]
-------------------------------------------------------
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <title>Posts: <%= controller.action_name %></title>
  <%= stylesheet_link_tag 'scaffold' %>
</head>
<body style="background: #EEEEEE;">

<p style="color: green"><%= flash[:notice] %></p>

<%= yield  %>

</body>
</html>
-------------------------------------------------------

Gdy teraz odświeżysz stronę +/posts+ zobaczysz szare tło. Taki sam będzie używany dla wszystkich widoków postów.

=== Tworzenie nowego postu.

Nowy post tworzy się za pomocą dwóch akcji. Pierwszą jest +new+ która tworzy nowy, pusty obiekt +Post+:

[source, ruby]
-------------------------------------------------------
def new
  @post = Post.new

  respond_to do |format|
    format.html # new.html.erb
    format.xml  { render :xml => @post }
  end
end
-------------------------------------------------------

Widok +new.html.erb+ wyświetli dla użytkownika pusty Post:

[source, ruby]
-------------------------------------------------------
<h1>New post</h1>

<% form_for(@post) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </p>
  <p>
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </p>
  <p>
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </p>
  <p>
    <%= f.submit "Create" %>
  </p>
<% end %>

<%= link_to 'Back', posts_path %>
-------------------------------------------------------

Blok +form_for+ jest używany do tworzenia formy HTML. Wewnątrz niego masz dostęp do metod, które umożliwiają zbudowanie różnorodnych sposobów kontroli form. Przykładowo: +f.text_field :name+ prosi Railsy by stworzyły w danej formie pole do wprowadzania tekstu i połączyły go z nazwą przykładowo wyświetlanego atrybutu. Możesz użyć tej metody tylko z takimi atrybutami modelu, które są podstawą formy (w tym wypadku +name+, +title+, i +content+). Rails preferencyjnie uzywa +form_for+ do stworzenia surowego kodu HTML. Dzięki temu jest on bardziej zwięzły i wyraźnie widać związek formy z konkretnym modelem.

TIP: Jeśli potrzebujesz stworzyć formę HTML, która pokazuje dowolne pole, nie pasujące do modelu, powinieneś użyć metody +form_tag+, umożliwiające szybkie zbudowanie form, których nie trzeba łączyć z konkretnym modelem.

Gdy użytkownik kliknie na przycisk +create+, przeglądarka wyśle informacje zwrotną do metody kontrolera +create+ (Rails wiedzą, że mają posłuzyć się metodą +create+ ponieważ forma jest wysyłana za pomocą żądania HTTP POST – jest to jedna z tych umownych rzeczy o których wspomniałem wcześniej):

[source, ruby]
-------------------------------------------------------
def create
  @post = Post.new(params[:post])

  respond_to do |format|
    if @post.save
      flash[:notice] = 'Post was successfully created.'
      format.html { redirect_to(@post) }
      format.xml  { render :xml => @post, :status => :created, :location => @post }
    else
      format.html { render :action => "new" }
      format.xml  { render :xml => @post.errors, :status => :unprocessable_entity }
    end
  end
end
-------------------------------------------------------

Akcja +create+ tworzy nowy obiekt Post z danych przekazanymi przez użytkownika w formie, który Rails udostępni w +params+. Po zapisaniu nowego postu, używa on +flash[:notice]+ do stworzenia wiadomości informacyjnej dla użytkownika oraz przekierowuje do wyświetlanej akcji. Jeśli napotka jakiś problem, akcja +create+ pokaże po raz drugi tylko widok new , ale wraz z wiadomością o błędzie.

Rails zapewniają hash: +flash+ (zwyczajowo nazywany po prostu Flashem), stąd ta wiadomość może być przenoszona do innej akcji, dostarczaną użytkownikowi wraz z przydatnymi informacjami na temat statusu żądania. W przypadku +create+ użytkownik nigdy nie widzi strony renderowanej podczas procesu tworzenia postu, ponieważ jest przekierowywany do nowego postu dopiero po zapisaniu rekordu. Flash przenosi informacje do następnej akcji, zatem gdy użytkownik jest przekierowywany spowrotem do akcji +show+, ukazuje mu się informacja „Post został stworzony”.

=== Prezentacja pojedynczego postu

Gdy klikniesz w link +show+ dla postu na stronie głównej, przeniesie Cie ona do adresu +http://localhost:3000/posts/1+ (lub podobnego). Railsy traktują to jako prośbę o zasoby skierowaną do akcji +show+ i przechodzącą w +1+ z parametrem +:id+. Akcja +show+ wygląda tak:

[source, ruby]
-------------------------------------------------------
def show
  @post = Post.find(params[:id])

  respond_to do |format|
    format.html # show.html.erb
    format.xml  { render :xml => @post }
  end
end
-------------------------------------------------------

Akcja +show+ używa +Post.find+ by znaleźć w bazie danych pojedynczy rekord z jej wartością id.
Rails wyświetla go używając +show.html.erb+:

[source, ruby]
-------------------------------------------------------
<p>
  <b>Name:</b>
  <%=h @post.name %>
</p>

<p>
  <b>Title:</b>
  <%=h @post.title %>
</p>

<p>
  <b>Content:</b>
  <%=h @post.content %>
</p>


<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
-------------------------------------------------------

=== Editing Posts

Like creating a new post, editing a post is a two-part process. The first step is a request to +edit_post_path(@post)+ with a particular post. This calls the +edit+ action in the controller:

[source, ruby]
-------------------------------------------------------
def edit
  @post = Post.find(params[:id])
end
-------------------------------------------------------

After finding the requested post, Rails uses the +edit.html.erb+ view to display it:

[source, ruby]
-------------------------------------------------------
<h1>Editing post</h1>

<% form_for(@post) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </p>
  <p>
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </p>
  <p>
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </p>
  <p>
    <%= f.submit "Update" %>
  </p>
<% end %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
-------------------------------------------------------

Submitting the form created by this view will invoke the +update+ action within the controller:

[source, ruby]
-------------------------------------------------------
def update
  @post = Post.find(params[:id])

  respond_to do |format|
    if @post.update_attributes(params[:post])
      flash[:notice] = 'Post was successfully updated.'
      format.html { redirect_to(@post) }
      format.xml  { head :ok }
    else
      format.html { render :action => "edit" }
      format.xml  { render :xml => @post.errors, :status => :unprocessable_entity }
    end
  end
end
-------------------------------------------------------

In the +update+ action, Rails first uses the +:id+ parameter passed back from the edit view to locate the database record that's being edited. The +update_attributes+ call then takes the rest of the parameters from the request and applies them to this record. If all goes well, the user is redirected to the post's +show+ view. If there are any problems, it's back to +edit+ to correct them.

NOTE: Sharp-eyed readers will have noticed that the +form_for+ declaration is identical for the +new+ and +edit+ views. Rails generates different code for the two forms because it's smart enough to notice that in the one case it's being passed a new record that has never been saved, and in the other case an existing record that has already been saved to the database. In a production Rails application, you would ordinarily eliminate this duplication by moving identical code to a _partial template_, which you could then include in both parent templates. But the scaffold generator tries not to make too many assumptions, and generates code thatâs easy to modify if you want different forms for +create+ and +edit+.

=== Destroying a Post

Finally, clicking one of the +destroy+ links sends the associated id to the +destroy+ action:

[source, ruby]
-------------------------------------------------------
def destroy
  @post = Post.find(params[:id])
  @post.destroy

  respond_to do |format|
    format.html { redirect_to(posts_url) }
    format.xml  { head :ok }
  end
end
-------------------------------------------------------

The +destroy+ method of an Active Record model instance removes the corresponding record from the database. After that's done, there isn't any record to display, so Rails redirects the user's browser to the index view for the model.

== DRYing up the Code

At this point, itâs worth looking at some of the tools that Rails provides to eliminate duplication in your code. In particular, you can use _partials_ to clean up duplication in views and _filters_ to help with duplication in controllers.

=== Using Partials to Eliminate View Duplication

As you saw earlier, the scaffold-generated views for the +new+ and +edit+ actions are largely identical. You can pull the shared code out into a +partial+ template. This requires editing the new and edit views, and adding a new template. The new +_form.html.erb+ template should be saved in the same +app/views/posts+ folder as the files from which it is being extracted:

+new.html.erb+:

[source, ruby]
-------------------------------------------------------
<h1>New post</h1>

<%= render :partial => "form" %>

<%= link_to 'Back', posts_path %>
-------------------------------------------------------

+edit.html.erb+:

[source, ruby]
-------------------------------------------------------
<h1>Editing post</h1>

<%= render :partial => "form" %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
-------------------------------------------------------

+_form.html.erb+:

[source, ruby]
-------------------------------------------------------
<% form_for(@post) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </p>
  <p>
    <%= f.label :title, "title" %><br />
    <%= f.text_field :title %>
  </p>
  <p>
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </p>
  <p>
    <%= f.submit "Save" %>
  </p>
<% end %>
-------------------------------------------------------

Now, when Rails renders the +new+ or +edit+ view, it will insert the +_form+ partial at the indicated point. Note the naming convention for partials: if you refer to a partial named +form+ inside of a view, the corresponding file is +_form.html.erb+, with a leading underscore.

For more information on partials, refer to the link:../layouts_and_rendering.html[Layouts and Rending in Rails] guide.

=== Using Filters to Eliminate Controller Duplication

At this point, if you look at the controller for posts, youâll see some duplication:

[source, ruby]
-------------------------------------------------------
class PostsController < ApplicationController
  # ...
  def show
    @post = Post.find(params[:id])
	# ... 
  end

  def edit
    @post = Post.find(params[:id])
  end

  def update
    @post = Post.find(params[:id])
    # ...
  end

  def destroy
    @post = Post.find(params[:id])
    # ...
  end
end
-------------------------------------------------------

Four instances of the exact same line of code doesnât seem very DRY. Rails provides _filters_ as a way to address this sort of repeated code. In this case, you can DRY things up by using a +before_filter+:

[source, ruby]
-------------------------------------------------------
class PostsController < ApplicationController
  before_filter :find_post, :only => [:show, :edit, :update, :destroy]
  # ...
  def show
	# ... 
  end

  def edit
  end

  def update
    # ...
  end

  def destroy
    # ...
  end

  private
    def find_post
      @post = Post.find(params[:id])
    end
end
-------------------------------------------------------

Rails runs _before filters_ before any action in the controller. You can use the +:only+ clause to limit a before filter to only certain actions, or an +:except+ clause to specifically skip a before filter for certain actions. Rails also allows you to define _after filters_ that run after processing an action, as well as _around filters_ that surround the processing of actions. Filters can also be defined in external classes to make it easy to share them between controllers.

For more information on filters, see the link:actioncontroller_basics.html[Action Controller Basics] guide.

== Adding a Second Model

Now that you've seen what's in a model built with scaffolding, it's time to add a second model to the application. The second model will handle comments on blog posts.

=== Generating a Model 

Models in Rails use a singular name, and their corresponding database tables use a plural name. For the model to hold comments, the convention is to use the name Comment. Even if you don't want to use the entire apparatus set up by scaffolding, most Rails developers still use generators to make things like models and controllers. To create the new model, run this command in your terminal:

[source, shell]
-------------------------------------------------------
$ script/generate model Comment commenter:string body:text post:references
-------------------------------------------------------

This command will generate four files:

* +app/models/comment.rb+ - The model
* +db/migrate/20081013214407_create_comments.rb - The migration
* +test/unit/comment_test.rb+ and +test/fixtures/comments.yml+ - The test harness.

First, take a look at +comment.rb+:

[source, ruby]
-------------------------------------------------------
class Comment < ActiveRecord::Base
  belongs_to :post
end
-------------------------------------------------------

This is very similar to the +post.rb+ model that you saw earlier. The difference is the line +belongs_to :post+, which sets up an Active Record _association_. You'll learn a little about associations in the next section of this guide.

In addition to the model, Rails has also made a migration to create the corresponding database table:

[source, ruby]
-------------------------------------------------------
class CreateComments < ActiveRecord::Migration
  def self.up
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end
  end

  def self.down
    drop_table :comments
  end
end
-------------------------------------------------------

The +t.references+ line sets up a foreign key column for the association between the two models. Go ahead and run the migration:

[source, shell]
-------------------------------------------------------
$ rake db:migrate
-------------------------------------------------------

Rails is smart enough to only execute the migrations that have not already been run against this particular database.

=== Associating Models

Active Record associations let you easily declare the relationship between two models. In the case of comments and posts, you could write out the relationships this way:

* Each comment belongs to one post
* One post can have many comments

In fact, this is very close to the syntax that Rails uses to declare this association. You've already seen the line of code inside the Comment model that makes each comment belong to a Post:

[source, ruby]
-------------------------------------------------------
class Comment < ActiveRecord::Base
  belongs_to :post
end
-------------------------------------------------------

You'll need to edit the +post.rb+ file to add the other side of the association:

[source, ruby]
-------------------------------------------------------
class Post < ActiveRecord::Base
  validates_presence_of :name, :title
  validates_length_of :title, :minimum => 5
  has_many :comments
end
-------------------------------------------------------

These two declarations enable a good bit of automatic behavior. For example, if you have an instance variable +@post+ containing a post, you can retrieve all the comments belonging to that post as the array +@post.comments+.

TIP: For more information on Active Record associations, see the link:../association_basics.html[Active Record Associations] guide.

=== Adding a Route

_Routes_ are entries in the +config/routes.rb+ file that tell Rails how to match incoming HTTP requests to controller actions. Open up that file and find the existing line referring to +posts+. Then edit it as follows:

[source, ruby]
-------------------------------------------------------
map.resources :posts do |post|
  post.resources :comments
end
-------------------------------------------------------

This creates +comments+ as a _nested resource_ within +posts+. This is another part of capturing the hierarchical relationship that exists between posts and comments.

TIP: For more information on routing, see the link:../routing_outside_in.html[Rails Routing from the Outside In] guide.

=== Generating a Controller

With the model in hand, you can turn your attention to creating a matching controller. Again, there's a generator for this:

[source, shell]
-------------------------------------------------------
$ script/generate controller Comments index show new edit
-------------------------------------------------------

This creates seven files:

* +app/controllers/comments_controller.rb+ - The controller
* +app/helpers/comments_helper.rb+ - A view helper file
* +app/views/comments/index.html.erb+ - The view for the index action
* +app/views/comments/show.html.erb+ - The view for the show action
* +app/views/comments/new.html.erb+ - The view for the new action
* +app/views/comments/edit.html.erb+ - The view for the edit action
* +test/functional/comments_controller_test.rb+ - The functional tests for the controller

The controller will be generated with empty methods for each action that you specified in the call to +script/generate controller+:

[source, ruby]
-------------------------------------------------------
class CommentsController < ApplicationController
  def index
  end

  def show
  end

  def new
  end

  def edit
  end

end
-------------------------------------------------------

You'll need to flesh this out with code to actually process requests appropriately in each method. Here's a version that (for simplicity's sake) only responds to requests that require HTML:

[source, ruby]
-------------------------------------------------------
class CommentsController < ApplicationController
  def index
    @post = Post.find(params[:post_id])
    @comments = @post.comments
  end

  def show
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
  end

  def new
    @post = Post.find(params[:post_id])
    @comment = @post.comments.build
  end

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.build(params[:comment])
    if @comment.save
      redirect_to post_comment_url(@post, @comment)
    else
      render :action => "new"
    end
  end
  
  def edit
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
  end

  def update
    @post = Post.find(params[:post_id])
    @comment = Comment.find(params[:id])
    if @comment.update_attributes(params[:comment])
      redirect_to post_comment_url(@post, @comment)
    else
      render :action => "edit"
    end
  end
  
end
-------------------------------------------------------

You'll see a bit more complexity here than you did in the controller for posts. That's a side-effect of the nesting that you've set up; each request for a comment has to keep track of the post to which the comment is attached.

In addition, the code takes advantage of some of the methods available for an association. For example, in the +new+ method, it calls

[source, ruby]
-------------------------------------------------------
@comment = @post.comments.build
-------------------------------------------------------

This creates a new +Comment+ object _and_ sets up the +post_id+ field to have the +id+ from the specified +Post+ object in a single operation.

=== Building Views

Because you skipped scaffolding, you'll need to build views for comments "by hand." Invoking +script/generate controller+ will give you skeleton views, but they'll be devoid of actual content. Here's a first pass at fleshing out the comment views.

The +index.html.erb+ view:

[source, ruby]
-------------------------------------------------------
<h1>Comments for <%= @post.title %></h1>

<table>
  <tr>
    <th>Commenter</th>
    <th>Body</th>
  </tr>

<% for comment in @comments %>
  <tr>
    <td><%=h comment.commenter %></td>
    <td><%=h comment.body %></td>
    <td><%= link_to 'Show', post_comment_path(@post, comment) %></td>
    <td><%= link_to 'Edit', edit_post_comment_path(@post, comment) %></td>
    <td><%= link_to 'Destroy', post_comment_path(@post, comment), :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New comment', new_post_comment_path(@post) %>
<%= link_to 'Back to Post', @post %>
-------------------------------------------------------

The +new.html.erb+ view:

[source, ruby]
-------------------------------------------------------
<h1>New comment</h1>

<% form_for([@post, @comment]) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit "Create" %>
  </p>
<% end %>

<%= link_to 'Back', post_comments_path(@post) %>
-------------------------------------------------------

The +show.html.erb+ view:

[source, ruby]
-------------------------------------------------------
<h1>Comment on <%= @post.title %></h1>

<p>
  <b>Commenter:</b>
  <%=h @comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%=h @comment.body %>
</p>

<%= link_to 'Edit', edit_post_comment_path(@post, @comment) %> |
<%= link_to 'Back', post_comments_path(@post) %>
-------------------------------------------------------

The +edit.html.erb+ view:

[source, ruby]
-------------------------------------------------------
<h1>Editing comment</h1>

<% form_for([@post, @comment]) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit "Update" %>
  </p>
<% end %>

<%= link_to 'Show', post_comment_path(@post, @comment) %> |
<%= link_to 'Back', post_comments_path(@post) %>
-------------------------------------------------------

Again, the added complexity here (compared to the views you saw for managing comments) comes from the necessity of juggling a post and its comments at the same time.

=== Hooking Comments to Posts

As a final step, I'll modify the +show.html.erb+ view for a post to show the comments on that post, and to allow managing those comments:

[source, ruby]
-------------------------------------------------------
<p>
  <b>Name:</b>
  <%=h @post.name %>
</p>

<p>
  <b>Title:</b>
  <%=h @post.title %>
</p>

<p>
  <b>Content:</b>
  <%=h @post.content %>
</p>

<h2>Comments</h2>
<% @post.comments.each do |c| %>
	<p>
	  <b>Commenter:</b>
	  <%=h c.commenter %>
	</p>

	<p>
	  <b>Comment:</b>
	  <%=h c.body %>
	</p>
<% end %>

<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
<%= link_to 'Manage Comments', post_comments_path(@post) %>
-------------------------------------------------------

Note that each post has its own individual comments collection, accessible as +@post.comments+. That's a consequence of the declarative associations in the models. Path helpers such as +post_comments_path+ come from the nested route declaration in +config/routes.rb+.

== What's Next?

Now that you've seen your first Rails application, you should feel free to update it and experiment on your own. But you don't have to do everything without help. As you need assistance getting up and running with Rails, feel free to consult these support resources:

* The link:http://guides.rubyonrails.org/[Ruby On Rails guides]
* The link:http://groups.google.com/group/rubyonrails-talk[Ruby on Rails mailing list]
* The #rubyonrails channel on irc.freenode.net
* The link:http://wiki.rubyonrails.org/rails[Rails wiki]

Rails also comes with built-in help that you can generate using the rake command-line utility:

* Running +rake doc:guides+ will put a full copy of the Rails Guides in the +/doc/guides+ folder of your application. Open +/doc/guides/index.html+ in your web browser to explore the Guides.
* Running +rake doc:rails+ will put a full copy of the API documentation for Rails in the +/doc/api+ folder of your application. Open +/doc/api/index.html+ in your web browser to explore the API documentation.

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/2[Lighthouse ticket]

* November 3, 2008: Formatting patch from Dave Rothlisberger
* November 1, 2008: First approved version by link:../authors.html#mgunderloy[Mike Gunderloy]
* October 16, 2008: Revised based on feedback from Pratik Naik by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* October 13, 2008: First complete draft by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* October 12, 2008: More detail, rearrangement, editing by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* September 8, 2008: initial version by James Miller (not yet approved for publication)















