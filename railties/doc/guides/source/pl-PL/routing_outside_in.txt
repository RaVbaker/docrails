Routing w Railsach
=================================

Poniższy tekst to przewodnik po opcjach związanych z routingiem (routing) we frameworku Rails, z którymi spotykają użytkownicy. W oparciu o niego, będziesz mógł:
* Poznać i zrozimieć sens routingu
* Rozszyfrować kod pliku `routes.rb`
* Tworzyć własne drogi routingu (routes) w klasycznym stylu hash lub popularnym obecnie RESTful
* Rozpoznać jak droga routingu wskazuje do kontrolera i akcji.

== Podwójny cel routingu

Routing w Railsach jest to dwukierunkowy mechanizm - tak, jakby móc przerobić drzewa na papier, a potem z papieru z powrotem utworzyć drzewa. Dokładnie rzecz biorąc, drogi routingu łączą nadchodzące żądania HTTP z kodem w kontrolerach Twojej aplikacji i pomagają generować adresy URL bez konieczności ręcznego zapisania ich jako łańcuchy znaków.

=== Łączenie adresu URL z kodem

Silnik routingu wewnątrz Railsów jest to fragment kodu, który przekazuje żądanie HTTP do odpowiedniego fragmentu aplikacji. Gdy Twoja aplikacja otrzymuje żądanie, np.

-------------------------------------------------------
GET /patients/17
-------------------------------------------------------

najprawdopodobniej wykona akcję `show` dla kontrolera `patients`, wyświetlając informacje o pacjencie posiadającym ID równe 17.
 
=== Generowanie adresu URL z kodu źródłowego

Routing działa także w drugą stronę. Załóżmy, że Twoja aplikacja zawiera kod:

[source, ruby]
-------------------------------------------------------
@patient = Patient.find(17)
<%= link_to "Patient Record", patient_path(@patient) %>
-------------------------------------------------------

Mechanizm rutingu działa jako element tłumaczący ten kod na adres URL, np `http://example.com/patients/17`. Korzystając z routingu w ten sposób, możesz sprawisz, że Twoja aplikacja będzie bardziej niezawodna i łatwiejsza do zrozumienia niż w wypadku, gdybyś ręcznie wpisywał wszystkie linki URL.

NOTE:  Obiekt `Patient` musi być zadeklarowany jako zasób dostępny dla drogi nazwanej, by mógł zostać prawidłowo obsłużony przez ten kod.

== Krótki przegląd routes.rb

Za routing w Railsach odpowiadają dwa moduły: silnik routingu, który jest integralną częścią frameworku oraz plik `config/routes.rb`, zawierający definicje dróg routingu używanych w aplikacji. Poznanie dokładnej zawartości pliku `routes.rb` jest podstawowym celem tego przewodnika. Zanim jednak zagłębimy się w tym temacie, proponuję krótki przegląd pliku.

=== Przetwarzanie pliku

Pod względem formatu, `routes.rb` jest po prostu dużym blokiem wysłanym do `ActionController::Routing::Routes.draw`. Wewnątrz tego bloku możesz umieszczać komentarze, jednak najprawdopodobniej większość jego zawartości to pojedyncze linie kodu - każda z nich odpowiada za drogę routingu w aplikacji. W pliku tym można znaleźć pięć podstawowych typów zawartości:

* drogi RESTful
* drogi nazwane
* drogi zagnieżdżone
* drogi regularne
* drogi domyślne

Każdą z nich omówimy dokładniej w dalszej części tego przewodnika.

W momencie nadejścia żądania, plik `routes.rb jest przetwarzany w kolejności "z góry na dół". W momencie odnalezienia pierwszego pasującego wpisu, żądanie zostaje przekazane przez powiązaną z nim drogę do odpowiedniego kontrolera.W przypadku, gdy w pliku nie będzie żadnej pasującej do żądania drogi routingu, Railsy zwrócą status 404.

=== Drogi RESTful

Drogi RESTful korzystają z wbudowanej w Rails orientacji REST, by umożliwić zapisanie jak najwięcej informacji routingu w jednej deklaracji. Ścieżka RESTful wygląda tak:

[source, ruby]
-------------------------------------------------------
map.resources :books
-------------------------------------------------------

=== Drogi nazwane

Drogi nazwane dają bardzo czytelne linki w kodzie źródłowym. Poniżej przedstawiona została typowa droga nazwana:

[source, ruby]
-------------------------------------------------------
map.login '/login', :controller => 'sessions', :action => 'new'
-------------------------------------------------------

=== Drogi zagnieżdżone

Drogi zagnieżdżone umożliwiają deklarację ścieżki do zasobu zawartego wewnątrz innego zasobu. Później zobaczysz jak taka droga umożliwia tłumaczenie kodu na adresy i ścieżki dostępu. Na przykład, jeśli aplikacja składa się z kilku części, a każda z nich należy do pewnej grupy, możesz stosować zagnieżdżoną drogę routingu:

[source, ruby]
-------------------------------------------------------
map.resources :assemblies do |assemblies|
  assemblies.resources :parts
end
-------------------------------------------------------

=== Drogi regularne

W wielu aplikacjach spotkasz się także z niezgodnym z założeniami REST routingiem, który wskazuje wprost powiązanie fragmentów URL z konkretną akcją. Przykład ścieżki regularnej to:

[source, ruby]
-------------------------------------------------------
map.connect 'parts/:number', :controller => 'inventory', :action => 'show'
-------------------------------------------------------

=== Drogi domyślne

Domyślne drogi routingu są siecią zabezpieczeń, obsługującą żądania które nie pasowały do żadnej innej drogi. Wiele aplikacji Railsowych zawiera taką parę ścieżek domyślnych: 

[source, ruby]
-------------------------------------------------------
map.connect ':controller/:action/:id'
map.connect ':controller/:action/:id.:format'
-------------------------------------------------------

Te drogi routingu są automatycznie generowane podczas tworzenia nowej aplikacji Railsowej. Jeśli cała Twoja aplikacja jest korzysta z routingu RESTful, prawdopodobnie będziesz chciał je usunąć. Zanim jednak to zrobisz, upewnij się, że nie są one nigdy używane!

== Routing RESTful: domyślny routing Railsów

Routing RESTful jest obecnie standardowy w Railsach i to jego powinieneś preferować tworząc nowe aplikacje. Zrozumienie jak działa routing RESTful może wydawać się trochę trudne, jednak na pewno się opłaca; dzięki niemu Twój kod będzie dużo bardziej czytelny, a Twoja praca w końcu przestanie wyglądać jak walczenie z frameworkiem.

=== Czym jest REST?

Założenia routingu REST pochodzą z pracy doktorskiej Roy'a Fielding'a: link:http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm[Architectural Styles and the Design of Network-based Software Architectures]. Na szczęście nie musisz czytać całego dokumentu, by zrozumieć ideę REST w Railsach. REST jest to skrót od angielskiej nazwy "Representational State Transfer", czyli Reprezentacyjny Transfer Stanu. Sprowadza się on do dwóch głównych założeń:

* używanie identyfikatorów zasobów (dla celów tego przewodnika możesz je utożsamiać z URL) do ich reprezentacji
* transferowanie reprezentacji stanów każdego zasobu pomiędzy elementami systemu.

Na przykład, żądanie takie jak:

`DELETE /photos/17`

będzie odczytane przez aplikację Railsową jako odniesienie do zasobu będącego zdjęciem o ID równym 17, a akcją wymaganą przez takie żądanie będzie wskazanego usunięcie zasobu. REST jest naturalnym stylem architektury aplikacji sieciowej, a Rails czyni go jeszcze bardziej przyjaznym dzięki konwencjom upraszczającym jego stosowanie.
  
=== CRUD, typy żądań i akcje

W Railsach, droga routingu RESTful łączy żądanie HTTP, akcję kontrolera i, pośrednio, operację CRUD na bazie danych. Pojedynczy wpis do pliku routingu, taki jak:

[source, ruby]
-------------------------------------------------------
map.resources :photos
-------------------------------------------------------

tworzy siedem różnych dróg routingu w aplikacji:

[options="header"]
|==========================================================================================================
|żądanie HTTP |URL             |kontroler |akcja    |cel użycia
|GET          |/photos         |Photos    |index    |wyświetlenie listy wszystkich zdjęć
|GET          |/photos/new     |Photos    |new      |zwrócenie formularza HTML do tworzenia zdjęcia
|POST         |/photos         |Photos    |create   |tworzenie nowego zdjęcia
|GET          |/photos/1       |Photos    |show     |wyświetlenie konkretnego zdjęcia
|GET          |/photos/1/edit  |Photos    |edit     |zwrócenie formularza HTML do edycji zdjęcia
|PUT          |/photos/1       |Photos    |update   |aktualizacja konkretnego zdjęcia
|DELETE       |/photos/1       |Photos    |destroy  |usunięcie konkretnego zdjęcia
|==========================================================================================================

Dla dróg routingu odnoszących się do jednego konkretnego zasobu, identyfikator zasobu będzie dostępny dla akcji odpowiedniego kontrolera jako parametr `params[:id]`.

TIP: Jeśli stale używasz dróg RESTful, powinieneś wyłączyć drogi domyślne w pliku `routes.rb`, aby Railsy wymusiły routowanie oparte na typach żądań.

=== Adresy URL i ścieżki dostępu

Stworzenie drogi routingu RESTful powoduje także udostępnienie kilku helperów wewnątrz aplikacji:

* `photos_url` i `photos_path` wskazują ścieżki dostępu do akcji `index` i `create`
* `new_photo_url` i `new_photo_path` wskazują ścieżkę dostępu do akcji `new`
* `edit_photo_url` i `edit_photo_path` wskazują ścieżkę dostępu do akcji `edit`
* `photo_url`  i `photo_path` wskazują ścieżki dostępu do akcji `show`, `update` i `destroy`

NOTE: Ponieważ routing opiera się zarówno na typach żądań HTTP jak i na ścieżkach dostępu w nich zawartych, siedem dróg routingu wymaga określenia tylko czterech par helperów.

W każdym przypadku, helper `_url` generuje łańcuch znaków zawierający pełny adres URL jaki będzie zrozumiały dla aplikacji, a `_path` - łańcuch zawierający ścieżkę dostępu odnoszącą się do katalogu głównego aplikacji. Na przykład:

[source, ruby]
-------------------------------------------------------
photos_url  # => "http://www.example.com/photos"
photos_path # => "/photos"
-------------------------------------------------------

=== Definiowanie kilku zasobów jednocześnie

Jeśli chcesz utworzyć drogi routingu do więcej niż jednego zasobu RESTful, możesz zaoszczędzić dużo kodu definiując je wewnątrz jednego odwołania do `map.resources`:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :books, :videos
-------------------------------------------------------

Taki zapis jest równoważny z poniższym:

[source, ruby]
-------------------------------------------------------
map.resources :photos
map.resources :books
map.resources :videos
-------------------------------------------------------

=== Pojedyncze zasoby

Możesz także zastosować routing RESTful do pojedynczego zasobu wewnątrz aplikacji. W tym przypadku zamiast `map.resources`, użyj `map.resource`, a generowane drogi routingu będą troszkę inne. Na przykład, wpis routingu:

[source, ruby]
-------------------------------------------------------
map.resource :geocoder
-------------------------------------------------------

stworzy sześć dróg routingu w aplikacji:

[options="header"]
|==========================================================================================================
|żądanie HTTP |URL             |kontroler |akcja    |cel użycia
|GET          |/geocoder/new   |Geocoders |new      |zwrócenie formularza HTML do tworzenia geokodera
|POST         |/geocoder       |Geocoders |create   |tworzenie nowego geokodera
|GET          |/geocoder       |Geocoders |show     |wyświetlenie jednego jedynego geokodera
|GET          |/geocoder/edit  |Geocoders |edit     |zwrócenie formularza HTML do edycji geokodera
|PUT          |/geocoder       |Geocoders |update   |akrualizacja geokodera
|DELETE       |/geocoder       |Geocoders |destroy  |usunięcie geokodera
|==========================================================================================================

NOTE: Pomimo, ze nazwa zasobu jest w liczbie pojedynczej, (Geocoder), odpowiadający za nią kontroler ma nazwę w liczbie mnogiej (Geocoders).

Pojedyncza ścieżka routingu RESTful generuje zmniejszony zestaw helperów:

* `new_geocoder_url` i `new_geocoder_path` wskazują ścieżkę dostępu do akcji `new`
* `edit_geocoder_url` i `edit_geocoder_path` wskazują ścieżkę dostępu do akcji `edit`
* `geocoder_url` i `geocoder_path` wskazują ścieżki dostępu do akcji `create`, `show`, `update` i `destroy`

=== Dopasowanie zasobów

Chociaż konwencje routingu RESTful są wystarczające dla większości aplikacji, można jednak dopasować do własnych potrzeb wiele aspektów jego działania. Służą do tego następujące opcje:

* `:controller`
* `:singular`
* `:requirements`
* `:conditions`
* `:as`
* `:path_names`
* `:path_prefix`
* `:name_prefix`
* `:only`
* `:except`

Możesz także tworzyć dodatkowe ścieżki routingu przy pomocy opcji `:member` i `:collection`, które zostaną omówione w dalszej części tego przewodnika.

==== Użycie :controller

Opcja `:controller` pozwala użyć kontrolera o innej nazwie niż dostępna od zewnątrz nazwa zasobu. Na przykład, wpis:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :controller => "images"
-------------------------------------------------------

rozpozna przychodzące żądania zawierające `photo`, lecz skieruje je do kontrolera `Images`: 

[options="header"]
|==========================================================================================================
|żądanie HTTP |URL             |kontroler |akcja    |cel użycia
|GET          |/photos         |Images    |index    |wyświetlenie listy wszystkich zdjęć
|GET          |/photos/new     |Images    |new      |zwrócenie formularza HTML do tworzenia zdjęcia
|POST         |/photos         |Images    |create   |tworzenie nowego zdjęcia
|GET          |/photos/1       |Images    |show     |wyświetlenie konkretnego zdjęcia
|GET          |/photos/1/edit  |Images    |edit     |zwrócenie formularza HTML do edycji zdjęcia
|PUT          |/photos/1       |Images    |update   |aktualizacja konkretnego zdjęcia
|DELETE       |/photos/1       |Images    |destroy  |usunięcie konkretnego zdjęcia
|==========================================================================================================

NOTE: Wygenerowane helpery będą zawierały nazwę zasobu, a nie kontrolera. W powyższym przykładzie nadal otrzymamy helpery takie jak `photos_path`, `new_photo_path` itd.

=== Routing a przestrzenie nazw kontrolerów ===

Railsy pozwalają na grupowanie kontrolerów w przestrzenie nazw (namespaces) poprzez umieszczenie ich w podfolderach `app/controllers`. Opcja `:controller` umożliwia wygodny routing do takich kontrolerów. Na przykład, możesz posiadać zasób, którego kontroler służy jedynie do celów administracyjnych, umieszczony w podkatalogu `admin`:

[source, ruby]
-------------------------------------------------------
map.resources :adminphotos, :controller => "admin/photos"
-------------------------------------------------------

Jeśli grupujesz w ten sposób kontrolery, zwróc uwagę na pewien niuans routingu: Railsy zawsze starają się znaleźć zasób najbardziej zbliżony do tego, którego użyły w poprzednim żądaniu. Na przykład, jeśli oglądasz obecnie widok wygenerowany przez helper `adminphoto_path` i klikniesz w link wygenerowany kodem `<%= link_to "show", adminphoto(1) %>`, zostaniesz przekierowany do widoku wygenerowanego przez `admin/photos/show`, ale w to samo miejsce przekieruje Cię także link `<%= link_to "show", {:controller => "photos", :action => "show"} %>`, ponieważ Railsy wygenerują URL nawiązujący do obecnego adresu URL.

TIP: Aby zapewnić, że link wskazuje na kontroler najwyższego poziomu, poprzedź nazwę kontrolera ukośnikiem: `<%= link_to "show", {:controller => "/photos", :action => "show"} %>`

Możesz także określić przestrzeń nazw kontrolera używając opcji `:namespace' zamiast podawać ścieżkę dostępu:

[source, ruby]
-------------------------------------------------------
map.resources :adminphotos, :namespace => "admin", :controller => "photos"
-------------------------------------------------------

Może to być szczególnie przydatne, jeśli połączymy to zastosowanie z `with_options` w celu połączenia kilku dróg routingu naraz:

[source, ruby]
-------------------------------------------------------
map.with_options(:namespace => "admin") do |admin|
  admin.resources :photos, :videos
end
-------------------------------------------------------

Taki zapis zapewni routing dla kontrolerów `admin/photos` i `admin/videos`.

==== Użycie :singular

Jeśli z jakiegoś powodu Railsy nie radzą sobie prawidłowo z utworzeniem nazwy pojedynczej pochodzącej od nazwy w liczbie mnogiej, możesz wymusić zmianę tej nazwy korzystając z opcji `:singular`:

[source, ruby]
-------------------------------------------------------
map.resources :teeth, :singular => "tooth"
-------------------------------------------------------

TIP: W zależności od reszty aplikacji, możesz zamiast tego stworzyć dodatkowe reguły dla klasy `Inflector`.

==== Użycie :requirements

Możesz użyć opcji `:requirements` w drodze routingu RESTful, by wymusić odpowiednie formatowanie parametru `:id` w pojedynczych ścieżkach routingu. Na przykład:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :requirements => {:id => /[A-Z][A-Z][0-9]+/}
-------------------------------------------------------

Ta deklaracja spowoduje, że parametr `:id` będzie musiał być zgodny z podanym wyrażeniem regularnym. W tym przypadku, żądanie `/photos/1` nie będzie dłużej pasowało do tej drogi routingu, ale np. `photos/RR27' będzie.

==== Użycie :conditions

Ten parametr jest obecnie używany tylko dla ustawienia typu żądań HTTP dotyczących indywidualnych ścieżek routingu. W teorii możesz ustawić go dla ścieżek RESTful, ale w praktyce nie ma to większego sensu. (Więcej o warunku `:conditions` dowiesz się z rozdziału dotyczącego klasycznego routingu w tym przewodniku.)

==== Użycie :as

Opcja `:as` pozwala nadpisać domyślną nazwę dla tworzonych ścieżek dostępu. Przykładowo, wpis:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :as => "images"
-------------------------------------------------------

rozpozna nadchodzące żądanie zawierające w URL słowo `image`, ale ścieżka routingu skieruje je do kontrolera Photos:

[options="header"]
|==========================================================================================================
|żądanie HTTP |URL             |kontroler |akcja    |cel użycia
|GET          |/images         |Photos    |index    |wyświetlenie listy wszystkich zdjęć
|GET          |/images/new     |Photos    |new      |zwrócenie formularza HTML do tworzenia zdjęcia
|POST         |/images         |Photos    |create   |tworzenie nowego zdjęcia
|GET          |/images/1       |Photos    |show     |wyświetlenie konkretnego zdjęcia
|GET          |/images/1/edit  |Photos    |edit     |zwrócenie formularza HTML do edycji zdjęcia
|PUT          |/images/1       |Photos    |update   |aktualizacja konkretnego zdjęcia
|DELETE       |/images/1       |Photos    |destroy  |usunięcie konkretnego zdjęcia
|==========================================================================================================

NOTE: Wygenerowane helpery będą zawierały nazwę zasobu, a nie ścieżki dostępu. W powyższym przykładzie nadal otrzymamy helpery takie jak `photos_path`, `new_photo_path` itd.

==== Użycie :path_names

Opcja `:path_names` pozwala nadpisać domyślne elementy `new` i `edit` w adresie URL:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :path_names => { :new => 'make', :edit => 'change' }
-------------------------------------------------------

Taki zapis spowoduje, że routing Railsów rozpozna URL takie jak:

-------------------------------------------------------
/photos/make
/photos/1/change
-------------------------------------------------------

NOTE: Rzeczywista nazwa akcji nie ulegnie zmianie; drogi routingu nadal będą prowadziły do akcji `new` i `edit`. 

TIP: Jeśli zechcesz zmienić tą opcją wszystkie drogi, możesz ustawić ją jako domyślną dla środowiska:

[source, ruby]
-------------------------------------------------------
config.action_controller.resources_path_names = { :new => 'make', :edit => 'change' }
-------------------------------------------------------

==== Użycie :path_prefix

Opcja `:path_prefix` pozwala umieścić dodatkowe parametry, by były zawarte w prefiksie pasującej ścieżki dostępu. Załóżmy na przykład, że każde zdjęcie zawarte w aplikacji jest przypisane do konkretnego autora. W tej sytuacji, możesz zadeklarować następującą ścieżkę routingu:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :path_prefix => '/photographers/:photographer_id'
-------------------------------------------------------

Do ścieżek pasujących do tego wpisu będą należały między innymi:

-------------------------------------------------------
/photographers/1/photos/2
/photographers/1/photos
-------------------------------------------------------

NOTE: W większości przypadków, łatwiej jest rozpoznawać takie URL poprzez stworzenie zagnieżdżonych zasobów, jak zostało to opisane w następnym rozdziale.

NOTE: Możesz też użyć opcji `:path_prefix` dla dróg routingu innych niż RESTful.

==== Użycie :name_prefix

Możesz użyć opcji `name_prefix` by zapobiec kolizji wpisów. Funkcja staje się bardzo użyteczna, gdy masz dwa zasoby o tej samej nazwie, które dzięki użyciu `:path_prefix` będą routowane inaczej. Na przykład:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :path_prefix => '/photographers/:photographer_id', :name_prefix => 'photographer_'
map.resources :photos, :path_prefix => '/agencies/:agency_id', :name_prefix => 'agency_'
-------------------------------------------------------

Taka kombinacja utworzy helpery takie jak `photographer_photos_path` i `agency_edit_photo_path`.

NOTE: Możesz też użyć opcji `:name_prefix` dla dróg routingu innych niż RESTful.

==== Użycie :only i :except

Railsy tworzą drogi routingu dla wszystkich siedmiu domyślnych akcji (`index`, `show`, `new`, `create`, `edit`, `update` i `destroy`) dla każdej drogi RESTful. Możesz użyć opcji `:only` i `:except`, by dopasować to zachowanie. Opcja `:only` wymusza wykonanie tylko wskazanych ścieżek routingu:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :only => [:index, :show]
-------------------------------------------------------

Przy takim wpisie, żądanie `GET` odnoszące się do zasobu `/photos` zostanie obsłużone, ale żądanie `POST` dla `/photos` (normalnie wskazujące na akcję `create`) już nie.

Opcja `:except` jest odwrotnością `:only` - wskazuje ona na akcje, które _nie zostaną_ obsłużone przez wpis:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :except => :destroy
-------------------------------------------------------

W tym przypadku, zostaną utworzone wszystkie normalne drogi routingu oprócz tej obsługującej akcję `destroy` (żądanie `DELETE` odnoszące się do zasobu `photos/_id_`).

Poza nazwami akcji, możesz także użyć dla opcji `:only` i `:except` specjalnych symboli, takich jak: `:all` i `:none`.

TIP: Jeśli w aplikacji występuje dużo dróg RESTful, użycie opcji `:only` i `:except`, by wygenerować tylko potrzebne ścieżki, może znacząco obniżyć zużycie pamięci i przyspieszyć proces routingu.

=== Zasoby zagnieżdżone

Częstym przypadkiem są zasoby logicznie przypisane do innych zasobów. Załóżmy na przykład, że aplikacja zawiera modele:

[source, ruby]
-------------------------------------------------------
class Magazine < ActiveRecord::Base
  has_many :ads
end

class Ad < ActiveRecord::Base
  belongs_to :magazine
end
-------------------------------------------------------

Każdy obiekt `ad` logicznie służy do obsługi jednego obiektu `magazine`. Drogi zagnieżdżone pozwalają zachować tę zależność podczas routingu. W tym przypadku, możesz użyć następującej deklaracji routingu:

[source, ruby]
-------------------------------------------------------
map.resources :magazines do |magazine|
  magazine.resources :ads
end 
-------------------------------------------------------

Poza drogami routingu do obiektów `magazine`, ta deklaracja stworzy także drogi do obiektów `ad`. Każda z nich będzie wymagała określenia w URL do którego obiektu `magazine` się odnosi:

[options="header"]
|==========================================================================================================
|żądanie HTTP |URL                      |kontroler |akcja    |cel użycia
|GET          |/magazines/1/ads         |Ads       |index    |wyświetlenie listy wszystkich `ad` dla wskazanego obiektu `magazine`
|GET          |/magazines/1/ads/new     |Ads       |new      |zwrócenie formularza HTML do tworzenia obiektu `ad` należącego do wskazanego obiektu `magazine`
|POST         |/magazines/1/ads         |Ads       |create   |tworzenie nowego obiektu `ad` należącego do wskazanego obiektu `magazine`
|GET          |/magazines/1/ads/1       |Ads       |show     |wyświetlenie konkretnego obiektu `ad` należącego do wskazanego obiektu `magazine`
|GET          |/magazines/1/ads/1/edit  |Ads       |edit     |zwrócenie formularza HTML do edycji obiektu `ad` należącego do wskazanego obiekty `magazine`
|PUT          |/magazines/1/ads/1       |Ads       |update   |aktualizacja konkretnego obiektu `ad` należącego do wskazanego obiektu `magazine`
|DELETE       |/magazines/1/ads/1       |Ads       |destroy  |usunięcie konkretnego obiektu `ad` należącego do wskazanego obiektu `magazine`
|==========================================================================================================

Wpis ten stworzy także helpery, takie jak `magazine_ads_url` i `edit_magazine_ad_path`.

==== Użycie :name_prefix

Opcja `:name_prefix` nadpisuje automatycznie generowany prefiks w helperach dla zagnieżdżonych ścieżek routingu, na przykład:

[source, ruby]
-------------------------------------------------------
map.resources :magazines do |magazine|
  magazine.resources :ads, :name_prefix => 'periodical'
end 
-------------------------------------------------------

Stworzy to helpery takie jak `periodical_ads_url` i `periodical_edit_ad_path`. Możesz nawet użyć `:name_prefix` by całkowicie usunąć prefiksy:

[source, ruby]
-------------------------------------------------------
map.resources :magazines do |magazine|
  magazine.resources :ads, :name_prefix => nil
end 
-------------------------------------------------------

Spowoduje to utworzenie helperów `ads_url` i `edit_ad_path`. Zwróć uwagę na fakt, że dodanie identyfikatora nadal będzie wymagane przy użyciu helperów:

[source, ruby]
-------------------------------------------------------
ads_url(@magazine)
edit_ad_path(@magazine, @ad)
-------------------------------------------------------

==== Użycie :has_one and :has_many

Opcje `:has_one` i `:has_many` umożliwiają zwięzłą notację prostych dróg zagnieżdżonych. Używamy `:has_one` dla zagnieżdżenia pojedynczego zasobu lub `:has_many` dla wielu zasobów:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :has_one => :photographer, :has_many => [:publications, :versions]
-------------------------------------------------------

Spowoduje to ten sam efekt co wpisanie całego zestawu deklaracji:

[source, ruby]
-------------------------------------------------------
map.resources :photos do |photo|
  photo.resource :photographer
  photo.resources :publications
  photo.resources :versions
end
-------------------------------------------------------
 
==== Ograniczenia zagnieżdżenia

Możesz zagnieździć zasoby wewnątrz innych zagnieżdżonych zasobów. Na przykład:

[source, ruby]
-------------------------------------------------------
map.resources :publishers do |publisher|
  publisher.resources :magazines do |magazine|
    magazine.resources :photos
  end
end
-------------------------------------------------------

Jeśli jednak nie użyjesz opcji `name_prefix => nil`, wielokrotnie zagnieżdżone zasoby staną się bardzo niewygodne w użyciu. Dla tego przykładu, aplikacja poprawnie obsługiwałaby URL takie jak:

-------------------------------------------------------
/publishers/1/magazines/2/photos/3
-------------------------------------------------------

Odpowiedni helper miałby postać `publisher_magazine_photo_url`, co wymagałoby określania trzech poziomów obiektów. W praktyce jest to na tyle niewygodne i mylące rozwiązanie, że popularny link:link:http://weblog.jamisbuck.org/2007/2/5/nesting-resources[artykuł] autorstwa Jamisa Bucka wprowadza regułę szeroko stosowaną przy projektowaniu z wykorzystaniem frameworku Rails:

_Zasoby nie powinny być nigdy zagnieżdżone na więcej niż jednym poziomie._

==== Płytkie zagnieżdżenie

Opcja `:shallow` oferuje eleganckie rozwiązanie problemów z głęboko zagnieżdżonymi drogami routingu. Jeśli użyjesz jej na dowolnym poziomie routingu, ścieżki dostępu do zagnieżdżonych zasobów odnoszące się do konkretnego elementu (tzn. takiego, który posiada parametr `:id`) nie będą posiadały obiektu nadrzędnego w prefiksie. Aby lepiej to wyjaśnić posłużę się przykładem:

[source, ruby]
-------------------------------------------------------
map.resources :publishers, :shallow => true do |publisher|
  publisher.resources :magazines do |magazine|
    magazine.resources :photos
  end
end
-------------------------------------------------------

Ten wpis umożliwi rozpoznanie m.in. takich dróg routingu:

-------------------------------------------------------
/publishers/1           ==> publisher_path(1)
/publishers/1/magazines ==> publisher_magazines_path(1)
/magazines/2            ==> magazine_path(2)
/magazines/2/photos     ==> magazines_photos_path(2)
/photos/3               ==> photo_path(3)
-------------------------------------------------------

Przy płytkim zagnieżdżeniu, wystarczy podać minimalną liczbę informacji potrzebną do jednoznaczej identyfikacji zasobu, by móc na nim pracować. Jeśli chcesz, możesz łączyć płytkie zagnieżdżenie z opcjami `:has_one` i `:has_many`:

[source, ruby]
-------------------------------------------------------
map.resources :publishers, :has_many => { :magazines => :photos }, :shallow => true
-------------------------------------------------------

=== Generowanie drogi routingu z tablic

Oprócz helperów routingu, Railsy mogą też generować drogi RESTful z tablicy parametrów. Załóżmy na przykład, że masz zestaw dróg routingu wygenerowanych na podstawie następujących wpisów w pliku routes.rb:

[source, ruby]
-------------------------------------------------------
map.resources :magazines do |magazine|
  magazine.resources :ads
end
-------------------------------------------------------

Railsy wygenerują helpery takie jak `magazine_ad_path`, które mogą służyć do tworzenia linków:

[source, ruby]
-------------------------------------------------------
<%= link_to "Ad details", magazine_ad_path(@magazine, @ad) %>
-------------------------------------------------------

Inny sposobem odniesienia się do tej drogi routingu jest tablica obiektów:

[source, ruby]
-------------------------------------------------------
<%= link_to "Ad details", [@magazine, @ad] %>
-------------------------------------------------------

Ten format jest bardzo wygodny, gdy nie wiesz z góry jaki typów obiektu będzie użyty w danym linku.
 
=== Zasoby z przestrzenią nazw

Łącząc opcje `:path_prefix` i `:name_prefix` możesz osiągnąć dosyć skomplikowane struktury. Na przykład, możesz użyć takiej kombinacji by przenieść zasoby administracyjne do oddzielnego katalogu w aplikacji:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :path_prefix => 'admin', :controller => 'admin/photos'
map.resources :tags, :name_prefix => 'admin_photo_', :path_prefix => 'admin/photos/:photo_id', :controller => 'admin/photo_tags'
map.resources :ratings, :name_prefix => 'admin_photo_', :path_prefix => 'admin/photos/:photo_id', :controller => 'admin/photo_ratings'
-------------------------------------------------------

Dobrą wiadomością jest, że jeśli Twój kod okaże się zbyt rozbudowany, możesz go uprościć. Railsy umożliwiają dzielenie zasobów na _przestrzenie nazw_, aby ułatwić ich rozmieszczenie we własnych katalogach. Oto te same trzy drogi routingu stworzone z wykorzystaniem przestrzeni nazw:

[source, ruby]
-------------------------------------------------------
map.namespace(:admin) do |admin|
	admin.resources :photos,
	  :has_many => { :tags, :ratings}
end
-------------------------------------------------------

Jak widzisz, taka wersja jest znacznie zwięźlejsza, a mimo tego daje takie same efekty. Uzyskasz te same helpery, np. `admin_photos_url`, korzystający z kontrolera `Admin::PhotosController` i wskazujący na `admin/photos` oraz `admin_photos_ratings_path`, wskazujący na `admin/photos/_photo_id_/ratings` i korzystający z `Admin::RatingsController`. Nawet jeśli nie zdefiniujesz bezpośrednio prefiksu `path_prefix`, wpis routingu spowoduje automatycznie wyliczenie poprawnego prefiksu dla drogi zagnieżdżonej.

=== Dodawanie większej liczby akcji RESTful

Nie jesteś ograniczony do siedmiu domyślnie tworzonych dróg routingu. Jeśli chcesz możesz dodawać kolejne drogi członkowskie (odnoszące się do konkretnego zasobu), a także drogi tworzące zasoby oraz drogi odnoszące się do zestawu zasobów jako całości.

==== Dodawanie dróg członkowskich

Aby dodać drogę członkowską, użyj opcji `:member`:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :member => { :preview => :get }
-------------------------------------------------------

Umożliwi to Railsom rozpoznanie adresów URL takich jak `/photos/1/preview` przy żądaniu HTTP GET i przekazanie ich do akcji `preview` kontrolera `Photos`. Stworzy to także helper `preview_photo`.

Wewnątrz tablicy dróg członkowskich, każda z nich określa typ żądania HTTP, jak będzie rozpoznawać. Do dyspozycji mamy `:get`, `:put`, `:post`, `:delete` lub `:any`. Możesz także określić tablicę metod, jeśli potrzebujesz więcej niż jedną, ale nie chcesz dopuścić dowolnej:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :member => { :prepare => [:get, :post] }
-------------------------------------------------------

==== Dodawanie dróg do zestawu zasobów

Aby dodać drogę odnoszącą się do zestawu zasobów jako całości, wykorzystywana jest opcja `:collection`:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :collection => { :search => :get }
-------------------------------------------------------

Taki wpis pozwoli Railsom rozpoznać URL taki jak `/photos/search` wykorzystujący żądanie HTTP GET i skierować go do akcji `search` kontrolera `Photos`. Dodatkowo, stworzony zostanie helper `search_photos`.

Tak jak przy drogach członkowskich, możesz określić tablicę metod dostępnych dla drogi do zestawu zasobów:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :collection => { :search => [:get, :post] }
-------------------------------------------------------

==== Dodawanie dróg tworzących zasoby

Aby dodać nową drogę tworzącą zasoby, używamy opcji `:new`:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :new => { :upload => :post }
-------------------------------------------------------

Taki wpis sprawi, że Railsy rozpoznają URL takie jak `/photos/upload` wykorzystujące żądanie HTTP POST i skieruje je do akcji `upload` kontrolera `Photos`. Stworzony zostanie także helper `upload_photos`.

TIP: Jeśli chcesz przedefiniować typ żądania akceptowanego przez jedną ze standardowych akcji, możesz to zrobić wprost poprzez wskazanie tej akcji, np:

[source, ruby]
-------------------------------------------------------
map.resources :photos, :new => { :new => :any }
-------------------------------------------------------

Dzięki temu akcja `new` będzie mogła być wywołana przez żądanie odnoszące się do `photos/new`, niezależnie od typu tego żądania.

==== Uwaga końcowa

Jeśli okaże się, że tworzysz zbyt wiele dodatkowych akcji dla drogi RESTful, czas zastanowić się dlaczego nie chcesz uznać potrzeby stworzenia nowego zasobu, który mógłby przejąć te żądania. W momencie, gdy kolejne opcje `:member` i `:collection` zaczynają tworzyć wielkie śmietnisko, routing RESTful traci swoją najważniejszą zaletę, jaką jest czytelność kodu.

== Regular Routes

In addition to RESTful routing, Rails supports regular routing - a way to map URLs to controllers and actions. With regular routing, you don't get the masses of routes automatically generated by RESTful routing. Instead, you must set up each route within your application separately.

While RESTful routing has become the Rails standard, there are still plenty of places where the simpler regular routing works fine. You can even mix the two styles within a single application. In general, you should prefer RESTful routing _when possible_, because it will make parts of your application easier to write. But there's no need to try to shoehorn every last piece of your application into a RESTful framework if that's not a good fit. 

=== Bound Parameters

When you set up a regular route, you supply a series of symbols that Rails maps to parts of an incoming HTTP request. Two of these symbols are special: +:controller+ maps to the name of a controller in your application, and +:action+ maps to the name of an action within that controller. For example, consider one of the default Rails routes:

[source, ruby]
-------------------------------------------------------
map.connect ':controller/:action/:id'
-------------------------------------------------------

If an incoming request of +/photos/show/1+ is processed by this route (because it hasn't matched any previous route in the file), then the result will be to invoke the +show+ action of the +Photos+ controller, and to make the final parameter (1) available as +params[:id]+.

=== Wildcard Components

You can set up as many wildcard symbols within a regular route as you like. Anything other than +:controller+ or +:action+ will be available to the matching action as part of the params hash. So, if you set up this route:

[source, ruby]
-------------------------------------------------------
map.connect ':controller/:action/:id/:user_id'
-------------------------------------------------------

An incoming URL of +/photos/show/1/2+ will be dispatched to the +show+ action of the +Photos+ controller. +params[:id]+ will be set to 1, and +params[:user_id]+ will be set to 2.

=== Static Text

You can specify static text when creating a route. In this case, the static text is used only for matching the incoming requests:

[source, ruby]
-------------------------------------------------------
map.connect ':controller/:action/:id/with_user/:user_id'
-------------------------------------------------------

This route would respond to URLs such as +/photos/show/1/with_user/2+.

=== Querystring Parameters

Rails routing automatically picks up querystring parameters and makes them available in the +params+ hash. For example, with this route:

[source, ruby]
-------------------------------------------------------
map.connect ':controller/:action/:id'
-------------------------------------------------------

An incoming URL of +/photos/show/1?user_id=2+ will be dispatched to the +show+ action of the +Photos+ controller. +params[:id]+ will be set to 1, and +params[:user_id]+ will be equal to 2.

=== Defining Defaults

You do not need to explicitly use the +:controller+ and +:action+ symbols within a route. You can supply defaults for these two parameters in a hash:

[source, ruby]
-------------------------------------------------------
map.connect 'photos/:id', :controller => 'photos', :action => 'show'
-------------------------------------------------------

With this route, an incoming URL of +/photos/12+ would be dispatched to the +show+ action within the +Photos+ controller.

You an also define other defaults in a route by supplying a hash for the +:defaults+ option. This even applies to parameters that are not explicitly defined elsewhere in the route. For example:

[source, ruby]
-------------------------------------------------------
map.connect 'photos/:id', :controller => 'photos', :action => 'show', :defaults => { :format => 'jpg' }
-------------------------------------------------------

With this route, an incoming URL of +photos/12+ would be dispatched to the +show+ action within the +Photos+ controller, and +params[:format]+ will be set to +jpg+.

=== Named Routes

Regular routes need not use the +connect+ method. You can use any other name here to create a _named route_. For example,

[source, ruby]
-------------------------------------------------------
map.logout '/logout', :controller => 'sessions', :action => 'destroy'
-------------------------------------------------------

This will do two things. First, requests to +/logout+ will be sent to the +destroy+ method of the +Sessions+ controller. Second, Rails will maintain the +logout_path+ and +logout_url+ helpers for use within your code.

=== Route Requirements

You can use the +:requirements+ option to enforce a format for any parameter in a route:

[source, ruby]
-------------------------------------------------------
map.connect 'photo/:id', :controller => 'photos', :action => 'show',
 :requirements => { :id => /[A-Z]\d{5}/ }
-------------------------------------------------------

This route would respond to URLs such as +/photo/A12345+. You can more succinctly express the same route this way:

[source, ruby]
-------------------------------------------------------
map.connect 'photo/:id', :controller => 'photos', :action => 'show',
  :id => /[A-Z]\d{5}/ 
-------------------------------------------------------

=== Route Conditions

Route conditions (introduced with the +:conditions+ option) are designed to implement restrictions on routes. Currently, the only supported restriction is +:method+:

[source, ruby]
-------------------------------------------------------
map.connect 'photo/:id', :controller => 'photos', :action => 'show',
 :conditions => { :method => :get }
-------------------------------------------------------

As with conditions in RESTful routes, you can specify +:get+, +:post+, +:put+, +:delete+, or +:any+ for the acceptable method.

=== Route Globbing

Route globbing is a way to specify that a particular parameter should be matched to all the remaining parts of a route. For example

[source, ruby]
-------------------------------------------------------
map.connect 'photo/*other', :controller => 'photos', :action => 'unknown',
-------------------------------------------------------

This route would match +photo/12+ or +/photo/long/path/to/12+ equally well, creating an array of path segments as the value of +params[:other]+.

=== Route Options

You can use +:with_options+ to simplify defining groups of similar routes:

[source, ruby]
-------------------------------------------------------
map.with_options :controller => 'photo' do |photo|
  photo.list '', :action => 'index'
  photo.delete ':id/delete', :action => 'delete'
  photo.edit ':id/edit', :action => 'edit'
end
-------------------------------------------------------

The importance of +map.with_options+ has declined with the introduction of RESTful routes.

== Formats and respond_to

There's one more way in which routing can do different things depending on differences in the incoming HTTP request: by issuing a response that corresponds to what the request specifies that it will accept. In Rails routing, you can control this with the special +:format+ parameter in the route.

For instance, consider the second of the default routes in the boilerplate +routes.rb+ file:

[source, ruby]
-------------------------------------------------------
map.connect ':controller/:action/:id.:format'
-------------------------------------------------------

This route matches requests such as +/photo/edit/1.xml+ or +/photo/show/2.rss+. Within the appropriate action code, you can issue different responses depending on the requested format:

[source, ruby]
-------------------------------------------------------
respond_to do |format|
  format.html # return the default template for HTML
  format.xml { render :xml => @photo.to_xml }
end
-------------------------------------------------------

=== Specifying the Format with an HTTP Header

If there is no +:format+ parameter in the route, Rails will automatically look at the HTTP Accept header to determine the desired format.

=== Recognized MIME types

By default, Rails recognizes +html+, +text+, +json+, +csv+, +xml+, +rss+, +atom+, and +yaml+ as acceptable response types. If you need types beyond this, you can register them in your environment:

[source, ruby]
-------------------------------------------------------
Mime::Type.register "image/jpg", :jpg
-------------------------------------------------------

== The Default Routes

When you create a new Rails application, +routes.rb+ is initialized with two default routes:

[source, ruby]
-------------------------------------------------------
map.connect ':controller/:action/:id'
map.connect ':controller/:action/:id.:format'
-------------------------------------------------------

These routes provide reasonable defaults for many URLs, if you're not using RESTful routing.

NOTE: The default routes will make every action of every controller in your application accessible to GET requests. If you've designed your application to make consistent use of RESTful and named routes, you should comment out the default routes to prevent access to your controllers through the wrong verbs. If you've had the default routes enabled during development, though, you need to be sure that you haven't unwittingly depended on them somewhere in your application - otherwise you may find mysterious failures when you disable them.

== The Empty Route

Don't confuse the default routes with the empty route. The empty route has one specific purpose: to route requests that come in to the root of the web site. For example, if your site is example.com, then requests to +http://example.com+ or +http://example.com/+ will be handled by the empty route.

=== Using map.root

The preferred way to set up the empty route is with the +map.root+ command:

[source, ruby]
-------------------------------------------------------
map.root :controller => "pages", :action => "main"
-------------------------------------------------------

The use of the +root+ method tells Rails that this route applies to requests for the root of the site.

For better readability, you can specify an already-created route in your call to +map.root+:

[source, ruby]
-------------------------------------------------------
map.index 'index', :controller => "pages", :action => "main"
map.root :index
-------------------------------------------------------

Because of the top-down processing of the file, the named route must be specified _before_ the call to +map.root+.

=== Connecting the Empty String

You can also specify an empty route by explicitly connecting the empty string:

[source, ruby]
-------------------------------------------------------
map.connect '', :controller => "pages", :action => "main"
-------------------------------------------------------

TIP: If the empty route does not seem to be working in your application, make sure that you have deleted the file +public/index.html+ from your Rails tree.

== Inspecting and Testing Routes

Routing in your application should not be a "black box" that you never open. Rails offers built-in tools for both inspecting and testing routes.

=== Seeing Existing Routes with rake

If you want a complete list of all of the available routes in your application, run the +rake routes+ command. This will dump all of your routes to the console, in the same order that they appear in +routes.rb+. For each route, you'll see:

* The route name (if any)
* The HTTP verb used (if the route doesn't respond to all verbs)
* The URL pattern
* The routing parameters that will be generated by this URL

For example, here's a small section of the +rake routes+ output for a RESTful route:

-------------------------------------------------------------------------------------------------------
          users GET  /users          {:controller=>"users", :action=>"index"}
formatted_users GET  /users.:format  {:controller=>"users", :action=>"index"}
                POST /users          {:controller=>"users", :action=>"create"}
                POST /users.:format  {:controller=>"users", :action=>"create"}
-------------------------------------------------------------------------------------------------------

TIP: You'll find that the output from +rake routes+ is much more readable if you widen your terminal window until the output lines don't wrap.

=== Testing Routes

Routes should be included in your testing strategy (just like the rest of your application). Rails offers three link:http://api.rubyonrails.com/classes/ActionController/Assertions/RoutingAssertions.html[built-in assertions] designed to make testing routes simpler:

* +assert_generates+
* +assert_recognizes+
* +assert_routing+

==== The +assert_generates+ Assertion

Use +assert_generates+ to assert that a particular set of options generate a particular path. You can use this with default routes or custom routes

[source, ruby]
-------------------------------------------------------
assert_generates "/photos/1", { :controller => "photos", :action => "show", :id => "1" }
assert_generates "/about", :controller => "pages", :action => "about"
-------------------------------------------------------

==== The +assert_recognizes+ Assertion

The +assert_recognizes+ assertion is the inverse of +assert_generates+. It asserts that Rails recognizes the given path and routes it to a particular spot in your application.

[source, ruby]
-------------------------------------------------------
assert_recognizes { :controller => "photos", :action => "show", :id => "1" }, "/photos/1"
-------------------------------------------------------

You can supply a +:method+ argument to specify the HTTP verb:

[source, ruby]
-------------------------------------------------------
assert_recognizes { :controller => "photos", :action => "create" }, { :path => "photos", :method => :post }
-------------------------------------------------------

You can also use the RESTful helpers to test recognition of a RESTful route:

[source, ruby]
-------------------------------------------------------
assert_recognizes new_photo_url, { :path => "photos", :method => :post }
-------------------------------------------------------

==== The +assert_routing+ Assertion

The +assert_routing+ assertion checks the route both ways: it tests that the path generates the options, and that the options generate the path. Thus, it combines the functions of +assert_generates+ and +assert_recognizes+.

[source, ruby]
-------------------------------------------------------
assert_routing { :path => "photos", :method => :post }, { :controller => "photos", :action => "create" }
-------------------------------------------------------

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/3[Lighthouse ticket]

* October 4, 2008: Added additional detail on specifying verbs for resource member/collection routes , by link:../authors.html#mgunderloy[Mike Gunderloy]
* September 23, 2008: Added section on namespaced controllers and routing, by link:../authors.html#mgunderloy[Mike Gunderloy]
* September 10, 2008: initial version by link:../authors.html#mgunderloy[Mike Gunderloy]
