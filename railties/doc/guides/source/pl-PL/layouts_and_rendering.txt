Layouty i Renderowanie w Rails
==============================

Ten przewodnik opisuje podstawowe możliwości layoutów w modułach Action Controller i Action View. Po jego przeczytaniu powinieneś umieć:

* Używać różnorodnych metod renderujących wbudowanych w Rails
* Tworzyć layouty podzielone na wiele sekcji
* Używać podszablonów (ang. partials) by zastosować regułę DRY do swoich widoków
* Używać zagnieżdżonych szablonów (sub-szablony ang. nested layouts, sub-templates)

== Opis zawartości: Jak wszystko razem współgra

Ten poradnik skupia się na wzajemnym oddziaływaniu pomiędzy Kontrolerem a Widokiem we wzorcu Model-View-Controller (MVC). Jak wiesz, Kontroler jest odpowiedzialny za nadzorowanie całego procesu obsługi zapytań w Rails, pomimo że zazwyczaj przekazuje on każdy większy kod do Modelu. Natomiast gdy dojdzie do wysłania odpowiedzi użytkownikowi, Kontroler przekazuje to zadanie Widokowi. Tematem tego tutoriala jest właśnie to przekazywanie.

Ogólnie mówiąc to nadzorowanie wymaga zadecydowania, co powinno być przesłane jako odpowiedź, a następnie wywołania odpowiedniej metody w celu jej stworzenia. Jeśli odpowiedź jest rozwiniętym, skomplikowanym widokiem, Rails wykonuje dodatkową pracę by opakować widok w layout i ewentualnie dołączyć częściowe widoki. Te wszystkie możliwości zobaczysz w późniejszej części poradnika.

== Tworzenie odpowiedzi

Z punktu widzenia kontrolera, są trzy drogi, aby stworzyć odpowiedź HTTP:

* Wywołać +render+ by stworzyć pełną odpowiedź do odesłania przeglądarce
* Wywołać +redirect_to+ by wysłać kod HTTP informujący o przekierowaniu do przeglądarki
* Wywołać +head+ by stworzyć odpowiedź zawierającą tylko nagłówki HTTP i odesłać ją do przeglądarki

Wytłumaczę po kolei każdą z tych metod, ale najpierw kilka słów o najprostszej rzeczy, którą może wykonać kontroler w odpowiedzi na żądanie – nie robić nic :)

=== Domyślne renderowanie: strategia Convention Over Configuration w akcji

Słyszałeś zapewne, że Rails promuje strategię „convention over configuration”. Domyślny rendering jest wspaniałym tego przykładem. Standardowo, kontrolery w Rails automatycznie renderują widoki z nazwami odpowiadającymi akcjom. Na przykład, jeśli masz poniższy kod w klasie +BooksController+:

[source, ruby]
-------------------------------------------------------
def show
  @book = Book.find(params[:id])
end
-------------------------------------------------------

Rails automatycznie po wykonaniu metody wyrenderuje plik +app/views/books/show.html.erb+. Właściwie, jeśli masz domyślną regułę (route) catch-all w odpowiednim miejscu (+map.connect \':controller/:action/:id'+), Rails wyrenderuje nawet widoki, które nie mają żadnego kodu w kontrolerze. Na przykład, jeśli masz ustawioną domyślną regułę i nadejdzie żądanie dla +/books/sale_list+, Rails w odpowiedzi wyrenderuje +app/views/books/sale_list.html.erb+.

NOTE: Właściwe renderowanie jest wykonywane przez podklasę +ActionView::TemplateHandlers+. Ten tutorial nie zagłębia się w ten proces, ale należy pamiętać, że rozszerzenie pliku twojego widoku wpływa na wybór szablonu obsługi. W Rails 2, standardowymi rozszerzeniami są +.erb+dla ERB (HTML z osadzonym Rubim), +.rjs+dla RJS (JavaScript z Rubim) i +.builder+ dla Buildera (generator XML). Dodatkowo znajdziesz również pliki +.rhtml+ używane dla szablonów ERB i +.rxml+ dla szablonów Buildera, jednak obecnie te rozszerzenia są niezalecane i będą usuniętę w przyszłych wersjach Rails.

=== Używanie +render+

W większości przypadków, metoda +ActionController::Base#render+ wykonuje dużą część renderowania twojej aplikacji do użytku przeglądarki. Jest wiele dróg dostosowania zachowania funkcji +render+. Możesz wyrenderować domyślny widok dla szablonu Rails, lub specyficznego szablonu, lub pliku, lub wewnętrznego kodu lub dla niczego w ogóle. Możesz renderować tekst, JSON lub XML. Możesz również ustalić typ zawartości lub stanu HTTP wyrenderowanej odpowiedzi.

TIP: Jeśli chcesz zobaczyć dokładny wynik wywołania +render+ bez potrzeby sprawdzania tego w przeglądarce, możesz wywołać +render_to_string+. Ta metoda ma dokładnie takie same opcje jak +render+, ale zwraca string zamiast wysyłać odpowiedzi bezpośrednio do przeglądarki.

==== Renderowanie niczego

Prawdopodobnie najprostszą rzeczą jaką możemy zrobić z +render+ jest wyrenderowanie niczego.

[source, ruby]
-------------------------------------------------------
render :nothing => true
-------------------------------------------------------

To wyśle pustą odpowiedź do przeglądarki (jakkolwiek, będzie ona zawierała nagłówki statusu które ustawisz za pomocą opcji :status, omówionej poniżej).

TIP: Będziesz prawdopodobnie chciał używać metody +head+, omówionej poniżej, zamiast +render:nothing+. Umożliwia to dodatkową elastyczność i zaznacza, że generujesz tylko i wyłącznie nagłówki HTTP.

==== Renderowanie widoku akcji

Jeśli chcesz wyrenderować widok odnoszący się do innej akcji w ramach tego samego szablonu, możesz użyć funkcji +render+ razem z nazwą widoku:

[source, ruby]
-------------------------------------------------------
def update
  @book = Book.find(params[:id])
    if @book.update_attributes(params[:book])
      redirect_to(@book)
    else
      render "edit"
    end
  end
end
-------------------------------------------------------
Jeśli wywołanie +update_attributes+ się nie powiedzie, wywołanie akcji +update+ w kontrolerze wyrenderuje szablon +edit.html.erb+ należący do tego samego kontrolera.

Jeśli wolisz, możesz używasz symbolu zamiast stringu by określić akcję do wyrenderowania.

[source, ruby]
-------------------------------------------------------
def update
  @book = Book.find(params[:id])
    if @book.update_attributes(params[:book])
      redirect_to(@book)
    else
      render :edit
    end
  end
end
-------------------------------------------------------

Uściślając, możesz użyć +render+ z opcją +:action +(chociaż nie jest to już konieczne od Rails 2.3):

[source, ruby]
-------------------------------------------------------
def update
  @book = Book.find(params[:id])
    if @book.update_attributes(params[:book])
      redirect_to(@book)
    else
      render :action => "edit"
    end
  end
end
-------------------------------------------------------

WARNING: Używanie +render+ z +:action+ jest częstym źródłem nieporozumień dla początkujących programistów. Wybrana akcja jest używana do określenia który widok należy wyrenderować, ale Rails nie wykonuje żadnego kodu dla tej akcji w kontrolerze. Wszystkie zmienne z których będziesz korzystać w widoku muszą być ustawione w aktualnej akcji przed wywołaniem +render+.

==== Renderowanie szablonu akcji z innego kontrolera

Co zrobić jeśli chcesz wyrenderować szablon z zupełnie innego kontrolera z tego, który zawiera kod akcji? Możesz to zrobić za pomocą +render+, które pobiera całą ścieżkę (relatywną do +app/views/+) kontrolera do wyrenderowania. Dla przykładu, jeśli uruchamiasz kod w +AdminProductsController+, który znajduje się w +app/controllers/admin+, możesz wyrenderować wynik akcji do szablonu +app/views/products+ w ten sposób:

[source, ruby]
-------------------------------------------------------
render 'products/show'
-------------------------------------------------------

Rails wie, że widok ten należy do innego kontrolera dzięki wbudowanemu slashowi w ciąg znaków.  Jeśli chcesz to dodatkowo zaznaczyć w kodzie, możesz użyć opcji +:template+ (która była wymagana w Rails 2.2 i wcześniejszych):

[source, ruby]
-------------------------------------------------------
render :template => 'products/show'
-------------------------------------------------------

==== Renderowanie dowolnego pliku

Metoda +render+ może również korzystać z widoku, który znajduje się zupełnie poza aplikacją (gdy prawdopodobnie dzielisz widoki między dwoma aplikacjami):

[source, ruby]
-------------------------------------------------------
render "/u/apps/warehouse_app/current/app/views/products/show"
-------------------------------------------------------

Rails stwierdzi, że jest to renderowanie pliku dzięki slashowi na początku stringu. Chcąc to dodatkowo zaznaczyć, możesz użyć opcji +:file+ (która była wymagana w Rails 2.2 i wcześniejszych wersjach):

[source, ruby]
-------------------------------------------------------
render :file => "/u/apps/warehouse_app/current/app/views/products/show"
-------------------------------------------------------

Opcja +:file+ pobiera bezwzględną ścieżkę w systemie plików. Oczywiście, musisz mieć odpowiednie prawa do widoku, którego używasz do wyrenderowania zawartości.

NOTE: Domyślnie ten plik jest renderowany bez użycia aktualnego layoutu. Jeśli chcesz by Rails zastosowało aktualny layout musisz dodać opcję +layout=>true+.

TIP: Jeśli korzystasz z systemu Microsoft Windows, powinieneś używać opcji +:file+ do renderowania pliku, ponieważ nazwy plików w Windowsie nie mają tego samego formatu jak w Unixie.

==== Używanie +render+ z +:inline+

Metoda +render+ może obyć się bez jakiegokolwiek widoku, jeśli tylko użyjesz opcji +:inline+ by wspomóc ERB jako części wywołania metody. Jest to całkowicie poprawne:

[source, ruby]
-------------------------------------------------------
render :inline => "<% products.each do |p| %><p><%= p.name %><p><% end %>"
-------------------------------------------------------

WARNING: Rzadko jednak istnieje dobry powód by użyć tej opcji. Mieszanie ERB wewnątrz twoich kontrolerów niszczy zorientowanie Rails na MVC i powoduje, że innym developerom jest trudniej podążać za tokiem twojego myślenia. Zamiast tego lepiej używaj oddzielnych widoków erb.

Domyślnie, renderowanie inline używa ERB. Możesz zmusić je by użyło zamiast tego Buildera, za pomocą opcji +:type+:

[source, ruby]
-------------------------------------------------------
render :inline => "xml.p {'Horrid coding practice!'}", :type => :builder
-------------------------------------------------------

==== Używanie +render+ z +:update+

Możesz również renderować uaktualnienia stron oparte o javascript  inline używając opcji +:update+ w +render+:

[source, ruby]
-------------------------------------------------------
render :update do |page|
  page.replace_html 'warning', "Invalid options supplied"
end
-------------------------------------------------------

WARNING: Umieszczanie javascriptowych uaktualnień w twoim kontrolerze może zdawać się upraszczać małe aktualizacje, ale niszczy orientację MVC Rails i powoduje, że trudniej jest innym zrozumieć twój kod. Proponuję używać zamiast tego oddzielnych szablonów rjs, nie ważne jak mała nie byłaby dana aktualizacja.

==== Renderowanie tekstu

Możesz wysyłać zwykły tekst – bez jakichkolwiek znaczników – z powrotem do przeglądarki za pomocą opcji +:text+:

[source, ruby]
-------------------------------------------------------
render :text => "OK"
-------------------------------------------------------

TIP: Rendering zwykłego tekstu jest najbardziej użyteczne kiedy odpowiadasz na AJAX-owe zapytania, które spodziewają się czegoś więcej niż tylko kodu HTML.

NOTE: Domyślnie, jeśli korzystasz z opcji +:text+, plik zostanie wyrenderowany bez użycia aktualnego layoutu. Jeśli chcesz by Rails umieściło text wewnątrz aktualnego layoutu, musisz skorzystać z opcji +:layout=>true+.

==== Renderowanie JSON

JSON jest formatem danych javascript wykorzystywanym przez wiele bibliotek AJAX. Rails ma wbudowaną obsługę konwersji obiektów do JSON i renderowania go później z powrotem do przeglądarki:

[source, ruby]
-------------------------------------------------------
render :json => @product
-------------------------------------------------------

TIP: Nie musisz wywoływać funkcji +to_json+ na obiekcie który chcesz wyrenderować. Jeśli użyjesz opcji +:json, render+ automatycznie wywoła to +to_json+ za ciebie.

==== Renderowanie XML

Rails ma także wbudowaną obsługę konwersji obiektów XML i renderowania ich z powrotem do obiektu wywołującego:

[source, ruby]
-------------------------------------------------------
render :xml => @product
-------------------------------------------------------

TIP: Nie musisz wywoływać funkcji +to_xml+ na obiekcie który chcesz wyrenderować. Jeśli użyjesz opcji +:xml+, +render+ automatycznie wywoła +to_xml+ za ciebie.

==== Renderowanie Vanilla JavaScript

Rails może renderować vanilla JavaScript (jako alternatywę do używania +update+ z plikiem +.rjs+):

[source, ruby]
-------------------------------------------------------
render :js => "alert('Hello Rails');"
-------------------------------------------------------

Będzie to wysyłać pobrany ciąg do przeglądarki z typem MIME +text/javascript+.

==== Opcje dla +render+

Wywołanie metody +render+ generalnie akceptuje cztery opcje:

* +:content_type+
* +:layout+
* +:status+
* +:location+

===== The +:content_type+ Option

Domyślnie Rails dostarczy wynik operacji renderowania z typem zawartości MIME +text/html+ (lub +application/json+ jeśli używasz opcji +:json+ lub +application/xm+l dla opcji +:xml+). Możliwe, że będziesz chciał to zmienić i możesz to zrobić  poprzez ustawienie opcji +:content_type+:

[source, ruby]
-------------------------------------------------------
render :file => filename, :content_type => 'application/rss'
-------------------------------------------------------

===== Opcja +:layout+

W większości opcji renderowania, renderowana zawartość jest wyświetlana jako część aktualnego layoutu. Poznasz dokładniej layouty i jak z nich korzystać w dalszej części tego przewodnika.

Możesz użyć opcji +:layout+ by zakomunikować Rails by użyło określonego pliku jako layout dla bieżącej akcji.

[source, ruby]
-------------------------------------------------------
render :layout => 'special_layout'
-------------------------------------------------------

Możesz również powiedzieć Rails by renderować bez jakiegokolwiek layoutu:

[source, ruby]
-------------------------------------------------------
render :layout => false
-------------------------------------------------------

===== Opcja +:status+

Rails może automatycznie generować odpowiedzi z poprawnym kodem HTML (w większości przypadków +200 OK+). Aby to zmienić możesz użyć opcji +:status+:

[source, ruby]
-------------------------------------------------------
render :status => 500
render :status => :forbidden
-------------------------------------------------------

Rails rozumie zarówno liczbowe kody stanu jak i odpowiadające im symbole. Listę kodów stanu możesz znaleźć w +actionpack/lib/action_controller/status_codes.rb+. Możesz również zobaczyć tam jak mapowane są symbole na kody stanu.

===== Opcja +:location+

Możesz używać opcji :location by ustawić nagłówek HTTP +Location+:

[source, ruby]
-------------------------------------------------------
render :xml => photo, :location => photo_url(photo)
-------------------------------------------------------

==== Znajdowanie Layoutów

Aby znaleźć bieżący layout, Rails najpierw szuka pliku w +app/views/layouts+ z taką samą nazwą bazową jak kontroler. Na przykład, renderowanie akcji z klasy +PhotosController+ użyje +/app/views/layouts/photos.html.erb+. Jeśli nie ma specyficznego layoutu dla danego kontrolera Rails użyje +/app/views/layouts/application.html.erb+. Jeśli nie ma layoutu +.erb+, Rails użyje layoutu +.builder+ jeśli taki istnieje. Rails również dostarcza kilka sposobów na bardziej precyzyjne przypisanie konkretnego layoutu do poszczególnych kontrolerów i akcji.

===== Określenie layoutów na poziomie kontrolera

Możesz nadpisać konwencje automatycznych layoutów w swoim kontrolerze za pomocą deklaracji +layout+. Na przykład:

[source, ruby]
-------------------------------------------------------
class ProductsController < ApplicationController
  layout "inventory"
  #...
end
-------------------------------------------------------

Z tą deklaracją, wszystkie metody w +ProductsController+ będą korzystać z +app/views/layouts/inventory.html.erb+ dla ich layoutu.

Aby przypisać konkretny layout dla całej aplikacji, użyj deklaracji w swojej klasie +ApplicationController+:

[source, ruby]
-------------------------------------------------------
class ApplicationController < ActionController::Base
  layout "main"
  #...
end
-------------------------------------------------------

Z tą deklaracją, wszystkie widoki w całej aplikacji będą korzystać z +app/views/layouts/main.html.erb+ dla ich layoutów.

===== Wybór layoutu w czasie wykonania

Możesz użyć symbolu dla odroczenia wyboru layoutu aż do czasu w którym przetwarzane jest zapytanie:

[source, ruby]
-------------------------------------------------------
class ProductsController < ApplicationController
  layout :products_layout
  
  def show
    @product = Product.find(params[:id])
  end

  private
    def products_layout
      @current_user.special? ? "special" : "products"
    end

end
-------------------------------------------------------

Teraz, jeśli bieżący użytkownik jest użytkownikiem specjalnym, to otrzyma specjalny layout podczas przeglądania produktów. Możesz nawet użyć metody inline do wyboru layoutu:

[source, ruby]
-------------------------------------------------------
class ProductsController < ApplicationController
  layout proc{ |controller| controller.
  # ...	
end
-------------------------------------------------------

===== Warunkowe layouty

Layouty określone w kontrolerze obsługują opcje +:only+ i +:except+, które pobierają albo pojedynczą nazwę metody albo tablicę nazw:

-------------------------------------------------------
class ProductsController < ApplicationController
  layout "inventory", :only => :index
  layout "product", :except => [:index, :rss]
  #...
end
-------------------------------------------------------

Z tymi deklaracjami, layout +inventory+ byłby wykorzystywany tylko do metody +index+, layout +product+ byłby wykorzystywany do wszystkiego oprócz metody +rss+, a metoda +rss+ będzie mieć określony layout poprzez zasady automatycznego layoutu.

===== Dziedziczenie layoutów

Layouty są dzielone w dół hierarchii zaś bardziej konkretne layouty zawsze zasłaniają te bardziej ogólne. Na przykład:

+application_controller.rb+:

[source, ruby]
-------------------------------------------------------
class ApplicationController < ActionController::Base
  layout "main"
  #...
end
-------------------------------------------------------

+posts_controller.rb+:

[source, ruby]
-------------------------------------------------------
class PostsController < ApplicationController
  # ...
end
-------------------------------------------------------

+special_posts_controller.rb+:

[source, ruby]
-------------------------------------------------------
class SpecialPostsController < PostsController
  layout "special"
  # ...
end
-------------------------------------------------------

+old_posts_controller.rb+:

[source, ruby]
-------------------------------------------------------
class OldPostsController < SpecialPostsController
  layout nil

  def show
    @post = Post.find(params[:id])
  end

  def index
    @old_posts = Post.older
    render :layout => "old"
  end
  # ...
end
-------------------------------------------------------

W tej aplikacji:

* Domyślnie, widoki będą renderowane z wykorzystaniem layoutu +main+
* +PostController#index+ będzie używać layoutu +main+
* +SpecialPostController#index+ będzie używał layoutu +special+
* +01dPostsController#show+ nie będzie używał żadnego layoutu
* +01dPostsController#index+ będzie używał layoutu +old+

==== Unikanie błędów podwójnego renderowania

Prędzej czy później, większość programistów Rails zobaczy komunikat o błędzie „Can only render od redirect once per action”. Chociaż jest to irytujące, jest to stosunkowo łatwe do naprawienia. Zwykle dzieje się to z powodu niezrozumienia podstaw działania metody +render+.

Na przykład, oto fragment kodu, który powoduje ten błąd:

[source, ruby]
-------------------------------------------------------
def show
  @book = Book.find(params[:id])
  if @book.special?
    render :action => "special_show"
  end
end
-------------------------------------------------------

Jeśli +@book.special?+ ewaluuje do +true+, Rails rozpocznie proces renderowania by zrzutować zmienną +@book+ w widoku +special_show+. Ale to _nie_ zatrzyma reszty kodu w akcji +show+ przed wykonaniem i jeśli Rails dojdzie do końca akcji zacznie renderować widok +show+ i wyrzuci błąd. Rozwiązanie jest proste: upewnij się, że masz tylko jedno wywołanie +render+ lub +redirect+ w jednej części kodu. Jedną z rzeczy które mogą pomóc jest +and return+. Oto poprawiona wersja metody:

[source, ruby]
-------------------------------------------------------
def show
  @book = Book.find(params[:id])
  if @book.special?
    render :action => "special_show" and return
  end
end
-------------------------------------------------------

=== Używanie +redirect_to+

Innym sposobem by obsłużyć wracające odpowiedzi na żądanie HTTP jest użycie +redirect_to+. Jak widziałeś, +render+ informuje Rails który widok użyć do konstrukcji odpowiedzi. Metoda +redirect_to+ robi coś zupełnie innego: mówi przeglądarce by wysłać nowe zapytanie o inny adres URL. Na przykład można przekierować z dowolnego miejsca w kodzie do indeksu zdjęć twojej aplikacji za pomocą tego wywołania:

[source, ruby]
-------------------------------------------------------
redirect_to photos_path
-------------------------------------------------------

Możesz korzystać z +redirect_to+ z wszystkimi argumentami które mogłeś użyć w +link_to+ lub +url_for+. W dodatku, istnieje specjalne przekierowanie, które wysyła użytkownika z powrotem tam z kąd przyszedł:

-------------------------------------------------------
redirect_to :back
-------------------------------------------------------

==== Uzyskanie innego kodu statusu przekierowania

Rails wykorzystuje kodu statusu HTTP 302 (stałe przekierowanie) gdy wywołujesz +redirect_to+. Jeśli chciałbyś użyć innego kodu statusu (prawdopodobnie 301, tymczasowe przekierowanie) możesz to zrobić za pomocą opcji +:status+:

-------------------------------------------------------
redirect_to photos_path, :status => 301
-------------------------------------------------------

Podobnie jak opcja +:status+ dla +render+, +:status+ dla +redirect_to+ akceptuje zarówno numeryczne jak i symboliczne oznaczenia nagłówka.

==== Różnica pomiędzy +render+ a +redirect+

Czasami niedoświadczony developer traktuje +redirect_to+ jako swego rodzaju polecenie +goto+, przenosząc wykonanie programu z jednego miejsca do innego miejsca w kodzie. To _nie_ jest prawidłowe. Twój kod przestaje się wykonywać i czeka na nowe zapytanie przeglądarki. Po prostu mówisz przeglądarce jakie następne zapytanie powinna zrobić poprzez wysłanie kodu HTTP 302.

Przeanalizuj te działania by zobaczyć róznicę:

[source, ruby]
-------------------------------------------------------
def index
  @books = Book.find(:all)
end

def show
  @book = Book.find(params[:id])
  if @book.nil?
    render :action => "index" and return
  end
end
-------------------------------------------------------

Kod w tej formie prawdopodobnie będzie stanowić problem jeśli zmienna +@book+ jest ustawiona na +nil+. Pamiętaj, +render:action+ nie uruchamia żadnego kodu w docelowej akcji, więc nic nie ustawi zmiennej +@books+ na wartość, której oczekuje widok +index+. Jednym sposobem aby to naprawić jest przekierowanie zamiast renderowania:

[source, ruby]
-------------------------------------------------------
def index
  @books = Book.find(:all)
end

def show
  @book = Book.find(params[:id])
  if @book.nil?
    redirect_to :action => "index" and return
  end
end
-------------------------------------------------------

Ten kod spowoduje, że przeglądarka wykona nowe zapytanie o stronę index, kod w metodzie +index+ będzie uruchomiony i wszystko będzie działać tak jak powinno.

=== Używanie +head+ do budowania odpowiedzi tylko z nagłówkami

Metoda head istnieje po to by odesłać do przeglądarki odpowiedzi zawierające tylko nagłówki. Zapewnia to bardziej oczywistą alternatywę +render:nothing+. Metoda +head+ bierze jedną odpowiedź, która jest interpretowana jako hash z nazw nagłówków i wartości. Na przykład możesz zwrócić tylko nagłówek błędu:

[source, ruby]
-------------------------------------------------------
head :bad_request
-------------------------------------------------------

Można też korzystać z innych nagłówków HTTP do przekazania dodatkowych informacji:

[source, ruby]
-------------------------------------------------------
head :created, :location => photo_path(@photo)
-------------------------------------------------------

== Strukturyzacja layoutów

Kiedy Rails renderuje widok jako odpowiedź czyni to poprzez połączenie widoku z bieżącym layoutem (stosując zasady znalezienia aktualnego layoutu które zostały omówione we wcześniejszej części tutoriala). W layoucie masz dostęp do trzech narzędzi służących do łączenia różnych bitów wyjścia do postaci ogólnej odpowiedzi:

* Asset tags
* +yield+ i +content_for+
* Podszablony

Zajmiemy się omówieniem każdej z nich po kolei.

=== Asset Tags

Asset tags dostarczają metod na generowanie kodu HTML który łączy widoki z elementami zewnętrznymi jak obrazki, javascript, arkusze stylów i kanały. Istnieją cztery typy tagów włączających:

* auto_discovery_link_tag
* javascript_include_tag
* stylesheet_link_tag
* image_tag

You can use these tags in layouts or other views, although the tags other than +image_tag+ are most commonly used in the +<head>+ section of a layout.

WARNING: The asset tags do _not_ verify the existence of the assets at the specified locations; they simply assume that you know what you're doing and generate the link.

==== Włączanie kanałów za pomocą +auto_discovery_link_tag+

+auto_discovery_link_tag helper+ buduje HTML który większość przeglądarek i czytników wiadomości może użyć do sprawdzenia czy istnieją kanały RSS lub ATOM. Pobiera to typ połączenia (+:rss+ or +:atom+),  hash opcji które są przekazywane poprzez url_for i hash opcji dla tagu:

[source, ruby]
-------------------------------------------------------
<%= auto_discovery_link_tag(:rss, {:action => "feed"}, {:title => "RSS Feed"}) %>
-------------------------------------------------------

Istnieją trzy opcje dostępne dla  +auto_discovery_link_tag+:

* +:rel+ określa wartość +rel+ w połączeniu (domyślnie ustawione na "alternate")
* +:type+ określa dokładny typ MIME. Rails automatycznie wygeneruje odpowiedni typ MIME
* +:title+ określa tytuł połączenia

==== Włączanie plików JavaScript za pomocą +javascript_include_tag+

Narzędzie +javascript_include_tag+ zwraca tag HTML +<script>+ dla każdego dostarczonego źródła. Rails szuka tych plików domyślnie w +public/javascripts+, ale jeśli wolisz można podać pełną ścieżkę w stosunku do głównego katalogu lub adresu URL. Na przykład aby włączyć +public/javascripts/main.js+:
	
[source, ruby]
-------------------------------------------------------
<%= javascript_include_tag "main" %>
-------------------------------------------------------

By włączyć +public/javascripts/main.js+ i +public/javascripts/columns.js+:

[source, ruby]
-------------------------------------------------------
<%= javascript_include_tag "main", "columns" %>
-------------------------------------------------------

By włączyć +public/javascripts/main.js+ i +public/photos/columns.js+:

[source, ruby]
-------------------------------------------------------
<%= javascript_include_tag "main", "/photos/columns" %>
-------------------------------------------------------

By włączyć +http://example.com/main.js+:

[source, ruby]
-------------------------------------------------------
<%= javascript_include_tag "http://example.com/main.js" %>
-------------------------------------------------------

Opcja +defaults+ wczytuje biblioteki Prototype i Scriptaculous:

[source, ruby]
-------------------------------------------------------
<%= javascript_include_tag :defaults %>
-------------------------------------------------------

Opcja +all+ wczytuje każdy plik javascript w +public/javascripts+, zaczynając od bibliotek Prototype i Scriptaculous:

[source, ruby]
-------------------------------------------------------
<%= javascript_include_tag :all %>
-------------------------------------------------------

Możesz dołączyć opcję +:recursive+ by ładować również pliki w podfolderach +public/javascripts+:

[source, ruby]
-------------------------------------------------------
<%= javascript_include_tag :all, :recursive => true %>
-------------------------------------------------------

Jeśli ładujesz wiele plików javascript, możesz polepszyć efektywność poprzez połączenie wielu plików w pojedyńczy plik do ściągnięcia. By zrobić to w czasie wykonania, zaznacz +:cache => true+ wewnątrz +javascript_include_tag+:

[source, ruby]
-------------------------------------------------------
<%= javascript_include_tag "main", "columns", :cache => true %>
-------------------------------------------------------

Domyślnie połączony plik będzie dostarczony jako +javascripts/all.js+. Możesz zamiast tego wybrać lokalizację dla załączanego pliku:

[source, ruby]
-------------------------------------------------------
<%= javascript_include_tag "main", "columns", :cache => 'cache/main/display' %>
-------------------------------------------------------

Możesz również używać dynamicznych ścieżek takich jak +"cache/#{current_site}/main/display"+.
	
==== Włączanie plików CSS za pomocą +stylesheet_link_tag+

Narzędzie +stylesheet_link_tag+ zwraca tag HTML +<link>+ dla każdego dostarczonego źródła. Rails szuka tych plików domyślnie w +public/stylesheets+, ale jeśli wolisz, można podać pełną ścieżkę w stosunku do głównego katalogu lub adresu URL. Na przykład aby włączyć +public/stylesheets/main.cs+:
	
[source, ruby]
-------------------------------------------------------
<%= stylesheet_link_tag "main" %>
-------------------------------------------------------

By włączyć +public/stylesheets/main.css+ i +public/stylesheets/columns.css+:

[source, ruby]
-------------------------------------------------------
<%= stylesheet_link_tag "main", "columns" %>
-------------------------------------------------------

By włączyć +public/stylesheets/main.css+ i +public/photos/columns.css+:

[source, ruby]
-------------------------------------------------------
<%= stylesheet_link_tag "main", "/photos/columns" %>
-------------------------------------------------------

By włączyć +http://example.com/main.cs+:

[source, ruby]
-------------------------------------------------------
<%= stylesheet_link_tag "http://example.com/main.cs" %>
-------------------------------------------------------

Domyślnie +stylesheet_link_tag+ tworzy połączenia z +media="screen" rel="stylesheet" type="text/css"+. Możesz nadpisać dowolne z nich poprzez użycie odpowiedniej opcji (:media, :rel, or :type):

[source, ruby]
-------------------------------------------------------
<%= stylesheet_link_tag "main_print", media => "print" %>
-------------------------------------------------------

Opcja +all+ załącza każdy plik CSS w +public/stylesheets+:

[source, ruby]
-------------------------------------------------------
<%= stylesheet_link_tag :all %>
-------------------------------------------------------

Możesz wykorzystać opcję +:recursive+ by załączyć wszystkie pliki w podfolderach +public/stylesheets+:

[source, ruby]
-------------------------------------------------------
<%= stylesheet_link_tag :all, :recursive => true %>
-------------------------------------------------------

Jeśli wczytujesz wiele plików CSS, możesz polepszyć efektywność poprzez połączenie wielu plików w pojedynczy plik do ściągnięcia. By zrobić to w czasie wykonania, zaznacz +:cache => true+ wewnątrz +stylesheet_link_tag+:

[source, ruby]
-------------------------------------------------------
<%= stylesheet_link_tag "main", "columns", :cache => true %>
-------------------------------------------------------

Domyślnie połączony plik będzie dostarczony jako +stylesheets/all.css+. Możesz zamiast tego wybrać lokalizację dla załączanego pliku:	

[source, ruby]
-------------------------------------------------------
<%= stylesheet_link_tag "main", "columns", :cache => 'cache/main/display' %>
-------------------------------------------------------

Możesz również użyć dynamicznych ścieżek takich jak: +"cache/#{current_site}/main/display"+.
	
==== Załączanie obrazków za pomocą +image_tag+

Narzędzie +image_tag+ zwraca tag HTML +<image>+ dla każdego dostarczonego źródła. Rails szuka tych plików domyślnie w +public/images+. Jeśli nie podasz rozszerzenia domyślnie przyjmowane jest .png:

[source, ruby]
-------------------------------------------------------
<%= image_tag "header" %>
-------------------------------------------------------

Możesz podać ścieżkę do obrazka:
	
[source, ruby]
-------------------------------------------------------
<%= image_tag "icons/delete.gif" %>
-------------------------------------------------------

Możesz podać hash dodatkowych opcji HTML:
	
[source, ruby]
-------------------------------------------------------
<%= image_tag "icons/delete.gif", :height => 45 %>
-------------------------------------------------------

Istnieją również trzy specjalne opcje które można używać z +image_tag+:

* +:alt+ określa alternatywny tekst dla obrazka (który domyślnie jest nazwą pliku, napisaną wielkimi literami bez rozszerzenia)
* +:size+ ustawia zarówno szerokość jak i wysokość, w formacie "{width}x{height}" (for example, "150x125")
* +:mouseover+ ustawia alternatywny obrazek który ma być użyty w przypadku gdy wywołane jest zdarzenie onmouseover.

=== Zrozumienie +yield+

W ramach kontekstu layoutu, +yield+ identyfikuje sekcję do której powinna być wstawiona zawartość widoku. Najprostszym sposobem użycia jest posiadanie jednego +yield+, w które powinna być wstawiana cała zawartość obecnie renderowanego widoku.

[source, html]
-------------------------------------------------------
<html>
  <head>
  </head>
  <body>
	<%= yield %>
  <hbody>
</html>
-------------------------------------------------------

Można również tworzyć layout z wieloma miejscami wstawiania kodu.

[source, html]
-------------------------------------------------------
<html>
  <head>
	<%= yield :head %>
  </head>
  <body>
	<%= yield %>
  <hbody>
</html>
-------------------------------------------------------

Główna część widoku będzie zawsze renderowana do nienazwanego +yield+. Aby wyrenderować zawartość w nazwany +yield+, należy użyć metody +content_for+.

=== Używanie +content_for+

Metoda ta pozwala wstawić treść do bloku +yield+ w twoim layoucie. Używa się +content_for+ tylko po to by wstawić zawartość w nazwane yieldy. Dla przykładu, ten widok będzie współpracował z powyższym layoutem:

[source, html]
-------------------------------------------------------
<% content_for :head do %>
  <title>A simple page</title>
<% end %>

<p>Hello, Rails!</p>
-------------------------------------------------------

Wynik renderowania tej strony w ten layout powinien być taki:

[source, html]
-------------------------------------------------------
<html>
  <head>
	<title>A simple page</title>
  </head>
  <body>
	<p>Hello, Rails!</p>
  <hbody>
</html>
-------------------------------------------------------

Metoda +content_for+ jest bardzo przydatna kiedy twój layout posiada odrębne regiony takie jak paski boczne i stopki, które powinny mieć wstawiane własne bloki zawartości. Jest to także przydatne do wstawiania tagów które wczytują specyficzny dla danej strony plik javascript lub css w nagłówek layoutu.

=== Używanie podszablonów

Częściowe szablony (ang. partials templates) – zazwyczaj nazywane po prostu podszablonami (ang. partials) - są kolejnym narzędziem służącym do dzielenia procesu renderowania na mniejsze kawałki. Za pomocą podszablonów, możesz przenieść kod renderujący odpowiednią część odpowiedzi do jego własnego pliku.

==== Nazywanie podszablonów

By wyrenderować podszablon jako część widoku, musisz użyć metody render wewnątrz tego widoku i dołączyć opcję +:partial+:

[source, ruby]
-------------------------------------------------------
<%= render :partial => "menu" %>
-------------------------------------------------------

To wyrenderuje plik nazwany +_menu.html.erb+ w tym momencie wewnątrz aktualnie renderowanego widoku. Zauważ początkowe znak podkreślenia: podszablony są nazywane w ten sposób by odróżnić je od zwyczajnych widoków, nawet jeśli odnosi się do nich bez podkreślenia. To działa nawet jeśli włączasz podszablon z zupełnie innego folderu:

[source, ruby]
-------------------------------------------------------
<%= render :partial => "shared/menu" %>
-------------------------------------------------------

Ten kod włączy podszablon z +app/views/shared/_menu.html.erb+.

==== Korzystanie z podszablonów do uproszczenia widoków

Jednym ze sposobów wykorzystania podszablonów jest traktowanie ich jako odpowiednik procedur: jako sposób aby przenieść detale na zewnątrz widoku tak by łatwiej zrozumieć co się dzieje wewnątrz. Na przykład, możesz mieć widok który wygląda w ten sposób:

[source, html]
-------------------------------------------------------
<%= render :partial => "shared/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
...

<%= render :partial => "shared/footer" %>
-------------------------------------------------------

Tutaj, podszablony +_ad_banner.html.erb+ i +_footer.html.erb+  mogą zawierać zawartość, która jest dzielona międz wiele stron w twojej aplikacji. Nie ma potrzeby aby widzieć szczegółów tych sekcji, kiedy koncentrujesz się na konkretnej stronie.

TIP: W przypadku treści, które są dzielone pomiędzy wszystkie strony twojej aplikacji możesz użyć podszablonów bezpośrednio z layoutów.

==== Partial Layouts

Podszablon może użyć swojego własnego pliku layoutu, tak samo jak może to robić widok. Na przykład możesz odwołać się do niego w ten sposób:

[source, html]
-------------------------------------------------------
<%= render :partial => "link_area", :layout => "graybar" %>
-------------------------------------------------------

Będzie to szukać podszablonu nazwanego +_link_area.html.erb+ i wyrenderuje go używając +_graybar.html.erb+. Zauważ, że layouty dla podszablonów podlegają tym samym zasadom nazewnictwa co zwykłe podszablony i są umiejscowione w tym samym folderze w którym znajdują się im odpowiadające podszablony (nie w głównym folderze +layouts+).

==== Przekazywanie lokalnych zmiennych

Możesz również przekazać lokalne zmienne do podszablonów, czyniąc z nich nawet bardziej potężne i elastyczne narzędzie. Na przykład możesz użyć tej techniki do zredukowania powtarzania pomiędzy stronami new i edit, wciąż jednak utrzymując w nich nieco odmienną treść:

+new.html.erb+:

[source, html]
-------------------------------------------------------
<h1>New zone</h1>
<%= error_messages_for :zone %>
<%= render :partial => "form", :locals => { :button_label => "Create zone", :zone => @zone } %>
-------------------------------------------------------

+edit.html.erb+:

[source, html]
-------------------------------------------------------
<h1>Editing zone</h1>
<%= error_messages_for :zone %>
<%= render :partial => "form", :locals => { :button_label => "Update zone", :zone => @zone } %>
-------------------------------------------------------

+_form.html.erb:+

[source, html]
-------------------------------------------------------
<% form_for(zone) do |f| %>
	<p>
	  <b>Zone name</b><br />
	  <%= f.text_field :name %>
	</p>
  <p>
    <%= f.submit button_label %>
  </p>
<% end %>
-------------------------------------------------------

Jakkolwiek ten sam podszablon będzie renderowany w obu widokach, etykieta na przycisku wysyłającym jest kontrolowana przez lokalną zmienną przekazywaną do podszablonów.

Każdy podszablon ma także lokalną zmienną z taką samą nazwą jak on sam (minus podkreślenie). Możesz przekazać obiekt do tej lokalnej zmiennej za pomocą opcji +:object+.

[source, html]
-------------------------------------------------------
<%= render :partial => "customer", :object => @new_customer %>
-------------------------------------------------------

Wewnątrz podszablonu +customer+, zmienna +@customer+ będzie odwoływać się do +@new_customer+ od rodzica.

WARNING: W poprzednich wersjach Rails, domyślna zmienna lokalna szukała instancji zmiennej o takiej samej nazwie jak podszablon w rodzicu. Takie zachowanie jest niezalecane w Rails 2.2 i będzie usunięte w przyszłych wersjach.

Jeśli masz instancje modelu do wyrenderowania w podszablonie możesz użyć skróconego zapisu:

[source, html]
-------------------------------------------------------
<%= render :partial => @customer %>
-------------------------------------------------------

Zakładając, że zmienna +@customer+ zawiera instancje modelu +Customer+, użyty zostanie +_customer.html.erb+ do renderowania.

==== Renderowanie kolekcji

Podszablony są bardzo przydatne w renderowaniu kolekcji . Kiedy przekazujesz kolekcje do podszablonu poprzez opcję +:collection+, podszablon będzie wstawiony do każdego elementu kolekcji.

+index.html.erb+:

[source, html]
-------------------------------------------------------
<h1>Products</h1>
<%= render :partial => "product", :collection => @products %>
-------------------------------------------------------

+_product.html.erb+:

[source, html]
-------------------------------------------------------
<p>Product Name: <%= product.name %></p>
-------------------------------------------------------

Kiedy podszablon jest renderowany z mnogą kolekcją, to każda indywidualna instancja podszablonu ma dostęp do renderowanego elementu kolekcji poprzez zmienną nazwaną po tym podszablonie. W tym przypadku podszablonem jest +_product+, i wewnątrz niego możesz odwołać się do +product+ by uzyskać aktualnie renderowaną instancję. Aby użyć wybranej nazwy zmiennej wewnątrz podszablonu, użyj opcji +:as+ podczas jego wywołania:

[source, html]
-------------------------------------------------------
<%= render :partial => "product", :collection => @products, :as => :item %>
-------------------------------------------------------

Dzięki tej zmianie można uzyskać dostęp do instancji kolekcji +@product+ jako lokalną zmienną +item+ wewnątrz podszablonu.

TIP:  Rails tworzy również zmienną licznikową dostępną wewnątrz podszablonu wywołanego przez kolekcję, nazwaną po elemencie kolekcji z dodanym sufiksem +_counter+. Na przykład, jeśli renderujesz +@products+ wewnątrz podszablonu możesz odwołać się do +product_counter+ by dowiedzieć się ile razy podszablon został wyrenderowany.

Możesz również określić drugi podszablon do wyrenderowania pomiędzy instancjami głównego podszablonu poprzez użycie opcji +:spacer_template+:

[source, html]
-------------------------------------------------------
<%= render :partial => "product", :collection => @products, :spacer_template => "product_ruler" %>
-------------------------------------------------------

Rails wyrenderuje podszablon +_product_ruler+ (bez danych przekazywanych do niego) pomiędzy każdą parą podszablonów +_product+.

Jest również dostępna skrócona wersja zapisu dla renderowania kolekcji. Na przykład, jeśli +@products+ jest kolekcją produktów to możesz wyrenderować tą kolekcję w ten sposób:

+index.html.erb+:

[source, html]
-------------------------------------------------------
<h1>Products</h1>
<%= render :partial => @products %>
-------------------------------------------------------

+_product.html.erb+:

[source, html]
-------------------------------------------------------
<p>Product Name: <%= product.name %></p>
-------------------------------------------------------

Rails określa nazwę podszablonu do użycia poprzez patrzenie na nazwę modelu w kolekcji. W istocie, można również stworzyć różnorodną kolekcję i renderować ją w ten sposób, a Rails wybierze właściwy podszablon dla każdego członka kolekcji.

+index.html.erb+:

[source, html]
-------------------------------------------------------
<h1>Contacts</h1>
<%= render :partial => [customer1, employee1, customer2, employee2] %>
-------------------------------------------------------

+_customer.html.erb+:

[source, html]
-------------------------------------------------------
<p>Name: <%= customer.name %></p>
-------------------------------------------------------

+_employee.html.erb+:

[source, html]
-------------------------------------------------------
<p>Name: <%= employee.name %></p>
-------------------------------------------------------

W tym przypadku, Rails użyje podszablonu customer lub employee jako odpowiednie dla każdego elementu kolekcji.

=== Korzystanie z zagnieżdżonych layoutów

Może się okazać, że twoja aplikacja wymaga layoutu zupełnie różniącego się od zwyczajnego layoutu twojej aplikacji by obsłużyć to jednym kontrolerem. Zamiast powtarzać główny layout i tylko odpowiednio go edytować można tego dokonać za pomocą zagnieżdżonych layoutów (niekiedy nazywanych sub-szablonami (ang. sub-templates)). Oto przykład:

Załóżmy, że masz następujący layout ApplicationController:

+app/views/layouts/application.erb+

[source, html]
-------------------------------------------------------
<html>
<head>
  <title><%= @page_title %><title>
  <% stylesheet_tag 'layout' %>
  <style type="text/css"><%= yield :stylesheets %></style>
<head>
<body>
  <div id="top_menu">Top menu items here</div>
  <div id="menu">Menu items here</div>
  <div id="main"><%= yield %></div>
</body>
</html>
-------------------------------------------------------

Na stronach generowanych przez NewsController, chciałbyś ukryć górne menu i dodać prawe:

+app/views/layouts/news.erb+

[source, html]
-------------------------------------------------------
<% content_for :stylesheets do %>
  #top_menu {display: none}
  #right_menu {float: right; background-color: yellow; color: black}
<% end -%>
<% content_for :main %>
  <div id="right_menu">Right menu items here</div>
  <%= yield %>
  <% end -%>
<% render :file => 'layouts/application' %>
-------------------------------------------------------

NOTE: W wersji Rails przed Rails 2.3, powinieneś użyć +render \'layouts/applications\'+ zamiast +render :file => \'layouts/applications\'+

To wszystko. Widok News będzie używał nowego layoutu, ukrywającego górne menu i dodającego prawe menu wewnątrz div "content".

Istnieje kilka sposobów otrzymania podobnych wyników za pomocą różnych schematów wykorzystania sub-szablonów wykorzystujących tą technikę. Należy pamiętać, że nie ma limitu poziomu zagnieżdżenia. Można wykorzystać metodę +ActionView::render+ poprzez +render \'layouts/news\'+ by ulokować nowy layout w layoucie News.

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/15[Lighthouse ticket]

* December 27, 2008: Merge patch from Rodrigo Rosenfeld Rosas covering subtemplates
* December 27, 2008: Information on new rendering defaults by link:../authors.html#mgunderloy[Mike Gunderloy] 
* November 9, 2008: Added partial collection counter by link:../authors.html#mgunderloy[Mike Gunderloy] 
* November 1, 2008: Added +:js+ option for +render+ by link:../authors.html#mgunderloy[Mike Gunderloy] 
* October 16, 2008: Ready for publication by link:../authors.html#mgunderloy[Mike Gunderloy] 
* October 4, 2008: Additional info on partials (+:object+, +:as+, and +:spacer_template+) by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* September 28, 2008: First draft by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)








































